diff --git a/configure b/configure
index 10ad7ca0b0..97d0180bac 100755
--- a/configure
+++ b/configure
@@ -7734,7 +7734,7 @@ case "$XPLATFORM" in
     *-g++*)
 	# Check gcc's version
 	case "$(${QMAKE_CONF_COMPILER} -dumpversion)" in
-	    5*|4*|3.4*)
+	    8*|7*|6*|5*|4*|3.4*)
 		;;
             3.3*)
                 canBuildWebKit="no"
@@ -7820,12 +7820,12 @@ if [ "$CFG_GUI" = "no" ]; then
     canBuildWebKit="no"
 fi
 
-if [ "$CFG_SHARED" = "no" ]; then
-    echo
-    echo "WARNING: Using static linking will disable the WebKit module."
-    echo
-    canBuildWebKit="no"
-fi
+#if [ "$CFG_SHARED" = "no" ]; then
+   # echo
+   # echo "WARNING: Using static linking will disable the WebKit module."
+   # echo
+   # canBuildWebKit="no"
+#fi
 
 CFG_CONCURRENT="yes"
 if [ "$canBuildQtConcurrent" = "no" ]; then
@@ -8050,7 +8050,7 @@ g++*)
     3.*)
         COMPILER_VERSION="3.*"
         ;;
-    5*|4.*)
+    8*|7*|6*|5*|4.*)
         COMPILER_VERSION="4"
         ;;
     *)
diff --git a/mkspecs/features/win32/embed_manifest_dll.prf b/mkspecs/features/win32/embed_manifest_dll.prf
index cf96ee7017..824abcc14b 100644
--- a/mkspecs/features/win32/embed_manifest_dll.prf
+++ b/mkspecs/features/win32/embed_manifest_dll.prf
@@ -1,4 +1,4 @@
-!if(plugin:no_plugin_manifest):if(win32-msvc2005*|win32-msvc2008*|win32-msvc2010*):!static:equals(TEMPLATE, "lib") {
+!if(plugin:no_plugin_manifest):if(win32-msvc2005*|win32-msvc2008*|win32-msvc2010*|win32-msvc2012*|win32-msvc2013*|win32-msvc2015*):!static:equals(TEMPLATE, "lib") {
     MANIFEST_DIR = $$OBJECTS_DIR
     isEmpty(MANIFEST_DIR):MANIFEST_DIR = .
     NOPATH_TARGET = $$TARGET
diff --git a/mkspecs/features/win32/embed_manifest_exe.prf b/mkspecs/features/win32/embed_manifest_exe.prf
index 9bc77029ff..e4effaeb9e 100644
--- a/mkspecs/features/win32/embed_manifest_exe.prf
+++ b/mkspecs/features/win32/embed_manifest_exe.prf
@@ -1,4 +1,4 @@
-if(win32-msvc2005*|win32-msvc2008*|win32-msvc2010*):equals(TEMPLATE, "app") {
+if(win32-msvc2005*|win32-msvc2008*|win32-msvc2010*|win32-msvc2012*|win32-msvc2013*|win32-msvc2015*):equals(TEMPLATE, "app") {
     MANIFEST_DIR = $$OBJECTS_DIR
     isEmpty(MANIFEST_DIR):MANIFEST_DIR = .
     NOPATH_TARGET = $$TARGET
diff --git a/mkspecs/win32-msvc2008/qmake.conf b/mkspecs/win32-msvc2008/qmake.conf
index 5c31cdad79..b8631a8e7b 100644
--- a/mkspecs/win32-msvc2008/qmake.conf
+++ b/mkspecs/win32-msvc2008/qmake.conf
@@ -58,7 +58,7 @@ QMAKE_LINK              = link
 QMAKE_LFLAGS            = /NOLOGO /DYNAMICBASE /NXCOMPAT
 QMAKE_LFLAGS_RELEASE    = /INCREMENTAL:NO
 QMAKE_LFLAGS_RELEASE_WITH_DEBUGINFO = /DEBUG /OPT:REF
-QMAKE_LFLAGS_DEBUG      = /DEBUG
+QMAKE_LFLAGS_DEBUG      = /DEBUG /INCREMENTAL:NO
 QMAKE_LFLAGS_CONSOLE    = /SUBSYSTEM:CONSOLE
 QMAKE_LFLAGS_WINDOWS    = /SUBSYSTEM:WINDOWS
 QMAKE_LFLAGS_EXE        = \"/MANIFESTDEPENDENCY:type=\'win32\' name=\'Microsoft.Windows.Common-Controls\' version=\'6.0.0.0\' publicKeyToken=\'6595b64144ccf1df\' language=\'*\' processorArchitecture=\'*\'\"
diff --git a/mkspecs/win32-msvc2010/qmake.conf b/mkspecs/win32-msvc2010/qmake.conf
index 9e5711cc4e..356d8b1859 100644
--- a/mkspecs/win32-msvc2010/qmake.conf
+++ b/mkspecs/win32-msvc2010/qmake.conf
@@ -58,7 +58,7 @@ QMAKE_LINK              = link
 QMAKE_LFLAGS            = /NOLOGO /DYNAMICBASE /NXCOMPAT
 QMAKE_LFLAGS_RELEASE    = /INCREMENTAL:NO
 QMAKE_LFLAGS_RELEASE_WITH_DEBUGINFO = /DEBUG /OPT:REF
-QMAKE_LFLAGS_DEBUG      = /DEBUG
+QMAKE_LFLAGS_DEBUG      = /DEBUG /INCREMENTAL:NO
 QMAKE_LFLAGS_CONSOLE    = /SUBSYSTEM:CONSOLE
 QMAKE_LFLAGS_WINDOWS    = /SUBSYSTEM:WINDOWS
 QMAKE_LFLAGS_EXE        = \"/MANIFESTDEPENDENCY:type=\'win32\' name=\'Microsoft.Windows.Common-Controls\' version=\'6.0.0.0\' publicKeyToken=\'6595b64144ccf1df\' language=\'*\' processorArchitecture=\'*\'\"
diff --git a/mkspecs/win32-msvc2012/qmake.conf b/mkspecs/win32-msvc2012/qmake.conf
index 875978b8b3..963dcb21ef 100644
--- a/mkspecs/win32-msvc2012/qmake.conf
+++ b/mkspecs/win32-msvc2012/qmake.conf
@@ -58,7 +58,7 @@ QMAKE_LINK              = link
 QMAKE_LFLAGS            = /NOLOGO /DYNAMICBASE /NXCOMPAT
 QMAKE_LFLAGS_RELEASE    = /INCREMENTAL:NO
 QMAKE_LFLAGS_RELEASE_WITH_DEBUGINFO = /DEBUG /OPT:REF
-QMAKE_LFLAGS_DEBUG      = /DEBUG
+QMAKE_LFLAGS_DEBUG      = /DEBUG /INCREMENTAL:NO
 QMAKE_LFLAGS_CONSOLE    = /SUBSYSTEM:CONSOLE
 QMAKE_LFLAGS_WINDOWS    = /SUBSYSTEM:WINDOWS
 QMAKE_LFLAGS_EXE        = \"/MANIFESTDEPENDENCY:type=\'win32\' name=\'Microsoft.Windows.Common-Controls\' version=\'6.0.0.0\' publicKeyToken=\'6595b64144ccf1df\' language=\'*\' processorArchitecture=\'*\'\"
diff --git a/mkspecs/win32-msvc2013/qmake.conf b/mkspecs/win32-msvc2013/qmake.conf
index 3ebb1da97a..48f1867f42 100644
--- a/mkspecs/win32-msvc2013/qmake.conf
+++ b/mkspecs/win32-msvc2013/qmake.conf
@@ -16,7 +16,7 @@ QMAKE_LEX               = flex
 QMAKE_LEXFLAGS          =
 QMAKE_YACC              = byacc
 QMAKE_YACCFLAGS         = -d
-QMAKE_CFLAGS            = -nologo -Zm200 -Zc:wchar_t- -FS
+QMAKE_CFLAGS            = -nologo -Zm200 -Zc:wchar_t- -FS -wd"4099"
 QMAKE_CFLAGS_WARN_ON    = -W3
 QMAKE_CFLAGS_WARN_OFF   = -W0
 QMAKE_CFLAGS_RELEASE    = -O2 -MD
@@ -28,7 +28,7 @@ QMAKE_CFLAGS_MP         = -MP
 
 QMAKE_CXX               = $$QMAKE_CC
 QMAKE_CXXFLAGS          = $$QMAKE_CFLAGS
-QMAKE_CXXFLAGS_WARN_ON  = $$QMAKE_CFLAGS_WARN_ON -w34100 -w34189
+QMAKE_CXXFLAGS_WARN_ON  = $$QMAKE_CFLAGS_WARN_ON
 QMAKE_CXXFLAGS_WARN_OFF = $$QMAKE_CFLAGS_WARN_OFF
 QMAKE_CXXFLAGS_RELEASE  = $$QMAKE_CFLAGS_RELEASE
 QMAKE_CXXFLAGS_RELEASE_WITH_DEBUGINFO += $$QMAKE_CFLAGS_RELEASE_WITH_DEBUGINFO
@@ -58,7 +58,7 @@ QMAKE_LINK              = link
 QMAKE_LFLAGS            = /NOLOGO /DYNAMICBASE /NXCOMPAT
 QMAKE_LFLAGS_RELEASE    = /INCREMENTAL:NO
 QMAKE_LFLAGS_RELEASE_WITH_DEBUGINFO = /DEBUG /OPT:REF
-QMAKE_LFLAGS_DEBUG      = /DEBUG
+QMAKE_LFLAGS_DEBUG      = /DEBUG /INCREMENTAL:NO
 QMAKE_LFLAGS_CONSOLE    = /SUBSYSTEM:CONSOLE
 QMAKE_LFLAGS_WINDOWS    = /SUBSYSTEM:WINDOWS
 QMAKE_LFLAGS_EXE        = \"/MANIFESTDEPENDENCY:type=\'win32\' name=\'Microsoft.Windows.Common-Controls\' version=\'6.0.0.0\' publicKeyToken=\'6595b64144ccf1df\' language=\'*\' processorArchitecture=\'*\'\"
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/runtime/ArgList.h b/src/3rdparty/javascriptcore/JavaScriptCore/runtime/ArgList.h
index 8e1fdbe4b8..4944cc47e6 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/runtime/ArgList.h
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/runtime/ArgList.h
@@ -170,9 +170,6 @@ namespace JSC {
 
         void* operator new[](size_t);
         void operator delete[](void*);
-
-        void* operator new(size_t, void*);
-        void operator delete(void*, size_t);
     };
 
     class ArgList {
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/wtf/StringExtras.h b/src/3rdparty/javascriptcore/JavaScriptCore/wtf/StringExtras.h
index b1ec09f095..a1c4344bcc 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/wtf/StringExtras.h
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/wtf/StringExtras.h
@@ -36,6 +36,7 @@
 #if COMPILER(MSVC)
 // FIXME: why a COMPILER check instead of OS? also, these should be HAVE checks
 
+#  if _MSC_VER < 1900
 inline int snprintf(char* buffer, size_t count, const char* format, ...) 
 {
     int result;
@@ -45,6 +46,7 @@ inline int snprintf(char* buffer, size_t count, const char* format, ...)
     va_end(args);
     return result;
 }
+#  endif // _MSC_VER < 1900
 
 #if COMPILER(MSVC7) || OS(WINCE)
 
diff --git a/src/3rdparty/javascriptcore/JavaScriptCore/wtf/TypeTraits.h b/src/3rdparty/javascriptcore/JavaScriptCore/wtf/TypeTraits.h
index 7ba487fcb3..ede98e4f26 100644
--- a/src/3rdparty/javascriptcore/JavaScriptCore/wtf/TypeTraits.h
+++ b/src/3rdparty/javascriptcore/JavaScriptCore/wtf/TypeTraits.h
@@ -166,7 +166,12 @@ namespace WTF {
         typedef T Type;
     };
 
-#if (defined(__GLIBCXX__) && (__GLIBCXX__ >= 20070724) && defined(__GXX_EXPERIMENTAL_CXX0X__)) || (defined(_MSC_VER) && (_MSC_VER >= 1600))
+#if (defined(_MSC_VER) && (_MSC_VER >= 1900))
+
+    template<typename T> struct HasTrivialConstructor : public std::is_trivially_default_constructible<T> { };
+    template<typename T> struct HasTrivialDestructor : public std::is_trivially_destructible<T> { };
+
+#elif (defined(__GLIBCXX__) && (__GLIBCXX__ >= 20070724) && defined(__GXX_EXPERIMENTAL_CXX0X__)) || (defined(_MSC_VER) && (_MSC_VER >= 1600))
 
     // GCC's libstdc++ 20070724 and later supports C++ TR1 type_traits in the std namespace.
     // VC10 (VS2010) and later support C++ TR1 type_traits in the std::tr1 namespace.
diff --git a/src/3rdparty/javascriptcore/WebKit.pri b/src/3rdparty/javascriptcore/WebKit.pri
index 9aaaa996d8..30c8726ccc 100644
--- a/src/3rdparty/javascriptcore/WebKit.pri
+++ b/src/3rdparty/javascriptcore/WebKit.pri
@@ -22,7 +22,7 @@ isEmpty(OUTPUT_DIR) {
 
 DEFINES += BUILDING_QT__=1
 building-libs {
-    win32-msvc*|win32-icc: INCLUDEPATH += $$PWD/JavaScriptCore/os-win32
+    win32-msvc2008|win32-msvc2010|win32-msvc2012|win32-msvc2013|win32-icc: INCLUDEPATH += $$PWD/JavaScriptCore/os-win32
 } else {
     CONFIG(QTDIR_build) {
         QT += webkit
diff --git a/src/3rdparty/webkit/Source/JavaScriptCore/JavaScriptCore.pri b/src/3rdparty/webkit/Source/JavaScriptCore/JavaScriptCore.pri
index d8290cfe4e..bbec4c2946 100644
--- a/src/3rdparty/webkit/Source/JavaScriptCore/JavaScriptCore.pri
+++ b/src/3rdparty/webkit/Source/JavaScriptCore/JavaScriptCore.pri
@@ -53,7 +53,7 @@ symbian {
     INCLUDEPATH *= $$MW_LAYER_SYSTEMINCLUDE
 }
 
-win32-*: DEFINES += _HAS_TR1=0
+win32-msvc200*: DEFINES += _HAS_TR1=0
 
 DEFINES += BUILDING_JavaScriptCore BUILDING_WTF
 
diff --git a/src/3rdparty/webkit/Source/JavaScriptCore/JavaScriptCore.pro b/src/3rdparty/webkit/Source/JavaScriptCore/JavaScriptCore.pro
index a109179577..f20ffc36d1 100644
--- a/src/3rdparty/webkit/Source/JavaScriptCore/JavaScriptCore.pro
+++ b/src/3rdparty/webkit/Source/JavaScriptCore/JavaScriptCore.pro
@@ -22,7 +22,7 @@ contains(QT_CONFIG, embedded):CONFIG += embedded
 contains(QT_CONFIG, reduce_exports):CONFIG += hide_symbols
 unix:contains(QT_CONFIG, reduce_relocations):CONFIG += bsymbolic_functions
 
-CONFIG(QTDIR_build) {
+!contains(QT_CONFIG, webkit-debug):CONFIG(QTDIR_build) {
     # Remove the following 2 lines if you want debug information in JavaScriptCore
     CONFIG -= separate_debug_info
     CONFIG += no_debug_info
@@ -217,6 +217,12 @@ symbian: {
     QMAKE_CXXFLAGS.ARMCC += -OTime -O3
 }
 
+static {
+  !isEmpty(INSTALL_LIBS): target.path = $$INSTALL_LIBS
+  else: target.path = $$[QT_INSTALL_LIBS]
+  INSTALLS += target
+}
+
 lessThan(QT_GCC_MAJOR_VERSION, 5) {
     # GCC 4.5 and before
     lessThan(QT_GCC_MINOR_VERSION, 6) {
diff --git a/src/3rdparty/webkit/Source/JavaScriptCore/runtime/ArgList.h b/src/3rdparty/webkit/Source/JavaScriptCore/runtime/ArgList.h
index bb2d284212..b1763ae154 100644
--- a/src/3rdparty/webkit/Source/JavaScriptCore/runtime/ArgList.h
+++ b/src/3rdparty/webkit/Source/JavaScriptCore/runtime/ArgList.h
@@ -172,9 +172,6 @@ namespace JSC {
 
         void* operator new[](size_t);
         void operator delete[](void*);
-
-        void* operator new(size_t, void*);
-        void operator delete(void*, size_t);
     };
 
     class ArgList {
diff --git a/src/3rdparty/webkit/Source/JavaScriptCore/wtf/StringExtras.h b/src/3rdparty/webkit/Source/JavaScriptCore/wtf/StringExtras.h
index 371e33bf98..e039ada60e 100644
--- a/src/3rdparty/webkit/Source/JavaScriptCore/wtf/StringExtras.h
+++ b/src/3rdparty/webkit/Source/JavaScriptCore/wtf/StringExtras.h
@@ -37,6 +37,7 @@
 #if COMPILER(MSVC)
 // FIXME: why a COMPILER check instead of OS? also, these should be HAVE checks
 
+#if _MSC_VER < 1900
 inline int snprintf(char* buffer, size_t count, const char* format, ...) 
 {
     int result;
@@ -52,6 +53,7 @@ inline int snprintf(char* buffer, size_t count, const char* format, ...)
 
     return result;
 }
+#  endif // _MSC_VER < 1900
 
 inline double wtf_vsnprintf(char* buffer, size_t count, const char* format, va_list args)
 {
diff --git a/src/3rdparty/webkit/Source/JavaScriptCore/wtf/TypeTraits.h b/src/3rdparty/webkit/Source/JavaScriptCore/wtf/TypeTraits.h
index 44103cdd34..3705ba6b4a 100644
--- a/src/3rdparty/webkit/Source/JavaScriptCore/wtf/TypeTraits.h
+++ b/src/3rdparty/webkit/Source/JavaScriptCore/wtf/TypeTraits.h
@@ -179,7 +179,12 @@ namespace WTF {
         typedef T Type;
     };
 
-#if (defined(__GLIBCXX__) && (__GLIBCXX__ >= 20070724) && defined(__GXX_EXPERIMENTAL_CXX0X__)) || (defined(_MSC_VER) && (_MSC_VER >= 1600))
+#if (defined(_MSC_VER) && (_MSC_VER >= 1900))
+
+    template<typename T> struct HasTrivialConstructor : public std::is_trivially_default_constructible<T> { };
+    template<typename T> struct HasTrivialDestructor : public std::is_trivially_destructible<T> { };
+
+#elif (defined(__GLIBCXX__) && (__GLIBCXX__ >= 20070724) && defined(__GXX_EXPERIMENTAL_CXX0X__)) || (defined(_MSC_VER) && (_MSC_VER >= 1600))
 
     // GCC's libstdc++ 20070724 and later supports C++ TR1 type_traits in the std namespace.
     // VC10 (VS2010) and later support C++ TR1 type_traits in the std::tr1 namespace.
diff --git a/src/3rdparty/webkit/Source/WebCore/WebCore.pri b/src/3rdparty/webkit/Source/WebCore/WebCore.pri
index 6ea37fde14..3411f66590 100644
--- a/src/3rdparty/webkit/Source/WebCore/WebCore.pri
+++ b/src/3rdparty/webkit/Source/WebCore/WebCore.pri
@@ -170,6 +170,10 @@ contains(DEFINES, ENABLE_XSLT=1) {
     QT *= xmlpatterns
 }
 
+contains(DEFINES, ENABLE_ZLIB=1) {
+    include($$QT_SOURCE_TREE/src/3rdparty/zlib_dependency.pri)
+}
+
 contains(DEFINES, ENABLE_SQLITE=1) {
     !system-sqlite:exists( $${SQLITE3SRCDIR}/sqlite3.c ) {
             INCLUDEPATH += $${SQLITE3SRCDIR}
@@ -264,7 +268,7 @@ contains(DEFINES, ENABLE_WEBGL=1)|contains(CONFIG, texmap) {
     QT *= opengl
 }
 
-!CONFIG(webkit-debug):CONFIG(QTDIR_build) {
+!contains(QT_CONFIG, webkit-debug):CONFIG(QTDIR_build) {
     # Remove the following 2 lines if you want debug information in WebCore
     CONFIG -= separate_debug_info
     CONFIG += no_debug_info
diff --git a/src/3rdparty/webkit/Source/WebCore/WebCore.pro b/src/3rdparty/webkit/Source/WebCore/WebCore.pro
index a0d7d5d300..e424a325b6 100644
--- a/src/3rdparty/webkit/Source/WebCore/WebCore.pro
+++ b/src/3rdparty/webkit/Source/WebCore/WebCore.pro
@@ -16,7 +16,6 @@ CONFIG += staticlib
 DESTDIR = $$WEBCORE_DESTDIR
 
 DEFINES += BUILDING_WEBKIT
-DEFINES += QT_MAKEDLL
 
 contains(DEFINES, WTF_USE_QT_MOBILE_THEME=1) {
     DEFINES += ENABLE_NO_LISTBOX_RENDERING=1
@@ -34,30 +33,36 @@ contains(DEFINES, ENABLE_WCSS=1) {
     EXTRACSSVALUES += $$PWD/css/WCSSValueKeywords.in
 }
 
+CONFIG(debug, debug|release) {
+    SOURCES += accessibility/AccessibilityAllInOne.cpp
+} else {
+    SOURCES += \
+        accessibility/AccessibilityImageMapLink.cpp \
+        accessibility/AccessibilityMediaControls.cpp \
+        accessibility/AccessibilityMenuList.cpp \
+        accessibility/AccessibilityMenuListOption.cpp \
+        accessibility/AccessibilityMenuListPopup.cpp \
+        accessibility/AccessibilityObject.cpp \
+        accessibility/AccessibilityList.cpp \
+        accessibility/AccessibilityListBox.cpp \
+        accessibility/AccessibilityListBoxOption.cpp \
+        accessibility/AccessibilityProgressIndicator.cpp \
+        accessibility/AccessibilityRenderObject.cpp \
+        accessibility/AccessibilityScrollbar.cpp \
+        accessibility/AccessibilityScrollView.cpp \
+        accessibility/AccessibilitySlider.cpp \
+        accessibility/AccessibilityARIAGrid.cpp \
+        accessibility/AccessibilityARIAGridCell.cpp \
+        accessibility/AccessibilityARIAGridRow.cpp \
+        accessibility/AccessibilityTable.cpp \
+        accessibility/AccessibilityTableCell.cpp \
+        accessibility/AccessibilityTableColumn.cpp \
+        accessibility/AccessibilityTableHeaderContainer.cpp \
+        accessibility/AccessibilityTableRow.cpp \
+        accessibility/AXObjectCache.cpp
+}
+
 SOURCES += \
-    accessibility/AccessibilityImageMapLink.cpp \
-    accessibility/AccessibilityMediaControls.cpp \    
-    accessibility/AccessibilityMenuList.cpp \
-    accessibility/AccessibilityMenuListOption.cpp \
-    accessibility/AccessibilityMenuListPopup.cpp \
-    accessibility/AccessibilityObject.cpp \    
-    accessibility/AccessibilityList.cpp \    
-    accessibility/AccessibilityListBox.cpp \    
-    accessibility/AccessibilityListBoxOption.cpp \    
-    accessibility/AccessibilityProgressIndicator.cpp \    
-    accessibility/AccessibilityRenderObject.cpp \    
-    accessibility/AccessibilityScrollbar.cpp \
-    accessibility/AccessibilityScrollView.cpp \
-    accessibility/AccessibilitySlider.cpp \    
-    accessibility/AccessibilityARIAGrid.cpp \    
-    accessibility/AccessibilityARIAGridCell.cpp \    
-    accessibility/AccessibilityARIAGridRow.cpp \    
-    accessibility/AccessibilityTable.cpp \    
-    accessibility/AccessibilityTableCell.cpp \    
-    accessibility/AccessibilityTableColumn.cpp \    
-    accessibility/AccessibilityTableHeaderContainer.cpp \    
-    accessibility/AccessibilityTableRow.cpp \    
-    accessibility/AXObjectCache.cpp \
     bindings/generic/ActiveDOMCallback.cpp \
     bindings/generic/RuntimeEnabledFeatures.cpp
 
@@ -227,138 +232,144 @@ v8 {
         bindings/v8/V8WorkerContextErrorHandler.cpp \
         testing/v8/WebCoreTestSupport.cpp
 } else {
+    CONFIG(debug, debug|release) {
+        SOURCES += bindings/js/JSBindingsAllInOne.cpp
+    } else {
+        SOURCES += \
+            bindings/js/CallbackFunction.cpp \
+            bindings/js/DOMObjectHashTableMap.cpp \
+            bindings/js/DOMWrapperWorld.cpp \
+            bindings/js/GCController.cpp \
+            bindings/js/JSArrayBufferCustom.cpp \
+            bindings/js/JSAttrCustom.cpp \
+            bindings/js/JSCDATASectionCustom.cpp \
+            bindings/js/JSCSSFontFaceRuleCustom.cpp \
+            bindings/js/JSCSSImportRuleCustom.cpp \
+            bindings/js/JSCSSMediaRuleCustom.cpp \
+            bindings/js/JSCSSPageRuleCustom.cpp \
+            bindings/js/JSCSSRuleCustom.cpp \
+            bindings/js/JSCSSRuleListCustom.cpp \
+            bindings/js/JSCSSStyleDeclarationCustom.cpp \
+            bindings/js/JSCSSStyleRuleCustom.cpp \
+            bindings/js/JSCSSValueCustom.cpp \
+            bindings/js/JSCallbackData.cpp \
+            bindings/js/JSCanvasRenderingContext2DCustom.cpp \
+            bindings/js/JSCanvasRenderingContextCustom.cpp \
+            bindings/js/JSClipboardCustom.cpp \
+            bindings/js/JSConsoleCustom.cpp \
+            bindings/js/JSCoordinatesCustom.cpp \
+            bindings/js/JSCustomPositionCallback.cpp \
+            bindings/js/JSCustomPositionErrorCallback.cpp \
+            bindings/js/JSCustomVoidCallback.cpp \
+            bindings/js/JSCustomXPathNSResolver.cpp \
+            bindings/js/JSDOMBinding.cpp \
+            bindings/js/JSDOMFormDataCustom.cpp \
+            bindings/js/JSDOMGlobalObject.cpp \
+            bindings/js/JSDOMImplementationCustom.cpp \
+            bindings/js/JSDOMMimeTypeArrayCustom.cpp \
+            bindings/js/JSDOMPluginArrayCustom.cpp \
+            bindings/js/JSDOMPluginCustom.cpp \
+            bindings/js/JSDOMStringMapCustom.cpp \
+            bindings/js/JSDOMTokenListCustom.cpp \
+            bindings/js/JSDOMWindowBase.cpp \
+            bindings/js/JSDOMWindowCustom.cpp \
+            bindings/js/JSDOMWindowShell.cpp \
+            bindings/js/JSDOMWrapper.cpp \
+            bindings/js/JSDataViewCustom.cpp \
+            bindings/js/JSDesktopNotificationsCustom.cpp \
+            bindings/js/JSDeviceOrientationEventCustom.cpp \
+            bindings/js/JSDocumentCustom.cpp \
+            bindings/js/JSElementCustom.cpp \
+            bindings/js/JSErrorHandler.cpp \
+            bindings/js/JSEventCustom.cpp \
+            bindings/js/JSEventListener.cpp \
+            bindings/js/JSEventSourceCustom.cpp \
+            bindings/js/JSEventTarget.cpp \
+            bindings/js/JSExceptionBase.cpp \
+            bindings/js/JSFloat32ArrayCustom.cpp \
+            bindings/js/JSGeolocationCustom.cpp \
+            bindings/js/JSHTMLAllCollectionCustom.cpp \
+            bindings/js/JSHTMLAppletElementCustom.cpp \
+            bindings/js/JSHTMLCanvasElementCustom.cpp \
+            bindings/js/JSHTMLCollectionCustom.cpp \
+            bindings/js/JSHTMLDocumentCustom.cpp \
+            bindings/js/JSHTMLElementCustom.cpp \
+            bindings/js/JSHTMLEmbedElementCustom.cpp \
+            bindings/js/JSHTMLFormElementCustom.cpp \
+            bindings/js/JSHTMLFrameElementCustom.cpp \
+            bindings/js/JSHTMLFrameSetElementCustom.cpp \
+            bindings/js/JSHTMLInputElementCustom.cpp \
+            bindings/js/JSHTMLLinkElementCustom.cpp \
+            bindings/js/JSHTMLObjectElementCustom.cpp \
+            bindings/js/JSHTMLOptionsCollectionCustom.cpp \
+            bindings/js/JSHTMLOutputElementCustom.cpp \
+            bindings/js/JSHTMLSelectElementCustom.cpp \
+            bindings/js/JSHTMLStyleElementCustom.cpp \
+            bindings/js/JSHistoryCustom.cpp \
+            bindings/js/JSImageConstructor.cpp \
+            bindings/js/JSImageDataCustom.cpp \
+            bindings/js/JSInjectedScriptHostCustom.cpp \
+            bindings/js/JSInjectedScriptManager.cpp \
+            bindings/js/JSInspectorFrontendHostCustom.cpp \
+            bindings/js/JSInt16ArrayCustom.cpp \
+            bindings/js/JSInt32ArrayCustom.cpp \
+            bindings/js/JSInt8ArrayCustom.cpp \
+            bindings/js/JSLazyEventListener.cpp \
+            bindings/js/JSLocationCustom.cpp \
+            bindings/js/JSMainThreadExecState.cpp \
+            bindings/js/JSMediaListCustom.cpp \
+            bindings/js/JSMemoryInfoCustom.cpp \
+            bindings/js/JSMessageChannelCustom.cpp \
+            bindings/js/JSMessageEventCustom.cpp \
+            bindings/js/JSMessagePortCustom.cpp \
+            bindings/js/JSNamedNodeMapCustom.cpp \
+            bindings/js/JSNavigatorCustom.cpp  \
+            bindings/js/JSNodeCustom.cpp \
+            bindings/js/JSNodeFilterCondition.cpp \
+            bindings/js/JSNodeFilterCustom.cpp \
+            bindings/js/JSNodeIteratorCustom.cpp \
+            bindings/js/JSNodeListCustom.cpp \
+            bindings/js/JSOptionConstructor.cpp \
+            bindings/js/JSPluginElementFunctions.cpp \
+            bindings/js/JSProcessingInstructionCustom.cpp \
+            bindings/js/JSScriptProfileNodeCustom.cpp \
+            bindings/js/JSStyleSheetCustom.cpp \
+            bindings/js/JSStyleSheetListCustom.cpp \
+            bindings/js/JSTextCustom.cpp \
+            bindings/js/JSTouchCustom.cpp \
+            bindings/js/JSTouchListCustom.cpp \
+            bindings/js/JSTreeWalkerCustom.cpp \
+            bindings/js/JSUint16ArrayCustom.cpp \
+            bindings/js/JSUint32ArrayCustom.cpp \
+            bindings/js/JSUint8ArrayCustom.cpp \
+            bindings/js/JSWebKitAnimationCustom.cpp \
+            bindings/js/JSWebKitAnimationListCustom.cpp \
+            bindings/js/JSWebKitCSSKeyframeRuleCustom.cpp \
+            bindings/js/JSWebKitCSSKeyframesRuleCustom.cpp \
+            bindings/js/JSWebKitCSSMatrixCustom.cpp \
+            bindings/js/JSWebKitPointCustom.cpp \
+            bindings/js/JSXMLHttpRequestCustom.cpp \
+            bindings/js/JSXMLHttpRequestUploadCustom.cpp \
+            bindings/js/ScheduledAction.cpp \
+            bindings/js/ScriptCachedFrameData.cpp \
+            bindings/js/ScriptCallStackFactory.cpp \
+            bindings/js/ScriptDebugServer.cpp \
+            bindings/js/ScriptEventListener.cpp \
+            bindings/js/ScriptFunctionCall.cpp \
+            bindings/js/ScriptGCEvent.cpp \
+            bindings/js/ScriptState.cpp \
+            bindings/js/SerializedScriptValue.cpp
+    }
     SOURCES += \
         bindings/ScriptControllerBase.cpp \
-        bindings/js/CallbackFunction.cpp \
-        bindings/js/DOMObjectHashTableMap.cpp \
-        bindings/js/DOMWrapperWorld.cpp \
-        bindings/js/GCController.cpp \
-        bindings/js/JSArrayBufferCustom.cpp \
-        bindings/js/JSAttrCustom.cpp \
-        bindings/js/JSCDATASectionCustom.cpp \
-        bindings/js/JSCSSFontFaceRuleCustom.cpp \
-        bindings/js/JSCSSImportRuleCustom.cpp \
-        bindings/js/JSCSSMediaRuleCustom.cpp \
-        bindings/js/JSCSSPageRuleCustom.cpp \
-        bindings/js/JSCSSRuleCustom.cpp \
-        bindings/js/JSCSSRuleListCustom.cpp \
-        bindings/js/JSCSSStyleDeclarationCustom.cpp \
-        bindings/js/JSCSSStyleRuleCustom.cpp \
-        bindings/js/JSCSSValueCustom.cpp \
-        bindings/js/JSCallbackData.cpp \
-        bindings/js/JSCanvasRenderingContext2DCustom.cpp \
-        bindings/js/JSCanvasRenderingContextCustom.cpp \
-        bindings/js/JSClipboardCustom.cpp \
-        bindings/js/JSConsoleCustom.cpp \
-        bindings/js/JSCoordinatesCustom.cpp \
-        bindings/js/JSCustomPositionCallback.cpp \
-        bindings/js/JSCustomPositionErrorCallback.cpp \
-        bindings/js/JSCustomVoidCallback.cpp \
-        bindings/js/JSCustomXPathNSResolver.cpp \
-        bindings/js/JSDOMBinding.cpp \
-        bindings/js/JSDOMFormDataCustom.cpp \
-        bindings/js/JSDOMGlobalObject.cpp \
-        bindings/js/JSDOMImplementationCustom.cpp \
-        bindings/js/JSDOMMimeTypeArrayCustom.cpp \
-        bindings/js/JSDOMPluginArrayCustom.cpp \
-        bindings/js/JSDOMPluginCustom.cpp \
-        bindings/js/JSDOMStringMapCustom.cpp \
-        bindings/js/JSDOMTokenListCustom.cpp \
-        bindings/js/JSDOMWindowBase.cpp \
-        bindings/js/JSDOMWindowCustom.cpp \
-        bindings/js/JSDOMWindowShell.cpp \
-        bindings/js/JSDOMWrapper.cpp \
-        bindings/js/JSDataViewCustom.cpp \
-        bindings/js/JSDesktopNotificationsCustom.cpp \
         bindings/js/JSDeviceMotionEventCustom.cpp \
-        bindings/js/JSDeviceOrientationEventCustom.cpp \
-        bindings/js/JSDocumentCustom.cpp \
-        bindings/js/JSElementCustom.cpp \
-        bindings/js/JSErrorHandler.cpp \
-        bindings/js/JSEventCustom.cpp \
-        bindings/js/JSEventListener.cpp \
-        bindings/js/JSEventSourceCustom.cpp \
-        bindings/js/JSEventTarget.cpp \
-        bindings/js/JSExceptionBase.cpp \
         bindings/js/JSFileReaderCustom.cpp \
-        bindings/js/JSFloat32ArrayCustom.cpp \
-        bindings/js/JSGeolocationCustom.cpp \
-        bindings/js/JSHTMLAllCollectionCustom.cpp \
-        bindings/js/JSHTMLAppletElementCustom.cpp \
-        bindings/js/JSHTMLCanvasElementCustom.cpp \
-        bindings/js/JSHTMLCollectionCustom.cpp \
-        bindings/js/JSHTMLDocumentCustom.cpp \
-        bindings/js/JSHTMLElementCustom.cpp \
-        bindings/js/JSHTMLEmbedElementCustom.cpp \
-        bindings/js/JSHTMLFormElementCustom.cpp \
-        bindings/js/JSHTMLFrameElementCustom.cpp \
-        bindings/js/JSHTMLFrameSetElementCustom.cpp \
-        bindings/js/JSHTMLInputElementCustom.cpp \
-        bindings/js/JSHTMLLinkElementCustom.cpp \
-        bindings/js/JSHTMLObjectElementCustom.cpp \
-        bindings/js/JSHTMLOptionsCollectionCustom.cpp \
-        bindings/js/JSHTMLOutputElementCustom.cpp \
-        bindings/js/JSHTMLSelectElementCustom.cpp \
-        bindings/js/JSHTMLStyleElementCustom.cpp \
-        bindings/js/JSHistoryCustom.cpp \
-        bindings/js/JSImageConstructor.cpp \
-        bindings/js/JSImageDataCustom.cpp \
-        bindings/js/JSInjectedScriptHostCustom.cpp \
-        bindings/js/JSInjectedScriptManager.cpp \
-        bindings/js/JSInspectorFrontendHostCustom.cpp \
-        bindings/js/JSInt16ArrayCustom.cpp \
-        bindings/js/JSInt32ArrayCustom.cpp \
-        bindings/js/JSInt8ArrayCustom.cpp \
-        bindings/js/JSLazyEventListener.cpp \
-        bindings/js/JSLocationCustom.cpp \
-        bindings/js/JSMainThreadExecState.cpp \
-        bindings/js/JSMediaListCustom.cpp \
-        bindings/js/JSMemoryInfoCustom.cpp \
-        bindings/js/JSMessageChannelCustom.cpp \
-        bindings/js/JSMessageEventCustom.cpp \
-        bindings/js/JSMessagePortCustom.cpp \
         bindings/js/JSMessagePortCustom.h \
-        bindings/js/JSNamedNodeMapCustom.cpp \
-        bindings/js/JSNavigatorCustom.cpp  \
-        bindings/js/JSNodeCustom.cpp \
-        bindings/js/JSNodeFilterCondition.cpp \
-        bindings/js/JSNodeFilterCustom.cpp \
-        bindings/js/JSNodeIteratorCustom.cpp \
-        bindings/js/JSNodeListCustom.cpp \
-        bindings/js/JSOptionConstructor.cpp \
-        bindings/js/JSPluginElementFunctions.cpp \
-        bindings/js/JSProcessingInstructionCustom.cpp \
-        bindings/js/JSScriptProfileNodeCustom.cpp \
-        bindings/js/JSStyleSheetCustom.cpp \
-        bindings/js/JSStyleSheetListCustom.cpp \
-        bindings/js/JSTextCustom.cpp \
-        bindings/js/JSTouchCustom.cpp \
-        bindings/js/JSTouchListCustom.cpp \
-        bindings/js/JSTreeWalkerCustom.cpp \
-        bindings/js/JSUint16ArrayCustom.cpp \
-        bindings/js/JSUint32ArrayCustom.cpp \
-        bindings/js/JSUint8ArrayCustom.cpp \
-        bindings/js/JSWebKitAnimationCustom.cpp \
-        bindings/js/JSWebKitAnimationListCustom.cpp \
-        bindings/js/JSWebKitCSSKeyframeRuleCustom.cpp \
-        bindings/js/JSWebKitCSSKeyframesRuleCustom.cpp \
-        bindings/js/JSWebKitCSSMatrixCustom.cpp \
-        bindings/js/JSWebKitPointCustom.cpp \
-        bindings/js/JSXMLHttpRequestCustom.cpp \
-        bindings/js/JSXMLHttpRequestUploadCustom.cpp \
         bindings/js/PageScriptDebugServer.cpp \
-        bindings/js/ScheduledAction.cpp \
-        bindings/js/ScriptCachedFrameData.cpp \
-        bindings/js/ScriptCallStackFactory.cpp \
         bindings/js/ScriptController.cpp \
         bindings/js/ScriptControllerQt.cpp \
-        bindings/js/ScriptDebugServer.cpp \
-        bindings/js/ScriptEventListener.cpp \
-        bindings/js/ScriptFunctionCall.cpp \
-        bindings/js/ScriptGCEvent.cpp \
         bindings/js/ScriptObject.cpp \
         bindings/js/ScriptProfile.cpp \
-        bindings/js/ScriptState.cpp \
         bindings/js/ScriptValue.cpp \
         bindings/js/SerializedScriptValue.cpp \
         bridge/IdentifierRep.cpp \
@@ -381,6 +392,347 @@ v8 {
         testing/js/WebCoreTestSupport.cpp
 }
 
+CONFIG(debug, debug|release) {
+    SOURCES += \
+        dom/DOMAllInOne.cpp \
+        editing/EditingAllInOne.cpp \
+        html/HTMLElementsAllInOne.cpp \
+        rendering/RenderingAllInOne.cpp \
+        rendering/style/StyleAllInOne.cpp
+} else {
+    SOURCES += \
+        dom/ActiveDOMObject.cpp \
+        dom/Attr.cpp \
+        dom/Attribute.cpp \
+        dom/BeforeProcessEvent.cpp \
+        dom/BeforeTextInsertedEvent.cpp \
+        dom/BeforeUnloadEvent.cpp \
+        dom/CDATASection.cpp \
+        dom/CharacterData.cpp \
+        dom/CheckedRadioButtons.cpp \
+        dom/ChildNodeList.cpp \
+        dom/ClassNodeList.cpp \
+        dom/ClientRect.cpp \
+        dom/ClientRectList.cpp \
+        dom/Clipboard.cpp \
+        dom/ClipboardEvent.cpp \
+        dom/Comment.cpp \
+        dom/CompositionEvent.cpp \
+        dom/ContainerNode.cpp \
+        dom/CSSMappedAttributeDeclaration.cpp \
+        dom/CustomEvent.cpp \
+        dom/DecodedDataDocumentParser.cpp \
+        dom/DeviceMotionController.cpp \
+        dom/DeviceMotionData.cpp \
+        dom/DeviceMotionEvent.cpp \
+        dom/DeviceOrientation.cpp \
+        dom/DeviceOrientationController.cpp \
+        dom/DeviceOrientationEvent.cpp \
+        dom/Document.cpp \
+        dom/DocumentFragment.cpp \
+        dom/DocumentMarkerController.cpp \
+        dom/DocumentOrderedMap.cpp \
+        dom/DocumentParser.cpp \
+        dom/DocumentType.cpp \
+        dom/DOMImplementation.cpp \
+        dom/DOMStringList.cpp \
+        dom/DOMStringMap.cpp \
+        dom/DatasetDOMStringMap.cpp \
+        dom/DynamicNodeList.cpp \
+        dom/EditingText.cpp \
+        dom/Element.cpp \
+        dom/EntityReference.cpp \
+        dom/ErrorEvent.cpp \
+        dom/Event.cpp \
+        dom/EventContext.cpp \
+        dom/EventDispatcher.cpp \
+        dom/EventNames.cpp \
+        dom/EventTarget.cpp \
+        dom/EventQueue.cpp \
+        dom/ExceptionBase.cpp \
+        dom/ExceptionCode.cpp \
+        dom/IconURL.cpp \
+        dom/InputElement.cpp \
+        dom/KeyboardEvent.cpp \
+        dom/MessageChannel.cpp \
+        dom/MessageEvent.cpp \
+        dom/MessagePort.cpp \
+        dom/MessagePortChannel.cpp \
+        dom/MouseEvent.cpp \
+        dom/MouseRelatedEvent.cpp \
+        dom/MutationEvent.cpp \
+        dom/NameNodeList.cpp \
+        dom/Node.cpp \
+        dom/NodeFilterCondition.cpp \
+        dom/NodeFilter.cpp \
+        dom/NodeIterator.cpp \
+        dom/Notation.cpp \
+        dom/OptionGroupElement.cpp \
+        dom/OptionElement.cpp \
+        dom/StaticHashSetNodeList.cpp \
+        dom/OverflowEvent.cpp \
+        dom/PageTransitionEvent.cpp \
+        dom/PendingScript.cpp \
+        dom/PopStateEvent.cpp \
+        dom/Position.cpp \
+        dom/PositionIterator.cpp \
+        dom/ProcessingInstruction.cpp \
+        dom/ProgressEvent.cpp \
+        dom/RegisteredEventListener.cpp \
+        dom/ScopedEventQueue.cpp \
+        dom/ScriptableDocumentParser.cpp \
+        dom/ScriptElement.cpp \
+        dom/ScriptExecutionContext.cpp \
+        dom/ScriptRunner.cpp \
+        dom/SelectElement.cpp \
+        dom/SelectorNodeList.cpp \
+        dom/ShadowRoot.cpp \
+        dom/SpaceSplitString.cpp \
+        dom/StaticNodeList.cpp \
+        dom/StyledElement.cpp \
+        dom/StyleElement.cpp \
+        dom/TagNodeList.cpp \
+        dom/Text.cpp \
+        dom/TextEvent.cpp \
+        dom/Touch.cpp \
+        dom/TouchEvent.cpp \
+        dom/TouchList.cpp \
+        dom/Traversal.cpp \
+        dom/TreeScope.cpp \
+        dom/TreeWalker.cpp \
+        dom/UIEvent.cpp \
+        dom/UIEventWithKeyState.cpp \
+        dom/UserGestureIndicator.cpp \
+        dom/UserTypingGestureIndicator.cpp \
+        dom/ViewportArguments.cpp \
+        dom/WebKitAnimationEvent.cpp \
+        dom/WebKitTransitionEvent.cpp \
+        dom/WheelEvent.cpp \
+        dom/WindowEventContext.cpp \
+        dom/XMLDocumentParser.cpp \
+        editing/AppendNodeCommand.cpp \
+        editing/ApplyBlockElementCommand.cpp \
+        editing/ApplyStyleCommand.cpp \
+        editing/BreakBlockquoteCommand.cpp \
+        editing/CompositeEditCommand.cpp \
+        editing/CreateLinkCommand.cpp \
+        editing/DeleteButtonController.cpp \
+        editing/DeleteButton.cpp \
+        editing/DeleteFromTextNodeCommand.cpp \
+        editing/DeleteSelectionCommand.cpp \
+        editing/EditCommand.cpp \
+        editing/EditingStyle.cpp \
+        editing/Editor.cpp \
+        editing/EditorCommand.cpp \
+        editing/FormatBlockCommand.cpp \
+        editing/htmlediting.cpp \
+        editing/HTMLInterchange.cpp \
+        editing/IndentOutdentCommand.cpp \
+        editing/InsertIntoTextNodeCommand.cpp \
+        editing/InsertLineBreakCommand.cpp \
+        editing/InsertListCommand.cpp \
+        editing/InsertNodeBeforeCommand.cpp \
+        editing/InsertParagraphSeparatorCommand.cpp \
+        editing/InsertTextCommand.cpp \
+        editing/JoinTextNodesCommand.cpp \
+        editing/markup.cpp \
+        editing/MarkupAccumulator.cpp \
+        editing/MergeIdenticalElementsCommand.cpp \
+        editing/ModifySelectionListLevel.cpp \
+        editing/MoveSelectionCommand.cpp \
+        editing/RemoveCSSPropertyCommand.cpp \
+        editing/RemoveFormatCommand.cpp \
+        editing/RemoveNodeCommand.cpp \
+        editing/RemoveNodePreservingChildrenCommand.cpp \
+        editing/ReplaceNodeWithSpanCommand.cpp \
+        editing/ReplaceSelectionCommand.cpp \
+        editing/SelectionController.cpp \
+        editing/SetNodeAttributeCommand.cpp \
+        editing/SmartReplaceICU.cpp \
+        editing/SpellChecker.cpp \
+        editing/SpellingCorrectionController.cpp \
+        editing/SplitElementCommand.cpp \
+        editing/SplitTextNodeCommand.cpp \
+        editing/SplitTextNodeContainingElementCommand.cpp \
+        editing/TextCheckingHelper.cpp \
+        editing/TextIterator.cpp \
+        editing/TypingCommand.cpp \
+        editing/UnlinkCommand.cpp \
+        editing/VisiblePosition.cpp \
+        editing/VisibleSelection.cpp \
+        editing/visible_units.cpp \
+        editing/WrapContentsInDummySpanCommand.cpp \
+        html/HTMLAppletElement.cpp \
+        html/HTMLAreaElement.cpp \
+        html/HTMLBRElement.cpp \
+        html/HTMLBaseElement.cpp \
+        html/HTMLBaseFontElement.cpp \
+        html/HTMLBlockquoteElement.cpp \
+        html/HTMLBodyElement.cpp \
+        html/HTMLButtonElement.cpp \
+        html/HTMLDataListElement.cpp \
+        html/HTMLDetailsElement.cpp \
+        html/HTMLDListElement.cpp \
+        html/HTMLDirectoryElement.cpp \
+        html/HTMLDivElement.cpp \
+        html/HTMLElement.cpp \
+        html/HTMLEmbedElement.cpp \
+        html/HTMLFieldSetElement.cpp \
+        html/HTMLFontElement.cpp \
+        html/HTMLFormControlElement.cpp \
+        html/HTMLFormElement.cpp \
+        html/HTMLFrameElement.cpp \
+        html/HTMLFrameElementBase.cpp \
+        html/HTMLFrameOwnerElement.cpp \
+        html/HTMLFrameSetElement.cpp \
+        html/HTMLHRElement.cpp \
+        html/HTMLHeadElement.cpp \
+        html/HTMLHeadingElement.cpp \
+        html/HTMLHtmlElement.cpp \
+        html/HTMLIFrameElement.cpp \
+        html/HTMLImageElement.cpp \
+        html/HTMLInputElement.cpp \
+        html/HTMLIsIndexElement.cpp \
+        html/HTMLKeygenElement.cpp \
+        html/HTMLLIElement.cpp \
+        html/HTMLLabelElement.cpp \
+        html/HTMLLegendElement.cpp \
+        html/HTMLLinkElement.cpp \
+        html/HTMLMapElement.cpp \
+        html/HTMLMarqueeElement.cpp \
+        html/HTMLMenuElement.cpp \
+        html/HTMLMetaElement.cpp \
+        html/HTMLMeterElement.cpp \
+        html/HTMLModElement.cpp \
+        html/HTMLOListElement.cpp \
+        html/HTMLObjectElement.cpp \
+        html/HTMLOptGroupElement.cpp \
+        html/HTMLOptionElement.cpp \
+        html/HTMLOutputElement.cpp \
+        html/HTMLParagraphElement.cpp \
+        html/HTMLParamElement.cpp \
+        html/HTMLParserErrorCodes.cpp \
+        html/HTMLPlugInImageElement.cpp \
+        html/HTMLPreElement.cpp \
+        html/HTMLProgressElement.cpp \
+        html/HTMLQuoteElement.cpp \
+        html/HTMLScriptElement.cpp \
+        html/HTMLSelectElement.cpp \
+        html/HTMLStyleElement.cpp \
+        html/HTMLSummaryElement.cpp \
+        html/HTMLTableCaptionElement.cpp \
+        html/HTMLTableCellElement.cpp \
+        html/HTMLTableColElement.cpp \
+        html/HTMLTableElement.cpp \
+        html/HTMLTablePartElement.cpp \
+        html/HTMLTableRowElement.cpp \
+        html/HTMLTableSectionElement.cpp \
+        html/HTMLTextAreaElement.cpp \
+        html/HTMLTitleElement.cpp \
+        html/HTMLUListElement.cpp \
+        rendering/AutoTableLayout.cpp \
+        rendering/break_lines.cpp \
+        rendering/BidiRun.cpp \
+        rendering/CounterNode.cpp \
+        rendering/EllipsisBox.cpp \
+        rendering/FixedTableLayout.cpp \
+        rendering/HitTestResult.cpp \
+        rendering/InlineBox.cpp \
+        rendering/InlineFlowBox.cpp \
+        rendering/InlineTextBox.cpp \
+        rendering/LayoutState.cpp \
+        rendering/RenderApplet.cpp \
+        rendering/RenderArena.cpp \
+        rendering/RenderBlock.cpp \
+        rendering/RenderBlockLineLayout.cpp \
+        rendering/RenderBox.cpp \
+        rendering/RenderBoxModelObject.cpp \
+        rendering/RenderBR.cpp \
+        rendering/RenderButton.cpp \
+        rendering/RenderCombineText.cpp \
+        rendering/RenderCounter.cpp \
+        rendering/RenderDetails.cpp \
+        rendering/RenderDetailsMarker.cpp \
+        rendering/RenderEmbeddedObject.cpp \
+        rendering/RenderFieldset.cpp \
+        rendering/RenderFileUploadControl.cpp \
+        rendering/RenderFlexibleBox.cpp \
+        rendering/RenderFrame.cpp \
+        rendering/RenderFrameBase.cpp \
+        rendering/RenderFrameSet.cpp \
+        rendering/RenderHTMLCanvas.cpp \
+        rendering/RenderIFrame.cpp \
+        rendering/RenderImage.cpp \
+        rendering/RenderImageResource.cpp \
+        rendering/RenderImageResourceStyleImage.cpp \
+        rendering/RenderInline.cpp \
+        rendering/RenderLayer.cpp \
+        rendering/RenderLayerCompositor.cpp \
+        rendering/RenderLineBoxList.cpp \
+        rendering/RenderListBox.cpp \
+        rendering/RenderListItem.cpp \
+        rendering/RenderListMarker.cpp \
+        rendering/RenderMarquee.cpp \
+        rendering/RenderMenuList.cpp \
+        rendering/RenderMeter.cpp \
+        rendering/RenderObject.cpp \
+        rendering/RenderObjectChildList.cpp \
+        rendering/RenderPart.cpp \
+        rendering/RenderProgress.cpp \
+        rendering/RenderQuote.cpp \
+        rendering/RenderReplaced.cpp \
+        rendering/RenderReplica.cpp \
+        rendering/RenderRuby.cpp \
+        rendering/RenderRubyBase.cpp \
+        rendering/RenderRubyRun.cpp \
+        rendering/RenderRubyText.cpp \
+        rendering/RenderScrollbar.cpp \
+        rendering/RenderScrollbarPart.cpp \
+        rendering/RenderScrollbarTheme.cpp \
+        rendering/RenderSlider.cpp \
+        rendering/RenderSummary.cpp \
+        rendering/RenderTable.cpp \
+        rendering/RenderTableCell.cpp \
+        rendering/RenderTableCol.cpp \
+        rendering/RenderTableRow.cpp \
+        rendering/RenderTableSection.cpp \
+        rendering/RenderText.cpp \
+        rendering/RenderTextControl.cpp \
+        rendering/RenderTextControlMultiLine.cpp \
+        rendering/RenderTextControlSingleLine.cpp \
+        rendering/RenderTextFragment.cpp \
+        rendering/RenderTheme.cpp \
+        rendering/RenderTreeAsText.cpp \
+        rendering/RenderView.cpp \
+        rendering/RenderWidget.cpp \
+        rendering/RenderWordBreak.cpp \
+        rendering/RootInlineBox.cpp \
+        rendering/ScrollBehavior.cpp \
+        rendering/ShadowElement.cpp \
+        rendering/TransformState.cpp \
+        rendering/style/ContentData.cpp \
+        rendering/style/CounterDirectives.cpp \
+        rendering/style/FillLayer.cpp \
+        rendering/style/KeyframeList.cpp \
+        rendering/style/NinePieceImage.cpp \
+        rendering/style/QuotesData.cpp \
+        rendering/style/RenderStyle.cpp \
+        rendering/style/ShadowData.cpp \
+        rendering/style/StyleBackgroundData.cpp \
+        rendering/style/StyleBoxData.cpp \
+        rendering/style/StyleCachedImage.cpp \
+        rendering/style/StyleFlexibleBoxData.cpp \
+        rendering/style/StyleGeneratedImage.cpp \
+        rendering/style/StyleInheritedData.cpp \
+        rendering/style/StyleMarqueeData.cpp \
+        rendering/style/StyleMultiColData.cpp \
+        rendering/style/StyleRareInheritedData.cpp \
+        rendering/style/StyleRareNonInheritedData.cpp \
+        rendering/style/StyleSurroundData.cpp \
+        rendering/style/StyleTransformData.cpp \
+        rendering/style/StyleVisualData.cpp
+}
+
 SOURCES += \
     css/CSSBorderImageValue.cpp \
     css/CSSCanvasValue.cpp \
@@ -446,173 +798,12 @@ SOURCES += \
     css/WebKitCSSKeyframesRule.cpp \
     css/WebKitCSSMatrix.cpp \
     css/WebKitCSSTransformValue.cpp \
-    dom/ActiveDOMObject.cpp \
-    dom/Attr.cpp \
-    dom/Attribute.cpp \
-    dom/BeforeProcessEvent.cpp \
-    dom/BeforeTextInsertedEvent.cpp \
-    dom/BeforeUnloadEvent.cpp \
-    dom/CDATASection.cpp \
-    dom/CharacterData.cpp \
-    dom/CheckedRadioButtons.cpp \
-    dom/ChildNodeList.cpp \
-    dom/ClassNodeList.cpp \
-    dom/ClientRect.cpp \
-    dom/ClientRectList.cpp \
-    dom/Clipboard.cpp \
-    dom/ClipboardEvent.cpp \
-    dom/Comment.cpp \
-    dom/CompositionEvent.cpp \
-    dom/ContainerNode.cpp \
-    dom/CSSMappedAttributeDeclaration.cpp \
-    dom/CustomEvent.cpp \
-    dom/DecodedDataDocumentParser.cpp \
-    dom/DeviceMotionController.cpp \
-    dom/DeviceMotionData.cpp \
-    dom/DeviceMotionEvent.cpp \
-    dom/DeviceOrientation.cpp \
-    dom/DeviceOrientationController.cpp \
-    dom/DeviceOrientationEvent.cpp \
-    dom/Document.cpp \
-    dom/DocumentFragment.cpp \
-    dom/DocumentMarkerController.cpp \
-    dom/DocumentOrderedMap.cpp \
-    dom/DocumentParser.cpp \
-    dom/DocumentType.cpp \
-    dom/DOMImplementation.cpp \
-    dom/DOMStringList.cpp \
-    dom/DOMStringMap.cpp \
-    dom/DatasetDOMStringMap.cpp \
-    dom/DynamicNodeList.cpp \
-    dom/EditingText.cpp \
-    dom/Element.cpp \
-    dom/EntityReference.cpp \
-    dom/ErrorEvent.cpp \
-    dom/Event.cpp \
-    dom/EventContext.cpp \
-    dom/EventDispatcher.cpp \
-    dom/EventNames.cpp \
-    dom/EventTarget.cpp \
-    dom/EventQueue.cpp \
-    dom/ExceptionBase.cpp \
-    dom/ExceptionCode.cpp \
-    dom/IconURL.cpp \
-    dom/InputElement.cpp \
-    dom/KeyboardEvent.cpp \
-    dom/MessageChannel.cpp \
-    dom/MessageEvent.cpp \
-    dom/MessagePort.cpp \
-    dom/MessagePortChannel.cpp \
-    dom/MouseEvent.cpp \
-    dom/MouseRelatedEvent.cpp \
-    dom/MutationEvent.cpp \
     dom/NamedNodeMap.cpp \
-    dom/NameNodeList.cpp \
-    dom/Node.cpp \
-    dom/NodeFilterCondition.cpp \
-    dom/NodeFilter.cpp \
-    dom/NodeIterator.cpp \
-    dom/Notation.cpp \
-    dom/OptionGroupElement.cpp \
-    dom/OptionElement.cpp \
-    dom/StaticHashSetNodeList.cpp \
-    dom/OverflowEvent.cpp \
-    dom/PageTransitionEvent.cpp \
-    dom/PendingScript.cpp \
-    dom/PopStateEvent.cpp \
-    dom/Position.cpp \
-    dom/PositionIterator.cpp \
-    dom/ProcessingInstruction.cpp \
-    dom/ProgressEvent.cpp \
     dom/QualifiedName.cpp \
     dom/Range.cpp \
     dom/RawDataDocumentParser.h \
-    dom/RegisteredEventListener.cpp \
-    dom/ScopedEventQueue.cpp \
-    dom/ScriptableDocumentParser.cpp \
-    dom/ScriptElement.cpp \
-    dom/ScriptExecutionContext.cpp \
-    dom/ScriptRunner.cpp \
-    dom/SelectElement.cpp \
-    dom/SelectorNodeList.cpp \
-    dom/ShadowRoot.cpp \
-    dom/SpaceSplitString.cpp \
-    dom/StaticNodeList.cpp \
-    dom/StyledElement.cpp \
-    dom/StyleElement.cpp \
-    dom/TagNodeList.cpp \
-    dom/Text.cpp \
-    dom/TextEvent.cpp \
-    dom/Touch.cpp \
-    dom/TouchEvent.cpp \
-    dom/TouchList.cpp \
-    dom/Traversal.cpp \
-    dom/TreeScope.cpp \
-    dom/TreeWalker.cpp \
-    dom/UIEvent.cpp \
-    dom/UIEventWithKeyState.cpp \
-    dom/UserGestureIndicator.cpp \
-    dom/UserTypingGestureIndicator.cpp \
-    dom/ViewportArguments.cpp \
-    dom/WebKitAnimationEvent.cpp \
-    dom/WebKitTransitionEvent.cpp \
-    dom/WheelEvent.cpp \
-    dom/WindowEventContext.cpp \
-    dom/XMLDocumentParser.cpp \
     dom/XMLDocumentParserQt.cpp \
     dom/default/PlatformMessagePortChannel.cpp \
-    editing/AppendNodeCommand.cpp \
-    editing/ApplyBlockElementCommand.cpp \
-    editing/ApplyStyleCommand.cpp \
-    editing/BreakBlockquoteCommand.cpp \
-    editing/CompositeEditCommand.cpp \
-    editing/CreateLinkCommand.cpp \
-    editing/DeleteButtonController.cpp \
-    editing/DeleteButton.cpp \
-    editing/DeleteFromTextNodeCommand.cpp \
-    editing/DeleteSelectionCommand.cpp \
-    editing/EditCommand.cpp \
-    editing/EditingStyle.cpp \
-    editing/Editor.cpp \
-    editing/EditorCommand.cpp \
-    editing/FormatBlockCommand.cpp \
-    editing/htmlediting.cpp \
-    editing/HTMLInterchange.cpp \
-    editing/IndentOutdentCommand.cpp \
-    editing/InsertIntoTextNodeCommand.cpp \
-    editing/InsertLineBreakCommand.cpp \
-    editing/InsertListCommand.cpp \
-    editing/InsertNodeBeforeCommand.cpp \
-    editing/InsertParagraphSeparatorCommand.cpp \
-    editing/InsertTextCommand.cpp \
-    editing/JoinTextNodesCommand.cpp \
-    editing/markup.cpp \
-    editing/MarkupAccumulator.cpp \
-    editing/MergeIdenticalElementsCommand.cpp \
-    editing/ModifySelectionListLevel.cpp \
-    editing/MoveSelectionCommand.cpp \
-    editing/RemoveCSSPropertyCommand.cpp \
-    editing/RemoveFormatCommand.cpp \
-    editing/RemoveNodeCommand.cpp \
-    editing/RemoveNodePreservingChildrenCommand.cpp \
-    editing/ReplaceNodeWithSpanCommand.cpp \
-    editing/ReplaceSelectionCommand.cpp \
-    editing/SelectionController.cpp \
-    editing/SetNodeAttributeCommand.cpp \
-    editing/SmartReplaceICU.cpp \
-    editing/SpellChecker.cpp \
-    editing/SpellingCorrectionController.cpp \
-    editing/SplitElementCommand.cpp \
-    editing/SplitTextNodeCommand.cpp \
-    editing/SplitTextNodeContainingElementCommand.cpp \
-    editing/TextCheckingHelper.cpp \
-    editing/TextIterator.cpp \
-    editing/TypingCommand.cpp \
-    editing/UnlinkCommand.cpp \
-    editing/VisiblePosition.cpp \
-    editing/VisibleSelection.cpp \
-    editing/visible_units.cpp \
-    editing/WrapContentsInDummySpanCommand.cpp \
     fileapi/Blob.cpp \
     fileapi/BlobURL.cpp \
     fileapi/File.cpp \
@@ -652,85 +843,17 @@ SOURCES += \
     html/FileInputType.cpp \
     html/FormAssociatedElement.cpp \
     html/FormDataList.cpp \
-    html/HTMLAllCollection.cpp \
     html/HTMLAnchorElement.cpp \
-    html/HTMLAppletElement.cpp \
-    html/HTMLAreaElement.cpp \
-    html/HTMLBRElement.cpp \
-    html/HTMLBaseElement.cpp \
-    html/HTMLBaseFontElement.cpp \
-    html/HTMLBlockquoteElement.cpp \
-    html/HTMLBodyElement.cpp \
-    html/HTMLButtonElement.cpp \
+    html/HTMLAllCollection.cpp \
     html/HTMLCanvasElement.cpp \
     html/HTMLCollection.cpp \
-    html/HTMLDListElement.cpp \
-    html/HTMLDataListElement.cpp \
-    html/HTMLDirectoryElement.cpp \
-    html/HTMLDetailsElement.cpp \
-    html/HTMLDivElement.cpp \
     html/HTMLDocument.cpp \
-    html/HTMLElement.cpp \
-    html/HTMLEmbedElement.cpp \
-    html/HTMLFieldSetElement.cpp \
-    html/HTMLFontElement.cpp \
     html/HTMLFormCollection.cpp \
-    html/HTMLFormControlElement.cpp \
-    html/HTMLFormElement.cpp \
-    html/HTMLFrameElement.cpp \
-    html/HTMLFrameElementBase.cpp \
-    html/HTMLFrameOwnerElement.cpp \
-    html/HTMLFrameSetElement.cpp \
-    html/HTMLHRElement.cpp \
-    html/HTMLHeadElement.cpp \
-    html/HTMLHeadingElement.cpp \
-    html/HTMLHtmlElement.cpp \
-    html/HTMLIFrameElement.cpp \
-    html/HTMLImageElement.cpp \
     html/HTMLImageLoader.cpp \
-    html/HTMLInputElement.cpp \
-    html/HTMLIsIndexElement.cpp \
-    html/HTMLKeygenElement.cpp \
-    html/HTMLLIElement.cpp \
-    html/HTMLLabelElement.cpp \
-    html/HTMLLegendElement.cpp \
-    html/HTMLLinkElement.cpp \
-    html/HTMLMapElement.cpp \
-    html/HTMLMarqueeElement.cpp \
-    html/HTMLMenuElement.cpp \
-    html/HTMLMetaElement.cpp \
-    html/HTMLMeterElement.cpp \
-    html/HTMLModElement.cpp \
     html/HTMLNameCollection.cpp \
-    html/HTMLOListElement.cpp \
-    html/HTMLObjectElement.cpp \
-    html/HTMLOptGroupElement.cpp \
-    html/HTMLOptionElement.cpp \
     html/HTMLOptionsCollection.cpp \
-    html/HTMLOutputElement.cpp \
-    html/HTMLParagraphElement.cpp \
-    html/HTMLParamElement.cpp \
-    html/HTMLParserErrorCodes.cpp \
     html/HTMLPlugInElement.cpp \
-    html/HTMLPlugInImageElement.cpp \
-    html/HTMLPreElement.cpp \
-    html/HTMLProgressElement.cpp \
-    html/HTMLQuoteElement.cpp \
-    html/HTMLScriptElement.cpp \
-    html/HTMLSelectElement.cpp \
-    html/HTMLStyleElement.cpp \
-    html/HTMLSummaryElement.cpp \
-    html/HTMLTableCaptionElement.cpp \
-    html/HTMLTableCellElement.cpp \
-    html/HTMLTableColElement.cpp \
-    html/HTMLTableElement.cpp \
-    html/HTMLTablePartElement.cpp \
-    html/HTMLTableRowElement.cpp \
     html/HTMLTableRowsCollection.cpp \
-    html/HTMLTableSectionElement.cpp \
-    html/HTMLTextAreaElement.cpp \
-    html/HTMLTitleElement.cpp \
-    html/HTMLUListElement.cpp \
     html/HTMLViewSourceDocument.cpp \
     html/HiddenInputType.cpp \
     html/ImageData.cpp \
@@ -989,6 +1112,7 @@ SOURCES += \
     platform/graphics/PathTraversalState.cpp \
     platform/graphics/Pattern.cpp \
     platform/graphics/RoundedIntRect.cpp \
+    platform/graphics/WOFFFileFormat.cpp \
     platform/graphics/SegmentedFontData.cpp \
     platform/graphics/ShadowBlur.cpp \
     platform/graphics/SVGGlyph.cpp \
@@ -1075,108 +1199,7 @@ SOURCES += \
     plugins/PluginPackage.cpp \
     plugins/PluginStream.cpp \
     plugins/PluginView.cpp \
-    rendering/AutoTableLayout.cpp \
-    rendering/break_lines.cpp \
-    rendering/BidiRun.cpp \
-    rendering/CounterNode.cpp \
-    rendering/EllipsisBox.cpp \
-    rendering/FixedTableLayout.cpp \
-    rendering/HitTestResult.cpp \
-    rendering/InlineBox.cpp \
-    rendering/InlineFlowBox.cpp \
-    rendering/InlineTextBox.cpp \
-    rendering/LayoutState.cpp \
-    rendering/RenderApplet.cpp \
-    rendering/RenderArena.cpp \
-    rendering/RenderBlock.cpp \
-    rendering/RenderBlockLineLayout.cpp \
-    rendering/RenderBox.cpp \
-    rendering/RenderBoxModelObject.cpp \
-    rendering/RenderBR.cpp \
-    rendering/RenderButton.cpp \
-    rendering/RenderCombineText.cpp \
-    rendering/RenderCounter.cpp \
-    rendering/RenderDetails.cpp \
-    rendering/RenderDetailsMarker.cpp \
-    rendering/RenderEmbeddedObject.cpp \
-    rendering/RenderFieldset.cpp \
-    rendering/RenderFileUploadControl.cpp \
-    rendering/RenderFlexibleBox.cpp \
-    rendering/RenderFrame.cpp \
-    rendering/RenderFrameBase.cpp \
-    rendering/RenderFrameSet.cpp \
-    rendering/RenderHTMLCanvas.cpp \
-    rendering/RenderIFrame.cpp \
-    rendering/RenderImage.cpp \
-    rendering/RenderImageResource.cpp \
-    rendering/RenderImageResourceStyleImage.cpp \
-    rendering/RenderInline.cpp \
-    rendering/RenderLayer.cpp \
     rendering/RenderLayerBacking.cpp \
-    rendering/RenderLayerCompositor.cpp \
-    rendering/RenderLineBoxList.cpp \
-    rendering/RenderListBox.cpp \
-    rendering/RenderListItem.cpp \
-    rendering/RenderListMarker.cpp \
-    rendering/RenderMarquee.cpp \
-    rendering/RenderMenuList.cpp \
-    rendering/RenderMeter.cpp \
-    rendering/RenderObject.cpp \
-    rendering/RenderObjectChildList.cpp \
-    rendering/RenderPart.cpp \
-    rendering/RenderProgress.cpp \
-    rendering/RenderQuote.cpp \
-    rendering/RenderReplaced.cpp \
-    rendering/RenderReplica.cpp \
-    rendering/RenderRuby.cpp \
-    rendering/RenderRubyBase.cpp \
-    rendering/RenderRubyRun.cpp \
-    rendering/RenderRubyText.cpp \
-    rendering/RenderScrollbar.cpp \
-    rendering/RenderScrollbarPart.cpp \
-    rendering/RenderScrollbarTheme.cpp \
-    rendering/RenderSlider.cpp \
-    rendering/RenderSummary.cpp \
-    rendering/RenderTable.cpp \
-    rendering/RenderTableCell.cpp \
-    rendering/RenderTableCol.cpp \
-    rendering/RenderTableRow.cpp \
-    rendering/RenderTableSection.cpp \
-    rendering/RenderText.cpp \
-    rendering/RenderTextControl.cpp \
-    rendering/RenderTextControlMultiLine.cpp \
-    rendering/RenderTextControlSingleLine.cpp \
-    rendering/RenderTextFragment.cpp \
-    rendering/RenderTheme.cpp \
-    rendering/RenderTreeAsText.cpp \
-    rendering/RenderView.cpp \
-    rendering/RenderWidget.cpp \
-    rendering/RenderWordBreak.cpp \
-    rendering/RootInlineBox.cpp \
-    rendering/ScrollBehavior.cpp \
-    rendering/ShadowElement.cpp \
-    rendering/TransformState.cpp \
-    rendering/style/ContentData.cpp \
-    rendering/style/CounterDirectives.cpp \
-    rendering/style/FillLayer.cpp \
-    rendering/style/KeyframeList.cpp \
-    rendering/style/NinePieceImage.cpp \
-    rendering/style/QuotesData.cpp \
-    rendering/style/RenderStyle.cpp \
-    rendering/style/ShadowData.cpp \
-    rendering/style/StyleBackgroundData.cpp \
-    rendering/style/StyleBoxData.cpp \
-    rendering/style/StyleCachedImage.cpp \
-    rendering/style/StyleFlexibleBoxData.cpp \
-    rendering/style/StyleGeneratedImage.cpp \
-    rendering/style/StyleInheritedData.cpp \
-    rendering/style/StyleMarqueeData.cpp \
-    rendering/style/StyleMultiColData.cpp \
-    rendering/style/StyleRareInheritedData.cpp \
-    rendering/style/StyleRareNonInheritedData.cpp \
-    rendering/style/StyleSurroundData.cpp \
-    rendering/style/StyleTransformData.cpp \
-    rendering/style/StyleVisualData.cpp \
     testing/Internals.cpp \
     xml/DOMParser.cpp \
     xml/XMLHttpRequest.cpp \
@@ -1959,6 +1982,7 @@ HEADERS += \
     platform/graphics/PathTraversalState.h \
     platform/graphics/Pattern.h \
     platform/graphics/RoundedIntRect.h \
+    platform/graphics/WOFFFileFormat.h \
     platform/graphics/qt/FontCustomPlatformData.h \
     platform/graphics/qt/ImageDecoderQt.h \
     platform/graphics/qt/StillImageQt.h \
@@ -3129,7 +3153,6 @@ contains(DEFINES, ENABLE_SVG=1) {
         rendering/style/SVGRenderStyle.cpp \
         rendering/style/SVGRenderStyleDefs.cpp \
         rendering/PointerEventsHitRules.cpp \
-        rendering/svg/RenderSVGPath.cpp \
         svg/animation/SMILTime.cpp \
         svg/animation/SMILTimeContainer.cpp \
         svg/animation/SVGSMILElement.cpp \
@@ -3139,9 +3162,7 @@ contains(DEFINES, ENABLE_SVG=1) {
         svg/graphics/SVGImage.cpp \
         svg/properties/SVGPathSegListPropertyTearOff.cpp
 
-    linux-g++*:CONFIG(debug, debug|release):isEqual(QT_ARCH,i386) {
-         # Using all in one files to avoid memory exhaustion
-         # during the linking phase.
+    CONFIG(debug, debug|release) {
          SOURCES += \
               rendering/svg/RenderSVGAllInOne.cpp \
               svg/SVGAllInOne.cpp
@@ -3156,6 +3177,7 @@ contains(DEFINES, ENABLE_SVG=1) {
               rendering/svg/RenderSVGInline.cpp \
               rendering/svg/RenderSVGInlineText.cpp \
               rendering/svg/RenderSVGModelObject.cpp \
+              rendering/svg/RenderSVGPath.cpp \
               rendering/svg/RenderSVGResource.cpp \
               rendering/svg/RenderSVGResourceClipper.cpp \
               rendering/svg/RenderSVGResourceContainer.cpp \
@@ -3464,7 +3486,7 @@ contains(DEFINES, ENABLE_WEBGL=1) {
         INCLUDEPATH += $$PWD/platform/graphics/gpu
 }
 
-win32:!win32-g++*:contains(QMAKE_HOST.arch, x86_64):{
+win32:!win32-g++*:contains(QMAKE_TARGET.arch, x86_64):{
     asm_compiler.commands = ml64 /c
     asm_compiler.commands +=  /Fo ${QMAKE_FILE_OUT} ${QMAKE_FILE_IN}
     asm_compiler.output = ${QMAKE_VAR_OBJECTS_DIR}${QMAKE_FILE_BASE}$${first(QMAKE_EXT_OBJ)}
@@ -3476,7 +3498,7 @@ win32:!win32-g++*:contains(QMAKE_HOST.arch, x86_64):{
 
     ASM_SOURCES += \
         plugins/win/PaintHooks.asm
-   if(win32-msvc2005|win32-msvc2008):equals(TEMPLATE_PREFIX, "vc") {
+   if(win32-msvc*):equals(TEMPLATE_PREFIX, "vc") {
         SOURCES += \
             plugins/win/PaintHooks.asm
    }
diff --git a/src/3rdparty/webkit/Source/WebCore/accessibility/AccessibilityAllInOne.cpp b/src/3rdparty/webkit/Source/WebCore/accessibility/AccessibilityAllInOne.cpp
index dd7f7776df..f9765ca123 100644
--- a/src/3rdparty/webkit/Source/WebCore/accessibility/AccessibilityAllInOne.cpp
+++ b/src/3rdparty/webkit/Source/WebCore/accessibility/AccessibilityAllInOne.cpp
@@ -34,7 +34,11 @@
 #include "AccessibilityListBox.cpp"
 #include "AccessibilityListBoxOption.cpp"
 #include "AccessibilityMediaControls.cpp"
+#include "AccessibilityMenuList.cpp"
+#include "AccessibilityMenuListOption.cpp"
+#include "AccessibilityMenuListPopup.cpp"
 #include "AccessibilityObject.cpp"
+#include "AccessibilityProgressIndicator.cpp"
 #include "AccessibilityRenderObject.cpp"
 #include "AccessibilityScrollView.cpp"
 #include "AccessibilityScrollbar.cpp"
diff --git a/src/3rdparty/webkit/Source/WebCore/bindings/js/JSBindingsAllInOne.cpp b/src/3rdparty/webkit/Source/WebCore/bindings/js/JSBindingsAllInOne.cpp
index 0f1de36f01..96d02b87fb 100644
--- a/src/3rdparty/webkit/Source/WebCore/bindings/js/JSBindingsAllInOne.cpp
+++ b/src/3rdparty/webkit/Source/WebCore/bindings/js/JSBindingsAllInOne.cpp
@@ -31,7 +31,6 @@
 #include "GCController.cpp"
 #include "JSArrayBufferCustom.cpp"
 #include "JSAttrCustom.cpp"
-#include "JSAudioConstructor.cpp"
 #include "JSCDATASectionCustom.cpp"
 #include "JSCSSFontFaceRuleCustom.cpp"
 #include "JSCSSImportRuleCustom.cpp"
@@ -50,10 +49,8 @@
 #include "JSCoordinatesCustom.cpp"
 #include "JSCustomPositionCallback.cpp"
 #include "JSCustomPositionErrorCallback.cpp"
-#include "JSCustomSQLStatementErrorCallback.cpp"
 #include "JSCustomVoidCallback.cpp"
 #include "JSCustomXPathNSResolver.cpp"
-#include "JSDOMApplicationCacheCustom.cpp"
 #include "JSDOMBinding.cpp"
 #include "JSDOMFormDataCustom.cpp"
 #include "JSDOMGlobalObject.cpp"
@@ -68,7 +65,6 @@
 #include "JSDOMWindowShell.cpp"
 #include "JSDOMWrapper.cpp"
 #include "JSDataViewCustom.cpp"
-#include "JSDedicatedWorkerContextCustom.cpp"
 #include "JSDesktopNotificationsCustom.cpp"
 #include "JSDeviceOrientationEventCustom.cpp"
 #include "JSDocumentCustom.cpp"
@@ -107,7 +103,6 @@
 #include "JSInt16ArrayCustom.cpp"
 #include "JSInt32ArrayCustom.cpp"
 #include "JSInt8ArrayCustom.cpp"
-#include "JSJavaScriptCallFrameCustom.cpp"
 #include "JSLazyEventListener.cpp"
 #include "JSLocationCustom.cpp"
 #include "JSMainThreadExecState.cpp"
@@ -126,15 +121,7 @@
 #include "JSOptionConstructor.cpp"
 #include "JSPluginElementFunctions.cpp"
 #include "JSProcessingInstructionCustom.cpp"
-#include "JSSQLResultSetRowListCustom.cpp"
-#include "JSSQLTransactionCustom.cpp"
-#include "JSSQLTransactionSyncCustom.cpp"
-#include "JSSVGElementInstanceCustom.cpp"
-#include "JSSVGLengthCustom.cpp"
-#include "JSSVGPathSegCustom.cpp"
 #include "JSScriptProfileNodeCustom.cpp"
-#include "JSSharedWorkerCustom.cpp"
-#include "JSStorageCustom.cpp"
 #include "JSStyleSheetCustom.cpp"
 #include "JSStyleSheetListCustom.cpp"
 #include "JSTextCustom.cpp"
@@ -150,28 +137,14 @@
 #include "JSWebKitCSSKeyframesRuleCustom.cpp"
 #include "JSWebKitCSSMatrixCustom.cpp"
 #include "JSWebKitPointCustom.cpp"
-#include "JSWebSocketCustom.cpp"
-#include "JSWorkerContextBase.cpp"
-#include "JSWorkerContextCustom.cpp"
-#include "JSWorkerCustom.cpp"
 #include "JSXMLHttpRequestCustom.cpp"
 #include "JSXMLHttpRequestUploadCustom.cpp"
-#include "JSXSLTProcessorCustom.cpp"
-#include "JavaScriptCallFrame.cpp"
-#include "MemoryInfo.cpp"
-#include "PageScriptDebugServer.cpp"
 #include "ScheduledAction.cpp"
 #include "ScriptCachedFrameData.cpp"
 #include "ScriptCallStackFactory.cpp"
-#include "ScriptController.cpp"
-#include "ScriptControllerWin.cpp"
 #include "ScriptDebugServer.cpp"
 #include "ScriptEventListener.cpp"
 #include "ScriptFunctionCall.cpp"
 #include "ScriptGCEvent.cpp"
-#include "ScriptProfiler.cpp"
 #include "ScriptState.cpp"
 #include "SerializedScriptValue.cpp"
-#include "WorkerScriptController.cpp"
-#include "WorkerScriptDebugServer.cpp"
-
diff --git a/src/3rdparty/webkit/Source/WebCore/bindings/js/JSCanvasRenderingContext2DCustom.cpp b/src/3rdparty/webkit/Source/WebCore/bindings/js/JSCanvasRenderingContext2DCustom.cpp
index 8434e5052d..9e16ad1eba 100644
--- a/src/3rdparty/webkit/Source/WebCore/bindings/js/JSCanvasRenderingContext2DCustom.cpp
+++ b/src/3rdparty/webkit/Source/WebCore/bindings/js/JSCanvasRenderingContext2DCustom.cpp
@@ -170,6 +170,21 @@ JSValue JSCanvasRenderingContext2D::setStrokeColor(ExecState* exec)
     return jsUndefined();
 }
 
+JSValue JSCanvasRenderingContext2D::setLineDash(ExecState* exec)
+{
+    CanvasRenderingContext2D* context = static_cast<CanvasRenderingContext2D*>(impl());
+    JSValue value = exec->argument(0);
+    JSObject* array = asObject(value);
+    uint32_t length = array->get(exec, JSC::Identifier(exec, "length")).toInt32(exec);
+    DashArray lineDash;
+    for(uint32_t i = 0; i < length; i++) {
+        JSValue v = array->get(exec, i);
+        lineDash.append(v.toNumber(exec));
+    }
+    context->setLineDash(lineDash, lineDash[0]);
+    return jsUndefined();
+}
+
 JSValue JSCanvasRenderingContext2D::strokeRect(ExecState* exec)
 { 
     CanvasRenderingContext2D* context = static_cast<CanvasRenderingContext2D*>(impl());
diff --git a/src/3rdparty/webkit/Source/WebCore/css/CSSComputedStyleDeclaration.cpp b/src/3rdparty/webkit/Source/WebCore/css/CSSComputedStyleDeclaration.cpp
index 08626ddfd8..4fb0feee68 100644
--- a/src/3rdparty/webkit/Source/WebCore/css/CSSComputedStyleDeclaration.cpp
+++ b/src/3rdparty/webkit/Source/WebCore/css/CSSComputedStyleDeclaration.cpp
@@ -1245,6 +1245,8 @@ PassRefPtr<CSSValue> CSSComputedStyleDeclaration::getPropertyCSSValue(int proper
         case CSSPropertyOpacity:
             return primitiveValueCache->createValue(style->opacity(), CSSPrimitiveValue::CSS_NUMBER);
         case CSSPropertyOrphans:
+            if (style->hasAutoOrphans())
+                return primitiveValueCache->createIdentifierValue(CSSValueAuto);
             return primitiveValueCache->createValue(style->orphans(), CSSPrimitiveValue::CSS_NUMBER);
         case CSSPropertyOutlineColor:
             return m_allowVisitedStyle ? primitiveValueCache->createColorValue(style->visitedDependentColor(CSSPropertyOutlineColor).rgb()) : currentColorOrValidColor(style.get(), style->outlineColor());
@@ -1383,6 +1385,8 @@ PassRefPtr<CSSValue> CSSComputedStyleDeclaration::getPropertyCSSValue(int proper
         case CSSPropertyWhiteSpace:
             return primitiveValueCache->createValue(style->whiteSpace());
         case CSSPropertyWidows:
+            if (style->hasAutoWidows())
+                return primitiveValueCache->createIdentifierValue(CSSValueAuto);
             return primitiveValueCache->createValue(style->widows(), CSSPrimitiveValue::CSS_NUMBER);
         case CSSPropertyWidth:
             if (renderer)
diff --git a/src/3rdparty/webkit/Source/WebCore/css/CSSFontFaceSource.cpp b/src/3rdparty/webkit/Source/WebCore/css/CSSFontFaceSource.cpp
index b0f7365d63..f51a25ac38 100644
--- a/src/3rdparty/webkit/Source/WebCore/css/CSSFontFaceSource.cpp
+++ b/src/3rdparty/webkit/Source/WebCore/css/CSSFontFaceSource.cpp
@@ -44,6 +44,10 @@
 #include "SVGURIReference.h"
 #endif
 
+#if PLATFORM(QT)
+#include <QFontInfo>
+#endif
+
 namespace WebCore {
 
 CSSFontFaceSource::CSSFontFaceSource(const String& str, CachedFont* font)
diff --git a/src/3rdparty/webkit/Source/WebCore/css/CSSFontSelector.cpp b/src/3rdparty/webkit/Source/WebCore/css/CSSFontSelector.cpp
index 8024afa4c2..9edf17feea 100644
--- a/src/3rdparty/webkit/Source/WebCore/css/CSSFontSelector.cpp
+++ b/src/3rdparty/webkit/Source/WebCore/css/CSSFontSelector.cpp
@@ -108,94 +108,65 @@ void CSSFontSelector::addFontFaceRule(const CSSFontFaceRule* fontFaceRule)
     unsigned traitsMask = 0;
 
     if (RefPtr<CSSValue> fontStyle = style->getPropertyCSSValue(CSSPropertyFontStyle)) {
-        if (fontStyle->isPrimitiveValue()) {
-            RefPtr<CSSValueList> list = CSSValueList::createCommaSeparated();
-            list->append(fontStyle);
-            fontStyle = list;
-        } else if (!fontStyle->isValueList())
-            return;
-
-        CSSValueList* styleList = static_cast<CSSValueList*>(fontStyle.get());
-        unsigned numStyles = styleList->length();
-        if (!numStyles)
+        if (!fontStyle->isPrimitiveValue())
             return;
 
-        for (unsigned i = 0; i < numStyles; ++i) {
-            switch (static_cast<CSSPrimitiveValue*>(styleList->itemWithoutBoundsCheck(i))->getIdent()) {
-                case CSSValueAll:
-                    traitsMask |= FontStyleMask;
-                    break;
-                case CSSValueNormal:
-                    traitsMask |= FontStyleNormalMask;
-                    break;
-                case CSSValueItalic:
-                case CSSValueOblique:
-                    traitsMask |= FontStyleItalicMask;
-                    break;
-                default:
-                    break;
-            }
+        switch (static_cast<CSSPrimitiveValue*>(fontStyle.get())->getIdent()) {
+        case CSSValueNormal:
+            traitsMask |= FontStyleNormalMask;
+            break;
+        case CSSValueItalic:
+        case CSSValueOblique:
+            traitsMask |= FontStyleItalicMask;
+            break;
+        default:
+            break;
         }
     } else
-        traitsMask |= FontStyleMask;
+        traitsMask |= FontStyleNormalMask;
 
     if (RefPtr<CSSValue> fontWeight = style->getPropertyCSSValue(CSSPropertyFontWeight)) {
-        if (fontWeight->isPrimitiveValue()) {
-            RefPtr<CSSValueList> list = CSSValueList::createCommaSeparated();
-            list->append(fontWeight);
-            fontWeight = list;
-        } else if (!fontWeight->isValueList())
+        if (!fontWeight->isPrimitiveValue())
             return;
 
-        CSSValueList* weightList = static_cast<CSSValueList*>(fontWeight.get());
-        unsigned numWeights = weightList->length();
-        if (!numWeights)
-            return;
-
-        for (unsigned i = 0; i < numWeights; ++i) {
-            switch (static_cast<CSSPrimitiveValue*>(weightList->itemWithoutBoundsCheck(i))->getIdent()) {
-                case CSSValueAll:
-                    traitsMask |= FontWeightMask;
-                    break;
-                case CSSValueBolder:
-                case CSSValueBold:
-                case CSSValue700:
-                    traitsMask |= FontWeight700Mask;
-                    break;
-                case CSSValueNormal:
-                case CSSValue400:
-                    traitsMask |= FontWeight400Mask;
-                    break;
-                case CSSValue900:
-                    traitsMask |= FontWeight900Mask;
-                    break;
-                case CSSValue800:
-                    traitsMask |= FontWeight800Mask;
-                    break;
-                case CSSValue600:
-                    traitsMask |= FontWeight600Mask;
-                    break;
-                case CSSValue500:
-                    traitsMask |= FontWeight500Mask;
-                    break;
-                case CSSValue300:
-                    traitsMask |= FontWeight300Mask;
-                    break;
-                case CSSValueLighter:
-                case CSSValue200:
-                    traitsMask |= FontWeight200Mask;
-                    break;
-                case CSSValue100:
-                    traitsMask |= FontWeight100Mask;
-                    break;
-                default:
-                    break;
-            }
+        switch (static_cast<CSSPrimitiveValue*>(fontWeight.get())->getIdent()) {
+        case CSSValueBold:
+        case CSSValue700:
+            traitsMask |= FontWeight700Mask;
+            break;
+        case CSSValueNormal:
+        case CSSValue400:
+            traitsMask |= FontWeight400Mask;
+            break;
+        case CSSValue900:
+            traitsMask |= FontWeight900Mask;
+            break;
+        case CSSValue800:
+            traitsMask |= FontWeight800Mask;
+            break;
+        case CSSValue600:
+            traitsMask |= FontWeight600Mask;
+            break;
+        case CSSValue500:
+            traitsMask |= FontWeight500Mask;
+            break;
+        case CSSValue300:
+            traitsMask |= FontWeight300Mask;
+            break;
+        case CSSValue200:
+            traitsMask |= FontWeight200Mask;
+            break;
+        case CSSValue100:
+            traitsMask |= FontWeight100Mask;
+            break;
+        default:
+            break;
         }
     } else
-        traitsMask |= FontWeightMask;
+        traitsMask |= FontWeight400Mask;
 
     if (RefPtr<CSSValue> fontVariant = style->getPropertyCSSValue(CSSPropertyFontVariant)) {
+        // font-variant descriptor can be a value list
         if (fontVariant->isPrimitiveValue()) {
             RefPtr<CSSValueList> list = CSSValueList::createCommaSeparated();
             list->append(fontVariant);
@@ -210,9 +181,6 @@ void CSSFontSelector::addFontFaceRule(const CSSFontFaceRule* fontFaceRule)
 
         for (unsigned i = 0; i < numVariants; ++i) {
             switch (static_cast<CSSPrimitiveValue*>(variantList->itemWithoutBoundsCheck(i))->getIdent()) {
-                case CSSValueAll:
-                    traitsMask |= FontVariantMask;
-                    break;
                 case CSSValueNormal:
                     traitsMask |= FontVariantNormalMask;
                     break;
@@ -420,6 +388,7 @@ static inline bool compareFontFaces(CSSFontFace* first, CSSFontFace* second)
     if (firstHasDesiredVariant != secondHasDesiredVariant)
         return firstHasDesiredVariant;
 
+    // We need to check font-variant css property for CSS2.1 compatibility.
     if ((desiredTraitsMaskForComparison & FontVariantSmallCapsMask) && !first->isLocalFallback() && !second->isLocalFallback()) {
         // Prefer a font that has indicated that it can only support small-caps to a font that claims to support
         // all variants.  The specialized font is more likely to be true small-caps and not require synthesis.
@@ -449,12 +418,11 @@ static inline bool compareFontFaces(CSSFontFace* first, CSSFontFace* second)
     if (firstTraitsMask & desiredTraitsMaskForComparison & FontWeightMask)
         return true;
 
-    // http://www.w3.org/TR/2002/WD-css3-webfonts-20020802/#q46 says: "If there are fewer then 9 weights in the family, the default algorithm
-    // for filling the "holes" is as follows. If '500' is unassigned, it will be assigned the same font as '400'. If any of the values '600',
-    // '700', '800', or '900' remains unassigned, they are assigned to the same face as the next darker assigned keyword, if any, or the next
-    // lighter one otherwise. If any of '300', '200', or '100' remains unassigned, it is assigned to the next lighter assigned keyword, if any,
-    // or the next darker otherwise."
-    // For '400', we made up our own rule (which then '500' follows).
+    // http://www.w3.org/TR/2011/WD-css3-fonts-20111004/#font-matching-algorithm says :
+    //   - If the desired weight is less than 400, weights below the desired weight are checked in descending order followed by weights above the desired weight in ascending order until a match is found.
+    //   - If the desired weight is greater than 500, weights above the desired weight are checked in ascending order followed by weights below the desired weight in descending order until a match is found.
+    //   - If the desired weight is 400, 500 is checked first and then the rule for desired weights less than 400 is used.
+    //   - If the desired weight is 500, 400 is checked first and then the rule for desired weights less than 400 is used.
 
     static const unsigned fallbackRuleSets = 9;
     static const unsigned rulesPerSet = 8;
@@ -462,8 +430,8 @@ static inline bool compareFontFaces(CSSFontFace* first, CSSFontFace* second)
         { FontWeight200Mask, FontWeight300Mask, FontWeight400Mask, FontWeight500Mask, FontWeight600Mask, FontWeight700Mask, FontWeight800Mask, FontWeight900Mask },
         { FontWeight100Mask, FontWeight300Mask, FontWeight400Mask, FontWeight500Mask, FontWeight600Mask, FontWeight700Mask, FontWeight800Mask, FontWeight900Mask },
         { FontWeight200Mask, FontWeight100Mask, FontWeight400Mask, FontWeight500Mask, FontWeight600Mask, FontWeight700Mask, FontWeight800Mask, FontWeight900Mask },
-        { FontWeight500Mask, FontWeight300Mask, FontWeight600Mask, FontWeight200Mask, FontWeight700Mask, FontWeight100Mask, FontWeight800Mask, FontWeight900Mask },
-        { FontWeight400Mask, FontWeight300Mask, FontWeight600Mask, FontWeight200Mask, FontWeight700Mask, FontWeight100Mask, FontWeight800Mask, FontWeight900Mask },
+        { FontWeight500Mask, FontWeight300Mask, FontWeight200Mask, FontWeight100Mask, FontWeight600Mask, FontWeight700Mask, FontWeight800Mask, FontWeight900Mask },
+        { FontWeight400Mask, FontWeight300Mask, FontWeight200Mask, FontWeight100Mask, FontWeight600Mask, FontWeight700Mask, FontWeight800Mask, FontWeight900Mask },
         { FontWeight700Mask, FontWeight800Mask, FontWeight900Mask, FontWeight500Mask, FontWeight400Mask, FontWeight300Mask, FontWeight200Mask, FontWeight100Mask },
         { FontWeight800Mask, FontWeight900Mask, FontWeight600Mask, FontWeight500Mask, FontWeight400Mask, FontWeight300Mask, FontWeight200Mask, FontWeight100Mask },
         { FontWeight900Mask, FontWeight700Mask, FontWeight600Mask, FontWeight500Mask, FontWeight400Mask, FontWeight300Mask, FontWeight200Mask, FontWeight100Mask },
diff --git a/src/3rdparty/webkit/Source/WebCore/css/CSSParser.cpp b/src/3rdparty/webkit/Source/WebCore/css/CSSParser.cpp
index 641ae05e38..ff7cd0ec8e 100644
--- a/src/3rdparty/webkit/Source/WebCore/css/CSSParser.cpp
+++ b/src/3rdparty/webkit/Source/WebCore/css/CSSParser.cpp
@@ -1241,7 +1241,9 @@ bool CSSParser::parseValue(int propId, bool important)
         break;
 
     case CSSPropertyFontStyle:           // normal | italic | oblique | inherit
-        return parseFontStyle(important);
+        if (id == CSSValueNormal || id == CSSValueItalic || id == CSSValueOblique)
+            validPrimitive = true;
+        break;
 
     case CSSPropertyFontVariant:         // normal | small-caps | inherit
         return parseFontVariant(important);
@@ -1291,10 +1293,12 @@ bool CSSParser::parseValue(int propId, bool important)
             break;
         }
         /* nobreak */
-    case CSSPropertyOrphans:              // <integer> | inherit
-    case CSSPropertyWidows:               // <integer> | inherit
-        // ### not supported later on
-        validPrimitive = (!id && validUnit(value, FInteger, false));
+    case CSSPropertyOrphans:              // <integer> | inherit | auto (We've added support for auto for backwards compatibility)
+    case CSSPropertyWidows:               // <integer> | inherit | auto (Ditto)
+        if (id == CSSValueAuto)
+            validPrimitive = true;
+        else
+            validPrimitive = (!id && validUnit(value, FInteger, false));
         break;
 
     case CSSPropertyLineHeight:          // normal | <number> | <length> | <percentage> | inherit
@@ -3760,53 +3764,6 @@ PassRefPtr<CSSValueList> CSSParser::parseFontFamily()
     return list.release();
 }
 
-bool CSSParser::parseFontStyle(bool important)
-{
-    RefPtr<CSSValueList> values;
-    if (m_valueList->size() > 1)
-        values = CSSValueList::createCommaSeparated();
-    CSSParserValue* val;
-    bool expectComma = false;
-    while ((val = m_valueList->current())) {
-        RefPtr<CSSPrimitiveValue> parsedValue;
-        if (!expectComma) {
-            expectComma = true;
-            if (val->id == CSSValueNormal || val->id == CSSValueItalic || val->id == CSSValueOblique)
-                parsedValue = primitiveValueCache()->createIdentifierValue(val->id);
-            else if (val->id == CSSValueAll && !values) {
-                // 'all' is only allowed in @font-face and with no other values. Make a value list to
-                // indicate that we are in the @font-face case.
-                values = CSSValueList::createCommaSeparated();
-                parsedValue = primitiveValueCache()->createIdentifierValue(val->id);
-            }
-        } else if (val->unit == CSSParserValue::Operator && val->iValue == ',') {
-            expectComma = false;
-            m_valueList->next();
-            continue;
-        }
-
-        if (!parsedValue)
-            return false;
-
-        m_valueList->next();
-
-        if (values)
-            values->append(parsedValue.release());
-        else {
-            addProperty(CSSPropertyFontStyle, parsedValue.release(), important);
-            return true;
-        }
-    }
-
-    if (values && values->length()) {
-        m_hasFontFaceOnlyValues = true;
-        addProperty(CSSPropertyFontStyle, values.release(), important);
-        return true;
-    }
-
-    return false;
-}
-
 bool CSSParser::parseFontVariant(bool important)
 {
     RefPtr<CSSValueList> values;
@@ -3856,51 +3813,19 @@ bool CSSParser::parseFontVariant(bool important)
 
 bool CSSParser::parseFontWeight(bool important)
 {
-    RefPtr<CSSValueList> values;
-    if (m_valueList->size() > 1)
-        values = CSSValueList::createCommaSeparated();
-    CSSParserValue* val;
-    bool expectComma = false;
-    while ((val = m_valueList->current())) {
-        RefPtr<CSSPrimitiveValue> parsedValue;
-        if (!expectComma) {
-            expectComma = true;
-            if (val->unit == CSSPrimitiveValue::CSS_IDENT) {
-                if (val->id >= CSSValueNormal && val->id <= CSSValue900)
-                    parsedValue = primitiveValueCache()->createIdentifierValue(val->id);
-                else if (val->id == CSSValueAll && !values) {
-                    // 'all' is only allowed in @font-face and with no other values. Make a value list to
-                    // indicate that we are in the @font-face case.
-                    values = CSSValueList::createCommaSeparated();
-                    parsedValue = primitiveValueCache()->createIdentifierValue(val->id);
-                }
-            } else if (validUnit(val, FInteger | FNonNeg, false)) {
-                int weight = static_cast<int>(val->fValue);
-                if (!(weight % 100) && weight >= 100 && weight <= 900)
-                    parsedValue = primitiveValueCache()->createIdentifierValue(CSSValue100 + weight / 100 - 1);
-            }
-        } else if (val->unit == CSSParserValue::Operator && val->iValue == ',') {
-            expectComma = false;
-            m_valueList->next();
-            continue;
-        }
-
-        if (!parsedValue)
-            return false;
-
-        m_valueList->next();
+    if (m_valueList->size() != 1)
+        return false;
 
-        if (values)
-            values->append(parsedValue.release());
-        else {
-            addProperty(CSSPropertyFontWeight, parsedValue.release(), important);
-            return true;
-        }
+    CSSParserValue* value = m_valueList->current();
+    if ((value->id >= CSSValueNormal) && (value->id <= CSSValue900)) {
+        addProperty(CSSPropertyFontWeight, primitiveValueCache()->createIdentifierValue(value->id), important);
+        return true;
     }
 
-    if (values && values->length()) {
-        m_hasFontFaceOnlyValues = true;
-        addProperty(CSSPropertyFontWeight, values.release(), important);
+    if (validUnit(value, FInteger | FNonNeg, false)) {
+        int weight = static_cast<int>(value->fValue);
+            if (!(weight % 100) && weight >= 100 && weight <= 900)
+                addProperty(CSSPropertyFontWeight, primitiveValueCache()->createIdentifierValue(CSSValue100 + weight / 100 - 1), important);
         return true;
     }
 
@@ -6339,7 +6264,7 @@ CSSRule* CSSParser::createFontFaceRule()
     for (unsigned i = 0; i < m_numParsedProperties; ++i) {
         CSSProperty* property = m_parsedProperties[i];
         int id = property->id();
-        if ((id == CSSPropertyFontWeight || id == CSSPropertyFontStyle || id == CSSPropertyFontVariant) && property->value()->isPrimitiveValue()) {
+        if (id == CSSPropertyFontVariant && property->value()->isPrimitiveValue()) {
             RefPtr<CSSValue> value = property->m_value.release();
             property->m_value = CSSValueList::createCommaSeparated();
             static_cast<CSSValueList*>(property->value())->append(value.release());
@@ -6466,7 +6391,7 @@ void CSSParser::deleteFontFaceOnlyValues()
     for (unsigned i = 0; i < m_numParsedProperties; ++i) {
         CSSProperty* property = m_parsedProperties[i];
         int id = property->id();
-        if ((id == CSSPropertyFontWeight || id == CSSPropertyFontStyle || id == CSSPropertyFontVariant) && property->value()->isValueList()) {
+        if (id == CSSPropertyFontVariant && property->value()->isValueList()) {
             delete property;
             deletedProperties++;
         } else if (deletedProperties)
diff --git a/src/3rdparty/webkit/Source/WebCore/css/CSSParser.h b/src/3rdparty/webkit/Source/WebCore/css/CSSParser.h
index 0524302262..0b8b6916ad 100644
--- a/src/3rdparty/webkit/Source/WebCore/css/CSSParser.h
+++ b/src/3rdparty/webkit/Source/WebCore/css/CSSParser.h
@@ -140,7 +140,6 @@ namespace WebCore {
 
         static bool parseColor(const String&, RGBA32& rgb, bool strict);
 
-        bool parseFontStyle(bool important);
         bool parseFontVariant(bool important);
         bool parseFontWeight(bool important);
         bool parseFontFaceSrc();
diff --git a/src/3rdparty/webkit/Source/WebCore/css/CSSStyleSelector.cpp b/src/3rdparty/webkit/Source/WebCore/css/CSSStyleSelector.cpp
index 7bb30d3c29..44f5d08830 100644
--- a/src/3rdparty/webkit/Source/WebCore/css/CSSStyleSelector.cpp
+++ b/src/3rdparty/webkit/Source/WebCore/css/CSSStyleSelector.cpp
@@ -4123,19 +4123,32 @@ void CSSStyleSelector::applyProperty(int id, CSSValue *value)
     }
     case CSSPropertyWidows:
     {
-        HANDLE_INHERIT_AND_INITIAL(widows, Widows)
-        if (!primitiveValue || primitiveValue->primitiveType() != CSSPrimitiveValue::CSS_NUMBER)
+        if (isInherit) {
+            if (m_parentStyle->hasAutoWidows())
+                m_style->setHasAutoWidows();
+            else
+                m_style->setWidows(m_parentStyle->widows());
             return;
-        m_style->setWidows(primitiveValue->getIntValue());
+        } else if (isInitial || primitiveValue->getIdent() == CSSValueAuto) {
+            m_style->setHasAutoWidows();
+            return;
+        }
+        m_style->setWidows(static_cast<short>(primitiveValue->getIntValue()));
         return;
     }
-        
     case CSSPropertyOrphans:
     {
-        HANDLE_INHERIT_AND_INITIAL(orphans, Orphans)
-        if (!primitiveValue || primitiveValue->primitiveType() != CSSPrimitiveValue::CSS_NUMBER)
+        if (isInherit) {
+            if (m_parentStyle->hasAutoOrphans())
+                m_style->setHasAutoOrphans();
+            else
+                m_style->setOrphans(m_parentStyle->widows());
             return;
-        m_style->setOrphans(primitiveValue->getIntValue());
+        } else if (isInitial || primitiveValue->getIdent() == CSSValueAuto) {
+            m_style->setHasAutoOrphans();
+            return;
+        }
+        m_style->setOrphans(static_cast<short>(primitiveValue->getIntValue()));
         return;
     }        
 
diff --git a/src/3rdparty/webkit/Source/WebCore/dom/DOMAllInOne.cpp b/src/3rdparty/webkit/Source/WebCore/dom/DOMAllInOne.cpp
index 55674dfee9..7f855b70ef 100644
--- a/src/3rdparty/webkit/Source/WebCore/dom/DOMAllInOne.cpp
+++ b/src/3rdparty/webkit/Source/WebCore/dom/DOMAllInOne.cpp
@@ -86,6 +86,7 @@
 #include "MouseRelatedEvent.cpp"
 #include "MutationEvent.cpp"
 #include "NameNodeList.cpp"
+#include "Node.cpp"
 #include "NodeFilter.cpp"
 #include "NodeFilterCondition.cpp"
 #include "NodeIterator.cpp"
@@ -100,7 +101,6 @@
 #include "PositionIterator.cpp"
 #include "ProcessingInstruction.cpp"
 #include "ProgressEvent.cpp"
-#include "Range.cpp"
 #include "RegisteredEventListener.cpp"
 #include "ScopedEventQueue.cpp"
 #include "ScriptElement.cpp"
@@ -121,7 +121,6 @@
 #include "Touch.cpp"
 #include "TouchEvent.cpp"
 #include "TouchList.cpp"
-#include "TransformSourceLibxslt.cpp"
 #include "Traversal.cpp"
 #include "TreeScope.cpp"
 #include "TreeWalker.cpp"
@@ -135,4 +134,3 @@
 #include "WheelEvent.cpp"
 #include "WindowEventContext.cpp"
 #include "XMLDocumentParser.cpp"
-#include "XMLDocumentParserScope.cpp"
diff --git a/src/3rdparty/webkit/Source/WebCore/editing/EditingAllInOne.cpp b/src/3rdparty/webkit/Source/WebCore/editing/EditingAllInOne.cpp
index f38cbe62a6..9381c0ad17 100644
--- a/src/3rdparty/webkit/Source/WebCore/editing/EditingAllInOne.cpp
+++ b/src/3rdparty/webkit/Source/WebCore/editing/EditingAllInOne.cpp
@@ -61,8 +61,7 @@
 #include <ReplaceSelectionCommand.cpp>
 #include <SelectionController.cpp>
 #include <SetNodeAttributeCommand.cpp>
-#include <SmartReplace.cpp>
-#include <SmartReplaceCF.cpp>
+#include <SmartReplaceICU.cpp>
 #include <SpellingCorrectionController.cpp>
 #include <SpellChecker.cpp>
 #include <SplitElementCommand.cpp>
diff --git a/src/3rdparty/webkit/Source/WebCore/features.pri b/src/3rdparty/webkit/Source/WebCore/features.pri
index 612ed8a728..ce8de52925 100644
--- a/src/3rdparty/webkit/Source/WebCore/features.pri
+++ b/src/3rdparty/webkit/Source/WebCore/features.pri
@@ -45,6 +45,7 @@ contains(DEFINES, ENABLE_SINGLE_THREADED=1) {
 !contains(DEFINES, ENABLE_DIRECTORY_UPLOAD=.): DEFINES += ENABLE_DIRECTORY_UPLOAD=0
 !contains(DEFINES, ENABLE_FILE_SYSTEM=.): DEFINES += ENABLE_FILE_SYSTEM=0
 !contains(DEFINES, ENABLE_QUOTA=.): DEFINES += ENABLE_QUOTA=0 
+!contains(DEFINES, ENABLE_ZLIB=.): DEFINES += ENABLE_ZLIB=1
 
 # turn on SQLITE support if any of the dependent features are turned on
 !contains(DEFINES, ENABLE_SQLITE=.) {
diff --git a/src/3rdparty/webkit/Source/WebCore/generated/JSCanvasRenderingContext2D.cpp b/src/3rdparty/webkit/Source/WebCore/generated/JSCanvasRenderingContext2D.cpp
index 0a66d056d1..c3c6fb3568 100644
--- a/src/3rdparty/webkit/Source/WebCore/generated/JSCanvasRenderingContext2D.cpp
+++ b/src/3rdparty/webkit/Source/WebCore/generated/JSCanvasRenderingContext2D.cpp
@@ -129,7 +129,7 @@ bool JSCanvasRenderingContext2DConstructor::getOwnPropertyDescriptor(ExecState*
 #define THUNK_GENERATOR(generator)
 #endif
 
-static const HashTableValue JSCanvasRenderingContext2DPrototypeTableValues[45] =
+static const HashTableValue JSCanvasRenderingContext2DPrototypeTableValues[46] =
 {
     { "save", DontDelete | Function, (intptr_t)static_cast<NativeFunction>(jsCanvasRenderingContext2DPrototypeFunctionSave), (intptr_t)0 THUNK_GENERATOR(0) },
     { "restore", DontDelete | Function, (intptr_t)static_cast<NativeFunction>(jsCanvasRenderingContext2DPrototypeFunctionRestore), (intptr_t)0 THUNK_GENERATOR(0) },
@@ -167,6 +167,7 @@ static const HashTableValue JSCanvasRenderingContext2DPrototypeTableValues[45] =
     { "strokeText", DontDelete | Function, (intptr_t)static_cast<NativeFunction>(jsCanvasRenderingContext2DPrototypeFunctionStrokeText), (intptr_t)0 THUNK_GENERATOR(0) },
     { "setStrokeColor", DontDelete | Function, (intptr_t)static_cast<NativeFunction>(jsCanvasRenderingContext2DPrototypeFunctionSetStrokeColor), (intptr_t)0 THUNK_GENERATOR(0) },
     { "setFillColor", DontDelete | Function, (intptr_t)static_cast<NativeFunction>(jsCanvasRenderingContext2DPrototypeFunctionSetFillColor), (intptr_t)0 THUNK_GENERATOR(0) },
+    { "setLineDash", DontDelete | Function, (intptr_t)static_cast<NativeFunction>(jsCanvasRenderingContext2DPrototypeFunctionSetLineDash), (intptr_t)0 THUNK_GENERATOR(0) },
     { "strokeRect", DontDelete | Function, (intptr_t)static_cast<NativeFunction>(jsCanvasRenderingContext2DPrototypeFunctionStrokeRect), (intptr_t)0 THUNK_GENERATOR(0) },
     { "drawImage", DontDelete | Function, (intptr_t)static_cast<NativeFunction>(jsCanvasRenderingContext2DPrototypeFunctionDrawImage), (intptr_t)0 THUNK_GENERATOR(0) },
     { "drawImageFromRect", DontDelete | Function, (intptr_t)static_cast<NativeFunction>(jsCanvasRenderingContext2DPrototypeFunctionDrawImageFromRect), (intptr_t)0 THUNK_GENERATOR(0) },
@@ -1147,6 +1148,15 @@ EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionSetFillC
     return JSValue::encode(castedThis->setFillColor(exec));
 }
 
+EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionSetLineDash(ExecState* exec)
+{
+    JSValue thisValue = exec->hostThisValue();
+    if (!thisValue.inherits(&JSCanvasRenderingContext2D::s_info))
+        return throwVMTypeError(exec);
+    JSCanvasRenderingContext2D* castedThis = static_cast<JSCanvasRenderingContext2D*>(asObject(thisValue));
+    return JSValue::encode(castedThis->setLineDash(exec));
+}
+
 EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionStrokeRect(ExecState* exec)
 {
     JSValue thisValue = exec->hostThisValue();
diff --git a/src/3rdparty/webkit/Source/WebCore/generated/JSCanvasRenderingContext2D.h b/src/3rdparty/webkit/Source/WebCore/generated/JSCanvasRenderingContext2D.h
index c557645ca9..7c40fca4b0 100644
--- a/src/3rdparty/webkit/Source/WebCore/generated/JSCanvasRenderingContext2D.h
+++ b/src/3rdparty/webkit/Source/WebCore/generated/JSCanvasRenderingContext2D.h
@@ -56,6 +56,7 @@ public:
     JSC::JSValue strokeText(JSC::ExecState*);
     JSC::JSValue setStrokeColor(JSC::ExecState*);
     JSC::JSValue setFillColor(JSC::ExecState*);
+    JSC::JSValue setLineDash(JSC::ExecState*);
     JSC::JSValue strokeRect(JSC::ExecState*);
     JSC::JSValue drawImage(JSC::ExecState*);
     JSC::JSValue drawImageFromRect(JSC::ExecState*);
@@ -122,6 +123,7 @@ JSC::EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionFil
 JSC::EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionStrokeText(JSC::ExecState*);
 JSC::EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionSetStrokeColor(JSC::ExecState*);
 JSC::EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionSetFillColor(JSC::ExecState*);
+JSC::EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionSetLineDash(JSC::ExecState*);
 JSC::EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionStrokeRect(JSC::ExecState*);
 JSC::EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionDrawImage(JSC::ExecState*);
 JSC::EncodedJSValue JSC_HOST_CALL jsCanvasRenderingContext2DPrototypeFunctionDrawImageFromRect(JSC::ExecState*);
diff --git a/src/3rdparty/webkit/Source/WebCore/html/HTMLElementsAllInOne.cpp b/src/3rdparty/webkit/Source/WebCore/html/HTMLElementsAllInOne.cpp
index 7fda8aafe0..ccb890fc37 100644
--- a/src/3rdparty/webkit/Source/WebCore/html/HTMLElementsAllInOne.cpp
+++ b/src/3rdparty/webkit/Source/WebCore/html/HTMLElementsAllInOne.cpp
@@ -31,17 +31,14 @@
 // This source file coalesces the HTML elements into a single object file to
 // reduce bloat and allow us to link release builds on 32-bit Windows.
 
-#include "HTMLAnchorElement.cpp"
 #include "HTMLAppletElement.cpp"
 #include "HTMLAreaElement.cpp"
-#include "HTMLAudioElement.cpp"
 #include "HTMLBRElement.cpp"
 #include "HTMLBaseElement.cpp"
 #include "HTMLBaseFontElement.cpp"
 #include "HTMLBlockquoteElement.cpp"
 #include "HTMLBodyElement.cpp"
 #include "HTMLButtonElement.cpp"
-#include "HTMLCanvasElement.cpp"
 #include "HTMLDataListElement.cpp"
 #include "HTMLDetailsElement.cpp"
 #include "HTMLDListElement.cpp"
@@ -72,26 +69,23 @@
 #include "HTMLLinkElement.cpp"
 #include "HTMLMapElement.cpp"
 #include "HTMLMarqueeElement.cpp"
-#include "HTMLMediaElement.cpp"
 #include "HTMLMenuElement.cpp"
 #include "HTMLMetaElement.cpp"
 #include "HTMLMeterElement.cpp"
 #include "HTMLModElement.cpp"
-#include "HTMLNoScriptElement.cpp"
 #include "HTMLOListElement.cpp"
 #include "HTMLObjectElement.cpp"
 #include "HTMLOptGroupElement.cpp"
 #include "HTMLOptionElement.cpp"
+#include "HTMLOutputElement.cpp"
 #include "HTMLParagraphElement.cpp"
 #include "HTMLParamElement.cpp"
-#include "HTMLPlugInElement.cpp"
 #include "HTMLPlugInImageElement.cpp"
 #include "HTMLPreElement.cpp"
 #include "HTMLProgressElement.cpp"
 #include "HTMLQuoteElement.cpp"
 #include "HTMLScriptElement.cpp"
 #include "HTMLSelectElement.cpp"
-#include "HTMLSourceElement.cpp"
 #include "HTMLStyleElement.cpp"
 #include "HTMLSummaryElement.cpp"
 #include "HTMLTableCaptionElement.cpp"
@@ -104,4 +98,3 @@
 #include "HTMLTextAreaElement.cpp"
 #include "HTMLTitleElement.cpp"
 #include "HTMLUListElement.cpp"
-#include "HTMLVideoElement.cpp"
diff --git a/src/3rdparty/webkit/Source/WebCore/html/canvas/CanvasRenderingContext2D.cpp b/src/3rdparty/webkit/Source/WebCore/html/canvas/CanvasRenderingContext2D.cpp
index 453248498e..902a9c925e 100644
--- a/src/3rdparty/webkit/Source/WebCore/html/canvas/CanvasRenderingContext2D.cpp
+++ b/src/3rdparty/webkit/Source/WebCore/html/canvas/CanvasRenderingContext2D.cpp
@@ -1047,6 +1047,12 @@ void CanvasRenderingContext2D::fillRect(float x, float y, float width, float hei
     didDraw(rect);
 }
 
+void CanvasRenderingContext2D::setLineDash(DashArray lineDash, float dashOffset)
+{
+    GraphicsContext* c = drawingContext();
+    c->setLineDash(lineDash, dashOffset);
+}
+
 void CanvasRenderingContext2D::strokeRect(float x, float y, float width, float height)
 {
     if (!validateRectForCanvas(x, y, width, height))
diff --git a/src/3rdparty/webkit/Source/WebCore/html/canvas/CanvasRenderingContext2D.h b/src/3rdparty/webkit/Source/WebCore/html/canvas/CanvasRenderingContext2D.h
index d95ef7471c..21939b9d1a 100644
--- a/src/3rdparty/webkit/Source/WebCore/html/canvas/CanvasRenderingContext2D.h
+++ b/src/3rdparty/webkit/Source/WebCore/html/canvas/CanvasRenderingContext2D.h
@@ -31,6 +31,7 @@
 #include "Color.h"
 #include "FloatSize.h"
 #include "Font.h"
+#include "GraphicsContext.h"
 #include "GraphicsTypes.h"
 #include "Path.h"
 #include "PlatformString.h"
@@ -152,6 +153,7 @@ public:
 
     void clearRect(float x, float y, float width, float height);
     void fillRect(float x, float y, float width, float height);
+    void setLineDash(DashArray lineDash, float setLineDash);
     void strokeRect(float x, float y, float width, float height);
     void strokeRect(float x, float y, float width, float height, float lineWidth);
 
diff --git a/src/3rdparty/webkit/Source/WebCore/page/FrameView.cpp b/src/3rdparty/webkit/Source/WebCore/page/FrameView.cpp
index ef72fb7c10..54ff69cc48 100644
--- a/src/3rdparty/webkit/Source/WebCore/page/FrameView.cpp
+++ b/src/3rdparty/webkit/Source/WebCore/page/FrameView.cpp
@@ -1080,7 +1080,9 @@ void FrameView::adjustMediaTypeForPrinting(bool printing)
     if (printing) {
         if (m_mediaTypeWhenNotPrinting.isNull())
             m_mediaTypeWhenNotPrinting = mediaType();
-            setMediaType("print");
+
+        String mediaType = (m_frame && m_frame->settings())?m_frame->settings()->printingMediaType():"print";
+        setMediaType(mediaType);
     } else {
         if (!m_mediaTypeWhenNotPrinting.isNull())
             setMediaType(m_mediaTypeWhenNotPrinting);
diff --git a/src/3rdparty/webkit/Source/WebCore/page/PrintContext.cpp b/src/3rdparty/webkit/Source/WebCore/page/PrintContext.cpp
index 660ad11b9d..443e500fd2 100644
--- a/src/3rdparty/webkit/Source/WebCore/page/PrintContext.cpp
+++ b/src/3rdparty/webkit/Source/WebCore/page/PrintContext.cpp
@@ -26,6 +26,7 @@
 #include "FrameView.h"
 #include "RenderLayer.h"
 #include "RenderView.h"
+#include "Settings.h"
 #include <wtf/text/StringConcatenate.h>
 
 namespace WebCore {
@@ -82,9 +83,16 @@ void PrintContext::computePageRects(const FloatRect& printRect, float headerHeig
     float pageWidth;
     float pageHeight;
     if (isHorizontal) {
-        float ratio = printRect.height() / printRect.width();
         pageWidth = view->docWidth();
-        pageHeight = floorf(pageWidth * ratio);
+        ///NOTE: if we do not reuse the previously set logical page height,
+        ///      we can end up with off-by-one errors in the page height,
+        ///      leading to rendering issues (e.g. rows overlap pagebreaks)
+        if (view->pageLogicalHeight() == 0) {
+            float ratio = printRect.height() / printRect.width();
+            pageHeight = floorf(pageWidth * ratio);
+        } else {
+            pageHeight = view->pageLogicalHeight();
+        }
     } else {
         float ratio = printRect.width() / printRect.height();
         pageHeight = view->docHeight();
@@ -182,11 +190,21 @@ void PrintContext::begin(float width, float height)
     // This function can be called multiple times to adjust printing parameters without going back to screen mode.
     m_isPrinting = true;
 
-    float minLayoutWidth = width * printingMinimumShrinkFactor;
-    float minLayoutHeight = height * printingMinimumShrinkFactor;
+    float minimumShrinkFactor = m_frame->settings() ? 
+        m_frame->settings()->printingMinimumShrinkFactor() : 0.0f;
+    float maximumShrinkFactor = m_frame->settings() ? 
+        m_frame->settings()->printingMaximumShrinkFactor() : 0.0f;
+
+    if (maximumShrinkFactor < minimumShrinkFactor || minimumShrinkFactor <= 0.0f) {
+        minimumShrinkFactor = printingMinimumShrinkFactor;
+        maximumShrinkFactor = printingMaximumShrinkFactor;
+    }
+    
+    float minLayoutWidth = width * minimumShrinkFactor;
+    float minLayoutHeight = height * minimumShrinkFactor;
 
     // This changes layout, so callers need to make sure that they don't paint to screen while in printing mode.
-    m_frame->setPrinting(true, FloatSize(minLayoutWidth, minLayoutHeight), printingMaximumShrinkFactor / printingMinimumShrinkFactor, Frame::AdjustViewSize);
+    m_frame->setPrinting(true, FloatSize(minLayoutWidth, minLayoutHeight), maximumShrinkFactor / minimumShrinkFactor, Frame::AdjustViewSize);
 }
 
 float PrintContext::computeAutomaticScaleFactor(const FloatSize& availablePaperSize)
diff --git a/src/3rdparty/webkit/Source/WebCore/page/PrintContext.h b/src/3rdparty/webkit/Source/WebCore/page/PrintContext.h
index aadff475fd..19f378e24e 100644
--- a/src/3rdparty/webkit/Source/WebCore/page/PrintContext.h
+++ b/src/3rdparty/webkit/Source/WebCore/page/PrintContext.h
@@ -83,6 +83,8 @@ public:
     // (pageSizeInPixels.height() + 1) * number-of-pages - 1
     static void spoolAllPagesWithBoundaries(Frame*, GraphicsContext&, const FloatSize& pageSizeInPixels);
 
+public:
+    const Vector<IntRect> & getPageRects() const {return m_pageRects;}
 protected:
     Frame* m_frame;
     Vector<IntRect> m_pageRects;
diff --git a/src/3rdparty/webkit/Source/WebCore/page/Settings.cpp b/src/3rdparty/webkit/Source/WebCore/page/Settings.cpp
index 2025bd04de..5414246623 100644
--- a/src/3rdparty/webkit/Source/WebCore/page/Settings.cpp
+++ b/src/3rdparty/webkit/Source/WebCore/page/Settings.cpp
@@ -87,6 +87,7 @@ static EditingBehaviorType editingBehaviorTypeForPlatform()
 
 Settings::Settings(Page* page)
     : m_page(page)
+    , m_printingMediaType("print")
     , m_editableLinkBehavior(EditableLinkDefaultBehavior)
     , m_textDirectionSubmenuInclusionBehavior(TextDirectionSubmenuAutomaticallyIncluded)
     , m_passwordEchoDurationInSeconds(1)
@@ -184,6 +185,8 @@ Settings::Settings(Page* page)
     , m_allowDisplayOfInsecureContent(true)
     , m_allowRunningOfInsecureContent(true)
     , m_passwordEchoEnabled(false)
+    , m_printingMinimumShrinkFactor(0.0)
+    , m_printingMaximumShrinkFactor(0.0)
 {
     // A Frame may not have been created yet, so we initialize the AtomicString 
     // hash before trying to use it.
@@ -569,6 +572,11 @@ void Settings::setApplicationChromeMode(bool mode)
     m_inApplicationChromeMode = mode;
 }
 
+void Settings::setPrintingMediaType(const String& type)
+{
+    m_printingMediaType = type;
+}
+
 void Settings::setOfflineWebApplicationCacheEnabled(bool enabled)
 {
     m_offlineWebApplicationCacheEnabled = enabled;
@@ -744,4 +752,15 @@ void Settings::setTiledBackingStoreEnabled(bool enabled)
 #endif
 }
 
+void Settings::setPrintingMinimumShrinkFactor(float printingMinimumShrinkFactor)
+{
+    m_printingMinimumShrinkFactor = printingMinimumShrinkFactor;
+}    
+
+void Settings::setPrintingMaximumShrinkFactor(float printingMaximumShrinkFactor)
+{
+    m_printingMaximumShrinkFactor = printingMaximumShrinkFactor;
+}    
+
+
 } // namespace WebCore
diff --git a/src/3rdparty/webkit/Source/WebCore/page/Settings.h b/src/3rdparty/webkit/Source/WebCore/page/Settings.h
index 1d2a138609..d827693a95 100644
--- a/src/3rdparty/webkit/Source/WebCore/page/Settings.h
+++ b/src/3rdparty/webkit/Source/WebCore/page/Settings.h
@@ -258,6 +258,9 @@ namespace WebCore {
         void setApplicationChromeMode(bool);
         bool inApplicationChromeMode() const { return m_inApplicationChromeMode; }
 
+        void setPrintingMediaType(const String&);
+        const String& printingMediaType() const { return m_printingMediaType; }
+
         void setOfflineWebApplicationCacheEnabled(bool);
         bool offlineWebApplicationCacheEnabled() const { return m_offlineWebApplicationCacheEnabled; }
 
@@ -349,6 +352,12 @@ namespace WebCore {
         
         void setTiledBackingStoreEnabled(bool);
         bool tiledBackingStoreEnabled() const { return m_tiledBackingStoreEnabled; }
+	
+        void setPrintingMinimumShrinkFactor(float);
+        float printingMinimumShrinkFactor() const { return m_printingMinimumShrinkFactor; }
+	
+        void setPrintingMaximumShrinkFactor(float);
+        float printingMaximumShrinkFactor() const { return m_printingMaximumShrinkFactor; }
 
         void setPaginateDuringLayoutEnabled(bool flag) { m_paginateDuringLayoutEnabled = flag; }
         bool paginateDuringLayoutEnabled() const { return m_paginateDuringLayoutEnabled; }
@@ -419,6 +428,7 @@ namespace WebCore {
         String m_defaultTextEncodingName;
         String m_ftpDirectoryTemplatePath;
         String m_localStorageDatabasePath;
+        String m_printingMediaType;
         KURL m_userStyleSheetLocation;
         AtomicString m_standardFontFamily;
         AtomicString m_fixedFontFamily;
@@ -429,6 +439,8 @@ namespace WebCore {
         EditableLinkBehavior m_editableLinkBehavior;
         TextDirectionSubmenuInclusionBehavior m_textDirectionSubmenuInclusionBehavior;
         double m_passwordEchoDurationInSeconds;
+        float m_printingMinimumShrinkFactor;
+        float m_printingMaximumShrinkFactor;
         int m_minimumFontSize;
         int m_minimumLogicalFontSize;
         int m_defaultFontSize;
diff --git a/src/3rdparty/webkit/Source/WebCore/page/animation/AnimationBase.cpp b/src/3rdparty/webkit/Source/WebCore/page/animation/AnimationBase.cpp
index 00a15e82f8..b04a8f99b0 100644
--- a/src/3rdparty/webkit/Source/WebCore/page/animation/AnimationBase.cpp
+++ b/src/3rdparty/webkit/Source/WebCore/page/animation/AnimationBase.cpp
@@ -656,6 +656,8 @@ void AnimationBase::ensurePropertyMap()
         gPropertyWrappers->append(new PropertyWrapper<short>(CSSPropertyWebkitBorderHorizontalSpacing, &RenderStyle::horizontalBorderSpacing, &RenderStyle::setHorizontalBorderSpacing));
         gPropertyWrappers->append(new PropertyWrapper<short>(CSSPropertyWebkitBorderVerticalSpacing, &RenderStyle::verticalBorderSpacing, &RenderStyle::setVerticalBorderSpacing));
         gPropertyWrappers->append(new PropertyWrapper<int>(CSSPropertyZIndex, &RenderStyle::zIndex, &RenderStyle::setZIndex));
+        gPropertyWrappers->append(new PropertyWrapper<short>(CSSPropertyOrphans, &RenderStyle::orphans, &RenderStyle::setOrphans));
+        gPropertyWrappers->append(new PropertyWrapper<short>(CSSPropertyWidows, &RenderStyle::widows, &RenderStyle::setWidows));
         gPropertyWrappers->append(new PropertyWrapper<Length>(CSSPropertyLineHeight, &RenderStyle::lineHeight, &RenderStyle::setLineHeight));
         gPropertyWrappers->append(new PropertyWrapper<int>(CSSPropertyOutlineOffset, &RenderStyle::outlineOffset, &RenderStyle::setOutlineOffset));
         gPropertyWrappers->append(new PropertyWrapper<unsigned short>(CSSPropertyOutlineWidth, &RenderStyle::outlineWidth, &RenderStyle::setOutlineWidth));
diff --git a/src/3rdparty/webkit/Source/WebCore/platform/graphics/qt/FontCacheQt.cpp b/src/3rdparty/webkit/Source/WebCore/platform/graphics/qt/FontCacheQt.cpp
index 31966d7ea5..505abc8cd9 100644
--- a/src/3rdparty/webkit/Source/WebCore/platform/graphics/qt/FontCacheQt.cpp
+++ b/src/3rdparty/webkit/Source/WebCore/platform/graphics/qt/FontCacheQt.cpp
@@ -35,6 +35,7 @@
 #include <wtf/text/StringHash.h>
 
 #include <QFont>
+#include <QFontDatabase>
 #if HAVE(QRAWFONT)
 #include <QTextLayout>
 #endif
@@ -106,6 +107,10 @@ void FontCache::getTraitsInFamily(const AtomicString&, Vector<unsigned>&)
 
 FontPlatformData* FontCache::createFontPlatformData(const FontDescription& fontDescription, const AtomicString& familyName)
 {
+    QFontDatabase db;
+    if (!db.hasFamily(familyName))
+        return 0;
+
     return new FontPlatformData(fontDescription, familyName);
 }
 
diff --git a/src/3rdparty/webkit/Source/WebCore/platform/graphics/qt/FontCustomPlatformData.h b/src/3rdparty/webkit/Source/WebCore/platform/graphics/qt/FontCustomPlatformData.h
index 3996d223b9..d880f73256 100644
--- a/src/3rdparty/webkit/Source/WebCore/platform/graphics/qt/FontCustomPlatformData.h
+++ b/src/3rdparty/webkit/Source/WebCore/platform/graphics/qt/FontCustomPlatformData.h
@@ -43,9 +43,11 @@ public:
 
     // for use with QFontDatabase::addApplicationFont/removeApplicationFont
     int m_handle;
+    bool m_italic;
+    bool m_bold;
 
-    FontPlatformData fontPlatformData(int size, bool bold, bool italic, FontOrientation = Horizontal, TextOrientation = TextOrientationVerticalRight,
-                                      FontWidthVariant = RegularWidth, FontRenderingMode = NormalRenderingMode);
+    FontPlatformData fontPlatformData(int size, bool syntheticBold, bool syntheticItalic, FontOrientation = Horizontal, 
+        TextOrientation = TextOrientationVerticalRight, FontWidthVariant = RegularWidth, FontRenderingMode = NormalRenderingMode);
 
     static bool supportsFormat(const String&);
 };
diff --git a/src/3rdparty/webkit/Source/WebCore/platform/graphics/qt/FontCustomPlatformDataQt.cpp b/src/3rdparty/webkit/Source/WebCore/platform/graphics/qt/FontCustomPlatformDataQt.cpp
index 20f161a8f2..0ce1563d53 100644
--- a/src/3rdparty/webkit/Source/WebCore/platform/graphics/qt/FontCustomPlatformDataQt.cpp
+++ b/src/3rdparty/webkit/Source/WebCore/platform/graphics/qt/FontCustomPlatformDataQt.cpp
@@ -24,7 +24,9 @@
 
 #include "FontPlatformData.h"
 #include "SharedBuffer.h"
+#include "WOFFFileFormat.h"
 #include <QFontDatabase>
+#include <QMap>
 #include <QStringList>
 
 namespace WebCore {
@@ -34,36 +36,113 @@ FontCustomPlatformData::~FontCustomPlatformData()
     QFontDatabase::removeApplicationFont(m_handle);
 }
 
-FontPlatformData FontCustomPlatformData::fontPlatformData(int size, bool bold, bool italic, FontOrientation, TextOrientation, FontWidthVariant, FontRenderingMode)
+FontPlatformData FontCustomPlatformData::fontPlatformData(int size, bool syntheticBold, bool syntheticItalic, FontOrientation, TextOrientation, FontWidthVariant, FontRenderingMode)
 {
+    // Note that syntheticBold and syntheticItalic are only set by CSSFontSelector
+    // (the sole user of this class) if the markup has requested bold or italic
+    // (e.g. <i>text</i>) but the @font-face rule for the font does not specify support
+    // for it (e.g. @font-face { font-family: "font"; font-style: normal;).
+
     QFont font;
-    font.setFamily(QFontDatabase::applicationFontFamilies(m_handle)[0]);
+    QFontDatabase db;
+    
+    QString family = QFontDatabase::applicationFontFamilies(m_handle)[0];
+    font.setFamily(family);
     font.setPixelSize(size);
-    if (bold)
+    if (m_bold || syntheticBold)
         font.setWeight(QFont::Bold);
-    font.setItalic(italic);
+    font.setItalic(m_italic || syntheticItalic);
 
     return FontPlatformData(font);
 }
 
+static QMap<QString, QStringList> currentStyles(const QStringList& families, const QFontDatabase& db)
+{
+    QMap<QString, QStringList> styles;
+    for (int i = 0; i < families.size(); ++i)
+        styles[families.at(i)].append(db.styles(families.at(i)));
+    return styles;
+}
+
+static QStringList stylesAddedByFont(const QString& familyAdded, const QStringList& stylesAdded, const QMap<QString, QStringList>& styles)
+{
+    QStringList newStyles = stylesAdded;
+    for (int i = 0; i < styles[familyAdded].size(); ++i)
+        newStyles.removeAll(styles[familyAdded].at(i));
+    return newStyles;
+}
+
+static bool strictlyItalicAddedByFont(const QString& familyAdded, const QStringList& stylesAdded, const QFontDatabase& db)
+{
+    bool italic = false;
+    for (int i = 0; i < stylesAdded.size(); ++i) {
+        if (db.italic(familyAdded, stylesAdded.at(i))) {
+            italic = true;
+        } else if (!db.bold(familyAdded, stylesAdded.at(i)))
+            return false;
+    }
+    return italic;
+}
+
+static bool strictlyBoldAddedByFont(const QString& familyAdded, const QStringList& stylesAdded, const QFontDatabase& db)
+{
+    bool bold = false;
+    for (int i = 0; i < stylesAdded.size(); ++i) {
+        if (db.bold(familyAdded, stylesAdded.at(i))) {
+            bold = true;
+        } else if (!db.italic(familyAdded, stylesAdded.at(i)))
+            return false;
+    }
+    return bold;
+}
+
 FontCustomPlatformData* createFontCustomPlatformData(SharedBuffer* buffer)
 {
     ASSERT_ARG(buffer, buffer);
+    QFontDatabase db;
+
+    // The font families in the font database, and the styles in each,
+    // before we load the new font in buffer.
+    QStringList families = db.families();
+    QMap<QString, QStringList> styles = currentStyles(families, db);
+
+    RefPtr<SharedBuffer> sfntBuffer;
+    if (isWOFF(buffer)) {
+        Vector<char> sfnt;
+        if (!convertWOFFToSfnt(buffer, sfnt))
+            return 0;
+        sfntBuffer = SharedBuffer::adoptVector(sfnt);
+        buffer = sfntBuffer.get();
+    }
 
     int id = QFontDatabase::addApplicationFontFromData(QByteArray(buffer->data(), buffer->size()));
     if (id == -1)
         return 0;
 
+    QString familyAdded = QFontDatabase::applicationFontFamilies(id)[0];
+    QStringList stylesAdded = db.styles(QFontDatabase::applicationFontFamilies(id)[0]);
+
+    // If we already had the family of which this font is a member then
+    // get the styles it added to the family
+    if (families.contains(familyAdded))
+        stylesAdded = stylesAddedByFont(familyAdded, stylesAdded, styles);
+
     Q_ASSERT(QFontDatabase::applicationFontFamilies(id).size() > 0);
 
     FontCustomPlatformData *data = new FontCustomPlatformData;
     data->m_handle = id;
+
+    // If we have created a font that only has bold or italic styles (or both)
+    // then we need to respect it's style(s) when we pass it back as
+    // FontPlatformData above.
+    data->m_italic = strictlyItalicAddedByFont(familyAdded, stylesAdded, db);
+    data->m_bold = strictlyBoldAddedByFont(familyAdded, stylesAdded, db);
     return data;
 }
 
 bool FontCustomPlatformData::supportsFormat(const String& format)
 {
-    return equalIgnoringCase(format, "truetype") || equalIgnoringCase(format, "opentype");
+    return equalIgnoringCase(format, "truetype") || equalIgnoringCase(format, "opentype") || equalIgnoringCase(format, "woff");
 }
 
 }
diff --git a/src/3rdparty/webkit/Source/WebCore/platform/graphics/qt/FontPlatformData.h b/src/3rdparty/webkit/Source/WebCore/platform/graphics/qt/FontPlatformData.h
index 88fd62737c..efa9568b00 100644
--- a/src/3rdparty/webkit/Source/WebCore/platform/graphics/qt/FontPlatformData.h
+++ b/src/3rdparty/webkit/Source/WebCore/platform/graphics/qt/FontPlatformData.h
@@ -36,6 +36,27 @@
 
 namespace WebCore {
 
+static inline QFont::Weight toQFontWeight(FontWeight fontWeight)
+{
+    switch (fontWeight) {
+    case FontWeight100:
+    case FontWeight200:
+        return QFont::Light; // QFont::Light == Weight of 25
+    case FontWeight600:
+        return QFont::DemiBold; // QFont::DemiBold == Weight of 63
+    case FontWeight700:
+    case FontWeight800:
+        return QFont::Bold; // QFont::Bold == Weight of 75
+    case FontWeight900:
+        return QFont::Black; // QFont::Black == Weight of 87
+    case FontWeight300:
+    case FontWeight400:
+    case FontWeight500:
+    default:
+        return QFont::Normal; // QFont::Normal == Weight of 50
+    }
+}
+
 class FontPlatformDataPrivate : public RefCounted<FontPlatformDataPrivate> {
     WTF_MAKE_NONCOPYABLE(FontPlatformDataPrivate); WTF_MAKE_FAST_ALLOCATED;
 public:
diff --git a/src/3rdparty/webkit/Source/WebCore/platform/graphics/qt/FontPlatformDataQt.cpp b/src/3rdparty/webkit/Source/WebCore/platform/graphics/qt/FontPlatformDataQt.cpp
index c34887007d..864bcab574 100644
--- a/src/3rdparty/webkit/Source/WebCore/platform/graphics/qt/FontPlatformDataQt.cpp
+++ b/src/3rdparty/webkit/Source/WebCore/platform/graphics/qt/FontPlatformDataQt.cpp
@@ -27,27 +27,6 @@
 
 namespace WebCore {
 
-static inline QFont::Weight toQFontWeight(FontWeight fontWeight)
-{
-    switch (fontWeight) {
-    case FontWeight100:
-    case FontWeight200:
-        return QFont::Light; // QFont::Light == Weight of 25
-    case FontWeight600:
-        return QFont::DemiBold; // QFont::DemiBold == Weight of 63
-    case FontWeight700:
-    case FontWeight800:
-        return QFont::Bold; // QFont::Bold == Weight of 75
-    case FontWeight900:
-        return QFont::Black; // QFont::Black == Weight of 87
-    case FontWeight300:
-    case FontWeight400:
-    case FontWeight500:
-    default:
-        return QFont::Normal; // QFont::Normal == Weight of 50
-    }
-}
-
 static inline bool isEmptyValue(const float size, const bool bold, const bool oblique)
 {
      // this is the empty value by definition of the trait FontDataCacheKeyTraits
@@ -73,7 +52,8 @@ FontPlatformData::FontPlatformData(const FontDescription& description, const Ato
     font.setLetterSpacing(QFont::AbsoluteSpacing, letterSpacing);
     const bool smallCaps = description.smallCaps();
     font.setCapitalization(smallCaps ? QFont::SmallCaps : QFont::MixedCase);
-    font.setStyleStrategy(QFont::ForceIntegerMetrics);
+    // Commented out to work around webkit bug 93263
+    //font.setStyleStrategy(QFont::ForceIntegerMetrics);
 
     m_data->bold = font.bold();
     // WebKit allows font size zero but QFont does not. We will return
diff --git a/src/3rdparty/webkit/Source/WebCore/platform/graphics/qt/FontQt.cpp b/src/3rdparty/webkit/Source/WebCore/platform/graphics/qt/FontQt.cpp
index c992efcefb..1f77ec4a82 100644
--- a/src/3rdparty/webkit/Source/WebCore/platform/graphics/qt/FontQt.cpp
+++ b/src/3rdparty/webkit/Source/WebCore/platform/graphics/qt/FontQt.cpp
@@ -27,6 +27,7 @@
 #include "FontDescription.h"
 #include "FontFallbackList.h"
 #include "FontSelector.h"
+#include "FontPlatformData.h"
 #if HAVE(QRAWFONT)
 #include "GlyphBuffer.h"
 #endif
@@ -471,6 +472,8 @@ void Font::drawEmphasisMarksForSimpleText(GraphicsContext* /* context */, const
 QFont Font::font() const
 {
     QFont f = primaryFont()->getQtFont();
+    f.setWeight(toQFontWeight(weight()));
+    f.setItalic(italic());
     if (m_letterSpacing != 0)
         f.setLetterSpacing(QFont::AbsoluteSpacing, m_letterSpacing);
     if (m_wordSpacing != 0)
diff --git a/src/3rdparty/webkit/Source/WebCore/platform/graphics/qt/ImageQt.cpp b/src/3rdparty/webkit/Source/WebCore/platform/graphics/qt/ImageQt.cpp
index 0c8ce9ed7b..5ba54d0ddf 100644
--- a/src/3rdparty/webkit/Source/WebCore/platform/graphics/qt/ImageQt.cpp
+++ b/src/3rdparty/webkit/Source/WebCore/platform/graphics/qt/ImageQt.cpp
@@ -41,6 +41,7 @@
 #include "PlatformString.h"
 #include "StillImageQt.h"
 #include "qwebsettings.h"
+#include "SharedBuffer.h"
 
 #include <QPixmap>
 #include <QPainter>
@@ -234,7 +235,8 @@ void BitmapImage::draw(GraphicsContext* ctxt, const FloatRect& dst,
         }
     }
 
-    ctxt->platformContext()->drawPixmap(normalizedDst, *image, normalizedSrc);
+    QByteArray a = QByteArray::fromRawData(data()->data(), data()->size());
+    ctxt->platformContext()->drawPixmap(normalizedDst, *image, normalizedSrc, &a);
 
     ctxt->setCompositeOperation(previousOperator);
 
diff --git a/src/3rdparty/webkit/Source/WebCore/platform/qt/PlatformScreenQt.cpp b/src/3rdparty/webkit/Source/WebCore/platform/qt/PlatformScreenQt.cpp
index 4db8bd1aa6..a6fc61c36e 100644
--- a/src/3rdparty/webkit/Source/WebCore/platform/qt/PlatformScreenQt.cpp
+++ b/src/3rdparty/webkit/Source/WebCore/platform/qt/PlatformScreenQt.cpp
@@ -39,9 +39,34 @@
 #include "QWebPageClient.h"
 #include <QApplication>
 #include <QDesktopWidget>
+#include <QByteArray>
 
 namespace WebCore {
 
+static int wkhtmltox_screen_width()
+{
+    QByteArray override = qgetenv("WKHTMLTOX_SCREEN_WIDTH");
+
+    bool ok;
+    int width = override.toInt(&ok);
+    if (ok)
+        return qMax(320, qMin(7680, width));
+
+    return 1366; // default screen width
+}
+
+static int wkhtmltox_screen_height()
+{
+    QByteArray override = qgetenv("WKHTMLTOX_SCREEN_HEIGHT");
+
+    bool ok;
+    int height = override.toInt(&ok);
+    if (ok)
+        return qMax(240, qMin(4320, height));
+
+    return 768; // default screen height
+}
+
 static int screenNumber(Widget* w)
 {
     if (!w)
@@ -53,11 +78,17 @@ static int screenNumber(Widget* w)
 
 int screenDepth(Widget* w)
 {
+    if (QApplication::type() == QApplication::Tty)
+        return 32;
+
     return QApplication::desktop()->screen(screenNumber(w))->depth();
 }
 
 int screenDepthPerComponent(Widget* w)
 {
+    if (QApplication::type() == QApplication::Tty)
+        return 8;
+
     int depth = QApplication::desktop()->screen(0)->depth();
     if (w) {
         QWebPageClient* client = w->root()->hostWindow()->platformPageClient();
@@ -86,17 +117,26 @@ int screenDepthPerComponent(Widget* w)
 
 bool screenIsMonochrome(Widget* w)
 {
+    if (QApplication::type() == QApplication::Tty)
+        return false;
+
     return QApplication::desktop()->screen(screenNumber(w))->colorCount() == 2;
 }
 
 FloatRect screenRect(Widget* w)
 {
+    if (QApplication::type() == QApplication::Tty)
+        return FloatRect(0,0,wkhtmltox_screen_width(),wkhtmltox_screen_height());
+
     QRect r = QApplication::desktop()->screenGeometry(screenNumber(w));
     return FloatRect(r.x(), r.y(), r.width(), r.height());
 }
 
 FloatRect screenAvailableRect(Widget* w)
 {
+    if (QApplication::type() == QApplication::Tty)
+        return FloatRect(0,0,wkhtmltox_screen_width(),wkhtmltox_screen_height());
+
     QRect r = QApplication::desktop()->availableGeometry(screenNumber(w));
     return FloatRect(r.x(), r.y(), r.width(), r.height());
 }
diff --git a/src/3rdparty/webkit/Source/WebCore/platform/qt/RenderThemeQt.cpp b/src/3rdparty/webkit/Source/WebCore/platform/qt/RenderThemeQt.cpp
index f98df886ba..b1fe30d0be 100644
--- a/src/3rdparty/webkit/Source/WebCore/platform/qt/RenderThemeQt.cpp
+++ b/src/3rdparty/webkit/Source/WebCore/platform/qt/RenderThemeQt.cpp
@@ -178,7 +178,13 @@ RenderThemeQt::RenderThemeQt(Page* page)
     : RenderTheme()
     , m_page(page)
     , m_lineEdit(0)
+    , m_fallbackStyle(0)
 {
+    if (QApplication::type() == QApplication::Tty) {
+        m_buttonFontFamily = "sans-serif";
+        return;
+    }
+
     QPushButton button;
     button.setAttribute(Qt::WA_MacSmallSize);
     QFont defaultButtonFont = QApplication::font(&button);
@@ -339,6 +345,9 @@ bool RenderThemeQt::supportsControlTints() const
 
 int RenderThemeQt::findFrameLineWidth(QStyle* style) const
 {
+    if (QApplication::type()==QApplication::Tty)
+        return 1;
+
 #ifndef QT_NO_LINEEDIT
     if (!m_lineEdit)
         m_lineEdit = new QLineEdit();
@@ -445,6 +454,9 @@ Color RenderThemeQt::systemColor(int cssValueId) const
 
 int RenderThemeQt::minimumMenuListSize(RenderStyle*) const
 {
+    if (QApplication::type() == QApplication::Tty)
+        return 1;
+
     const QFontMetrics &fm = QApplication::fontMetrics();
     return fm.width(QLatin1Char('x'));
 }
diff --git a/src/3rdparty/webkit/Source/WebCore/platform/qt/ScreenQt.cpp b/src/3rdparty/webkit/Source/WebCore/platform/qt/ScreenQt.cpp
index d648c5315f..8ec41a0d2c 100644
--- a/src/3rdparty/webkit/Source/WebCore/platform/qt/ScreenQt.cpp
+++ b/src/3rdparty/webkit/Source/WebCore/platform/qt/ScreenQt.cpp
@@ -38,9 +38,36 @@
 
 #include <QApplication>
 #include <QDesktopWidget>
+#include <QByteArray>
 
 namespace WebCore {
 
+static int wkhtmltox_screen_width()
+{
+    QByteArray override = qgetenv("WKHTMLTOX_SCREEN_WIDTH");
+
+    bool ok;
+    int width = override.toInt(&ok);
+    if (ok)
+        return qMax(320, qMin(7680, width));
+
+    return 1366; // default screen width
+}
+
+static int wkhtmltox_screen_height()
+{
+    QByteArray override = qgetenv("WKHTMLTOX_SCREEN_HEIGHT");
+
+    bool ok;
+    int height = override.toInt(&ok);
+    if (ok)
+        return qMax(240, qMin(4320, height));
+
+    return 768; // default screen width
+}
+
+
+
 static QWidget* qwidgetForPage(const Page* page)
 {
     Frame* frame = (page ? page->mainFrame() : 0);
@@ -54,6 +81,9 @@ static QWidget* qwidgetForPage(const Page* page)
 
 FloatRect screenRect(const Page* page)
 {
+    if (QApplication::type() == QApplication::Tty)
+        return FloatRect(0,0,wkhtmltox_screen_width(),wkhtmltox_screen_height());
+
     QWidget* qw = qwidgetForPage(page);
     if (!qw)
         return FloatRect();
@@ -68,6 +98,9 @@ FloatRect screenRect(const Page* page)
 
 int screenDepth(const Page* page)
 {
+    if (QApplication::type() == QApplication::Tty)
+        return 32;
+
     QWidget* qw = qwidgetForPage(page);
     if (!qw)
         return 32;
@@ -77,6 +110,9 @@ int screenDepth(const Page* page)
 
 FloatRect usableScreenRect(const Page* page)
 {
+    if (QApplication::type() == QApplication::Tty)
+        return FloatRect();
+
     QWidget* qw = qwidgetForPage(page);
     if (!qw)
         return FloatRect();
diff --git a/src/3rdparty/webkit/Source/WebCore/platform/qt/WidgetQt.cpp b/src/3rdparty/webkit/Source/WebCore/platform/qt/WidgetQt.cpp
index 5215e66611..e0332795ca 100644
--- a/src/3rdparty/webkit/Source/WebCore/platform/qt/WidgetQt.cpp
+++ b/src/3rdparty/webkit/Source/WebCore/platform/qt/WidgetQt.cpp
@@ -41,6 +41,7 @@
 #include "QWebPageClient.h"
 #include "ScrollView.h"
 
+#include <QApplication>
 #include <QCoreApplication>
 #include <QDebug>
 #include <QPaintEngine>
@@ -78,6 +79,9 @@ void Widget::setFocus(bool focused)
 void Widget::setCursor(const Cursor& cursor)
 {
 #ifndef QT_NO_CURSOR
+    if (QApplication::type() == QApplication::Tty)
+        return;
+
     ScrollView* view = root();
     if (!view)
         return;
diff --git a/src/3rdparty/webkit/Source/WebCore/rendering/InlineFlowBox.h b/src/3rdparty/webkit/Source/WebCore/rendering/InlineFlowBox.h
index 236371ac93..ca52cbcfd4 100644
--- a/src/3rdparty/webkit/Source/WebCore/rendering/InlineFlowBox.h
+++ b/src/3rdparty/webkit/Source/WebCore/rendering/InlineFlowBox.h
@@ -46,6 +46,7 @@ public:
         , m_includeLogicalLeftEdge(false)
         , m_includeLogicalRightEdge(false)
         , m_descendantsHaveSameLineHeightAndBaseline(true)
+        , m_isFirstAfterPageBreak(false)
 #ifndef NDEBUG
         , m_hasBadChildList(false)
 #endif
@@ -293,6 +294,7 @@ protected:
     bool m_hasTextChildren : 1;
     bool m_hasTextDescendants : 1;
     bool m_descendantsHaveSameLineHeightAndBaseline : 1;
+    bool m_isFirstAfterPageBreak : 1;
 
 #ifndef NDEBUG
     bool m_hasBadChildList;
diff --git a/src/3rdparty/webkit/Source/WebCore/rendering/RenderBlock.cpp b/src/3rdparty/webkit/Source/WebCore/rendering/RenderBlock.cpp
index 4ad1bfe8cd..5fd713c813 100644
--- a/src/3rdparty/webkit/Source/WebCore/rendering/RenderBlock.cpp
+++ b/src/3rdparty/webkit/Source/WebCore/rendering/RenderBlock.cpp
@@ -2048,7 +2048,7 @@ void RenderBlock::layoutBlockChild(RenderBox* child, MarginInfo& marginInfo, int
     setLogicalTopForChild(child, logicalTopAfterClear, ApplyLayoutDelta);
 
     // Now we have a final top position.  See if it really does end up being different from our estimate.
-    if (logicalTopAfterClear != logicalTopEstimate) {
+    if (logicalTopAfterClear != logicalTopEstimate || (paginated && childRenderBlock && childRenderBlock->shouldBreakAtLineToAvoidWidow())) {
         if (child->shrinkToAvoidFloats()) {
             // The child's width depends on the line width.
             // When the child shifts to clear an item, its width can
@@ -2235,7 +2235,7 @@ void RenderBlock::markForPaginationRelayoutIfNeeded()
     if (needsLayout())
         return;
 
-    if (view()->layoutState()->pageLogicalHeightChanged() || (view()->layoutState()->pageLogicalHeight() && view()->layoutState()->pageLogicalOffset(logicalTop()) != pageLogicalOffset()))
+    if (view()->layoutState()->pageLogicalHeightChanged() || (view()->layoutState()->pageLogicalHeight() && view()->layoutState()->pageLogicalOffset(logicalTop()) != pageLogicalOffset()) || shouldBreakAtLineToAvoidWidow())
         setChildNeedsLayout(true, false);
 }
 
@@ -3234,6 +3234,8 @@ void RenderBlock::removeFloatingObjectsBelow(FloatingObject* lastFloat, int logi
         floatingObjectSet.removeLast();
         ASSERT(!curr->m_originatingLine);
         delete curr;
+        if (floatingObjectSet.isEmpty())
+            break;
         curr = floatingObjectSet.last();
     }
 }
@@ -4156,6 +4158,10 @@ VisiblePosition RenderBlock::positionForPointWithInlineChildren(const IntPoint&
             continue;
         if (!firstRootBoxWithChildren)
             firstRootBoxWithChildren = root;
+
+        if (root->isFirstAfterPageBreak() && pointInLogicalContents.y() < root->logicalTop())
+            break;
+
         lastRootBoxWithChildren = root;
 
         // check if this root line box is located at this y coordinate
@@ -5717,6 +5723,23 @@ void RenderBlock::setPageLogicalOffset(int logicalOffset)
     m_rareData->m_pageLogicalOffset = logicalOffset;
 }
 
+void RenderBlock::setBreakAtLineToAvoidWidow(RootInlineBox* lineToBreak)
+{
+    ASSERT(lineToBreak);
+    if (!m_rareData)
+        m_rareData = adoptPtr(new RenderBlockRareData(this));
+    m_rareData->m_shouldBreakAtLineToAvoidWidow = true;
+    m_rareData->m_lineBreakToAvoidWidow = lineToBreak;
+}
+
+void RenderBlock::clearShouldBreakAtLineToAvoidWidow() const
+{
+    if (!m_rareData)
+        return;
+    m_rareData->m_shouldBreakAtLineToAvoidWidow = false;
+    m_rareData->m_lineBreakToAvoidWidow = 0;
+}
+
 void RenderBlock::absoluteRects(Vector<IntRect>& rects, int tx, int ty)
 {
     // For blocks inside inlines, we go ahead and include margins so that we run right up to the
@@ -6045,7 +6068,8 @@ int RenderBlock::applyAfterBreak(RenderBox* child, int logicalOffset, MarginInfo
 
 int RenderBlock::adjustForUnsplittableChild(RenderBox* child, int logicalOffset, bool includeMargins)
 {
-    bool isUnsplittable = child->isReplaced() || child->scrollsOverflow();
+    bool isUnsplittable = child->isReplaced() || child->scrollsOverflow() ||
+                          child->style()->pageBreakInside() == PBAVOID;
     if (!isUnsplittable)
         return logicalOffset;
     int childLogicalHeight = logicalHeightForChild(child) + (includeMargins ? marginBeforeForChild(child) + marginAfterForChild(child) : 0);
@@ -6090,20 +6114,26 @@ void RenderBlock::adjustLinePositionForPagination(RootInlineBox* lineBox, int& d
         layoutState->m_columnInfo->updateMinimumColumnHeight(lineHeight);
     logicalOffset += delta;
     lineBox->setPaginationStrut(0);
+    lineBox->setIsFirstAfterPageBreak(false);
     if (!pageLogicalHeight || lineHeight > pageLogicalHeight)
         return;
     IntSize offsetDelta = layoutState->m_layoutOffset - layoutState->m_pageOffset;
     int offset = isHorizontalWritingMode() ? offsetDelta.height() : offsetDelta.width();
     int remainingLogicalHeight = pageLogicalHeight - (offset + logicalOffset) % pageLogicalHeight;
-    if (remainingLogicalHeight < lineHeight) {
+    if (remainingLogicalHeight < lineHeight || (shouldBreakAtLineToAvoidWidow() && lineBreakToAvoidWidow() == lineBox)) {
+        if (shouldBreakAtLineToAvoidWidow() && lineBreakToAvoidWidow() == lineBox)
+            clearShouldBreakAtLineToAvoidWidow();
         int totalLogicalHeight = lineHeight + max(0, logicalOffset);
-        if (lineBox == firstRootBox() && totalLogicalHeight < pageLogicalHeight && !isPositioned() && !isTableCell())
+        if (((lineBox == firstRootBox() && totalLogicalHeight < pageLogicalHeight) || (!style()->hasAutoOrphans() && style()->orphans() >= lineCount()))
+            && !isPositioned() && !isTableCell())
             setPaginationStrut(remainingLogicalHeight + max(0, logicalOffset));
         else {
             delta += remainingLogicalHeight;
             lineBox->setPaginationStrut(remainingLogicalHeight);
+            lineBox->setIsFirstAfterPageBreak(true);
         }
-    }  
+    } else if (remainingLogicalHeight == pageLogicalHeight && lineBox != firstRootBox())
+        lineBox->setIsFirstAfterPageBreak(true);
 }
 
 int RenderBlock::collapsedMarginBeforeForChild(RenderBox* child) const
diff --git a/src/3rdparty/webkit/Source/WebCore/rendering/RenderBlock.h b/src/3rdparty/webkit/Source/WebCore/rendering/RenderBlock.h
index 6e420ca023..28c333235b 100644
--- a/src/3rdparty/webkit/Source/WebCore/rendering/RenderBlock.h
+++ b/src/3rdparty/webkit/Source/WebCore/rendering/RenderBlock.h
@@ -169,7 +169,12 @@ public:
 
     int paginationStrut() const { return m_rareData ? m_rareData->m_paginationStrut : 0; }
     void setPaginationStrut(int);
-    
+
+    bool shouldBreakAtLineToAvoidWidow() const { return m_rareData && m_rareData->m_shouldBreakAtLineToAvoidWidow; }
+    void clearShouldBreakAtLineToAvoidWidow() const;
+    RootInlineBox* lineBreakToAvoidWidow() const { return m_rareData ? m_rareData->m_lineBreakToAvoidWidow : 0; }
+    void setBreakAtLineToAvoidWidow(RootInlineBox*);
+
     // The page logical offset is the object's offset from the top of the page in the page progression
     // direction (so an x-offset in vertical text and a y-offset for horizontal text).
     int pageLogicalOffset() const { return m_rareData ? m_rareData->m_pageLogicalOffset : 0; }
@@ -785,6 +790,8 @@ private:
             : m_margins(positiveMarginBeforeDefault(block), negativeMarginBeforeDefault(block), positiveMarginAfterDefault(block), negativeMarginAfterDefault(block))
             , m_paginationStrut(0)
             , m_pageLogicalOffset(0)
+            , m_shouldBreakAtLineToAvoidWidow(false)
+            , m_lineBreakToAvoidWidow(0)
         { 
         }
 
@@ -809,6 +816,9 @@ private:
         MarginValues m_margins;
         int m_paginationStrut;
         int m_pageLogicalOffset;
+
+        bool m_shouldBreakAtLineToAvoidWidow;
+        RootInlineBox* m_lineBreakToAvoidWidow;
      };
 
     OwnPtr<RenderBlockRareData> m_rareData;
diff --git a/src/3rdparty/webkit/Source/WebCore/rendering/RenderBlockLineLayout.cpp b/src/3rdparty/webkit/Source/WebCore/rendering/RenderBlockLineLayout.cpp
index 2e928018c7..974773cc8b 100644
--- a/src/3rdparty/webkit/Source/WebCore/rendering/RenderBlockLineLayout.cpp
+++ b/src/3rdparty/webkit/Source/WebCore/rendering/RenderBlockLineLayout.cpp
@@ -34,6 +34,7 @@
 #include "RenderListMarker.h"
 #include "RenderRubyRun.h"
 #include "RenderView.h"
+#include "RenderTableRow.h"
 #include "Settings.h"
 #include "TextBreakIterator.h"
 #include "TextRun.h"
@@ -816,6 +817,15 @@ RootInlineBox* RenderBlock::createLineBoxesFromBidiRuns(BidiRunList<BidiRun>& bi
     return lineBox;
 }
 
+static inline bool isTableCellWithPageBreakInsideAvoid(RenderBlock *block)
+{
+    if (!block->isTableCell())
+        return false;
+
+    RenderTableRow *row = toRenderTableRow(block->parent());
+    return row && row->style()->pageBreakInside() == PBAVOID;
+}
+
 void RenderBlock::layoutRunsAndFloats(bool fullLayout, bool hasInlineChild, Vector<FloatWithRect>& floats, int& repaintLogicalTop, int& repaintLogicalBottom)
 {
     // We want to skip ahead to the first dirty line
@@ -956,7 +966,8 @@ void RenderBlock::layoutRunsAndFloats(bool fullLayout, bool hasInlineChild, Vect
                     repaintLogicalBottom = max(repaintLogicalBottom, lineBox->logicalBottomVisualOverflow());
                 }
 
-                if (paginated) {
+                // table cell pagination in case of page-break-inside: avoid is handled in RenderTableSection
+                if (paginated && !isTableCellWithPageBreakInsideAvoid(this)) {
                     int adjustment = 0;
                     adjustLinePositionForPagination(lineBox, adjustment);
                     if (adjustment) {
@@ -1013,6 +1024,63 @@ void RenderBlock::layoutRunsAndFloats(bool fullLayout, bool hasInlineChild, Vect
         resolver.setPosition(end);
     }
 
+    if (paginated && !style()->hasAutoWidows()) {
+        // Check the line boxes to make sure we didn't create unacceptable widows.
+        // However, we'll prioritize orphans - so nothing we do here should create
+        // a new orphan.
+
+        RootInlineBox* lineBox = lastRootBox();
+
+        // Count from the end of the block backwards, to see how many hanging
+        // lines we have.
+        RootInlineBox* firstLineInBlock = firstRootBox();
+        int numLinesHanging = 1;
+        while (lineBox && lineBox != firstLineInBlock && !lineBox->isFirstAfterPageBreak()) {
+            ++numLinesHanging;
+            lineBox = lineBox->prevRootBox();
+        }
+
+        // If there were no breaks in the block, we didn't create any widows.
+        if (!lineBox || !lineBox->isFirstAfterPageBreak() || lineBox == firstLineInBlock)
+            return;
+
+        if (numLinesHanging < style()->widows()) {
+            // We have detected a widow. Now we need to work out how many
+            // lines there are on the previous page, and how many we need
+            // to steal.
+            int numLinesNeeded = style()->widows() - numLinesHanging;
+            RootInlineBox* currentFirstLineOfNewPage = lineBox;
+
+            // Count the number of lines in the previous page.
+            lineBox = lineBox->prevRootBox();
+            int numLinesInPreviousPage = 1;
+            while (lineBox && lineBox != firstLineInBlock && !lineBox->isFirstAfterPageBreak()) {
+                ++numLinesInPreviousPage;
+                lineBox = lineBox->prevRootBox();
+            }
+
+            // If there was an explicit value for orphans, respect that. If not, we still
+            // shouldn't create a situation where we make an orphan bigger than the initial value.
+            // This means that setting widows implies we also care about orphans, but given
+            // the specification says the initial orphan value is non-zero, this is ok. The
+            // author is always free to set orphans explicitly as well.
+            int orphans = style()->hasAutoOrphans() ? style()->initialOrphans() : style()->orphans();
+            int numLinesAvailable = numLinesInPreviousPage - orphans;
+            if (numLinesAvailable <= 0)
+                return;
+
+            int numLinesToTake = min(numLinesAvailable, numLinesNeeded);
+            // Wind back from our first widowed line.
+            lineBox = currentFirstLineOfNewPage;
+            for (int i = 0; i < numLinesToTake; ++i)
+                lineBox = lineBox->prevRootBox();
+
+            // We now want to break at this line. Remember for next layout and trigger relayout.
+            setBreakAtLineToAvoidWidow(lineBox);
+            markLinesDirtyInBlockRange(lastRootBox()->lineBottom(), lineBox->lineBottom(), lineBox);
+        }
+    }
+
     if (endLine) {
         if (endLineMatched) {
             // Attach all the remaining lines, and then adjust their y-positions as needed.
diff --git a/src/3rdparty/webkit/Source/WebCore/rendering/RenderTable.cpp b/src/3rdparty/webkit/Source/WebCore/rendering/RenderTable.cpp
index 73b08015e1..a439f6263a 100644
--- a/src/3rdparty/webkit/Source/WebCore/rendering/RenderTable.cpp
+++ b/src/3rdparty/webkit/Source/WebCore/rendering/RenderTable.cpp
@@ -37,6 +37,7 @@
 #include "RenderLayer.h"
 #include "RenderTableCell.h"
 #include "RenderTableCol.h"
+#include "RenderTableRow.h"
 #include "RenderTableSection.h"
 #include "RenderView.h"
 
@@ -63,7 +64,7 @@ RenderTable::RenderTable(Node* node)
     setChildrenInline(false);
     m_columnPos.fill(0, 2);
     m_columns.fill(ColumnStruct(), 1);
-    
+
 }
 
 RenderTable::~RenderTable()
@@ -138,7 +139,7 @@ void RenderTable::addChild(RenderObject* child, RenderObject* beforeChild)
                     m_head = toRenderTableSection(child);
                 } else {
                     resetSectionPointerIfNotBefore(m_firstBody, beforeChild);
-                    if (!m_firstBody) 
+                    if (!m_firstBody)
                         m_firstBody = toRenderTableSection(child);
                 }
                 wrapInAnonymousSection = false;
@@ -203,7 +204,7 @@ void RenderTable::addChild(RenderObject* child, RenderObject* beforeChild)
 void RenderTable::removeChild(RenderObject* oldChild)
 {
     RenderBox::removeChild(oldChild);
-    
+
     if (m_caption && oldChild == m_caption && node())
         node()->setNeedsStyleRecalc();
     setNeedsSectionRecalc();
@@ -232,10 +233,10 @@ void RenderTable::computeLogicalWidth()
             marginTotal += style()->marginStart().calcValue(availableLogicalWidth);
         if (!style()->marginEnd().isAuto())
             marginTotal += style()->marginEnd().calcValue(availableLogicalWidth);
-            
+
         // Subtract out our margins to get the available content width.
         int availableContentLogicalWidth = max(0, containerWidthInInlineDirection - marginTotal);
-        
+
         // Ensure we aren't bigger than our max width or smaller than our min width.
         setLogicalWidth(min(availableContentLogicalWidth, maxPreferredLogicalWidth()));
     }
@@ -273,7 +274,7 @@ void RenderTable::layout()
         return;
 
     recalcSectionsIfNeeded();
-        
+
     LayoutRepainter repainter(*this, checkForRepaintDuringLayout());
     LayoutStateMaintainer statePusher(view(), this, IntSize(x(), y()), style()->isFlippedBlocksWritingMode());
 
@@ -281,7 +282,7 @@ void RenderTable::layout()
     m_overflow.clear();
 
     initMaxMarginValues();
-    
+
     int oldLogicalWidth = logicalWidth();
     computeLogicalWidth();
 
@@ -302,11 +303,20 @@ void RenderTable::layout()
 
     bool collapsing = collapseBorders();
 
+    // repeat header and footer on each page
+    int headHeight = 0;
+    int footHeight = 0;
     for (RenderObject* child = firstChild(); child; child = child->nextSibling()) {
         if (child->isTableSection()) {
             child->layoutIfNeeded();
             RenderTableSection* section = toRenderTableSection(child);
-            totalSectionLogicalHeight += section->calcRowLogicalHeight();
+            int rowHeight = section->calcRowLogicalHeight();
+            if (child == m_head) {
+                headHeight = rowHeight;
+            } else if (child == m_foot) {
+                footHeight = rowHeight;
+            }
+            totalSectionLogicalHeight += rowHeight;
             if (collapsing)
                 section->recalcOuterBorder();
             ASSERT(!section->needsLayout());
@@ -320,6 +330,34 @@ void RenderTable::layout()
     if (m_caption)
         m_caption->layoutIfNeeded();
 
+    // Bump table to next page if we can't fit the caption, thead and first body cell if first row has page-break-inside: avoid
+    setPaginationStrut(0);
+    if (view()->layoutState()->pageLogicalHeight()) {
+        LayoutState* layoutState = view()->layoutState();
+        const int pageLogicalHeight = layoutState->m_pageLogicalHeight;
+        const int remainingLogicalHeight = pageLogicalHeight - layoutState->pageLogicalOffset(0) % pageLogicalHeight;
+        if (remainingLogicalHeight > 0) {
+            int requiredHeight = headHeight;
+            if (m_caption && m_caption->style()->captionSide() != CAPBOTTOM) {
+                requiredHeight += m_caption->logicalHeight() + m_caption->marginBefore() + m_caption->marginAfter();
+            }
+            if (m_firstBody) {
+                // FIXME: Calculate maximum required height across all cells in first body row
+                if (m_firstBody->numRows() > 0 && m_firstBody->numColumns() > 0) {
+                    RenderTableCell* firstCell = m_firstBody->primaryCellAt(0, 0);
+                    if (firstCell) {
+                        RenderTableRow *firstRow = toRenderTableRow(firstCell->parent());
+                        if (firstRow && firstRow->style()->pageBreakInside() == PBAVOID)
+                            requiredHeight += firstCell->contentLogicalHeight() + firstCell->paddingTop(false) + firstCell->paddingBottom(false) + vBorderSpacing();
+                    }
+                }
+            }
+            if (requiredHeight > remainingLogicalHeight && requiredHeight < pageLogicalHeight) {
+                setPaginationStrut(remainingLogicalHeight);
+            }
+        }
+    }
+
     // If any table section moved vertically, we will just repaint everything from that
     // section down (it is quite unlikely that any of the following sections
     // did not shift).
@@ -352,12 +390,6 @@ void RenderTable::layout()
         computedLogicalHeight = computePercentageLogicalHeight(logicalHeightLength);
     computedLogicalHeight = max(0, computedLogicalHeight);
 
-    for (RenderObject* child = firstChild(); child; child = child->nextSibling()) {
-        if (child->isTableSection())
-            // FIXME: Distribute extra height between all table body sections instead of giving it all to the first one.
-            toRenderTableSection(child)->layoutRows(child == m_firstBody ? max(0, computedLogicalHeight - totalSectionLogicalHeight) : 0);
-    }
-
     if (!m_firstBody && computedLogicalHeight > totalSectionLogicalHeight && !document()->inQuirksMode()) {
         // Completely empty tables (with no sections or anything) should at least honor specified height
         // in strict mode.
@@ -377,6 +409,9 @@ void RenderTable::layout()
         }
         section->setLogicalLocation(sectionLogicalLeft, logicalHeight());
 
+        // FIXME: Distribute extra height between all table body sections instead of giving it all to the first one.
+        section->layoutRows(section == m_firstBody ? max(0, computedLogicalHeight - totalSectionLogicalHeight) : 0, section == m_head ? 0 : headHeight, section == m_foot ? 0 : footHeight);
+
         setLogicalHeight(logicalHeight() + section->logicalHeight());
         section = sectionBelow(section);
     }
@@ -468,7 +503,7 @@ void RenderTable::paint(PaintInfo& paintInfo, int tx, int ty)
             return;
     }
 
-    bool pushedClip = pushContentsClip(paintInfo, tx, ty);    
+    bool pushedClip = pushContentsClip(paintInfo, tx, ty);
     paintObject(paintInfo, tx, ty);
     if (pushedClip)
         popContentsClip(paintInfo, paintPhase, tx, ty);
@@ -488,7 +523,7 @@ void RenderTable::paintObject(PaintInfo& paintInfo, int tx, int ty)
     // We're done.  We don't bother painting any children.
     if (paintPhase == PaintPhaseBlockBackground)
         return;
-    
+
     // We don't paint our own background, but we do let the kids paint their backgrounds.
     if (paintPhase == PaintPhaseChildBlockBackgrounds)
         paintPhase = PaintPhaseChildBlockBackground;
@@ -503,7 +538,92 @@ void RenderTable::paintObject(PaintInfo& paintInfo, int tx, int ty)
             child->paint(info, childPoint.x(), childPoint.y());
         }
     }
-    
+
+    bool repaintedHead = false;
+    IntPoint repaintedHeadPoint;
+    bool repaintedFoot = false;
+    IntPoint repaintedFootPoint;
+    if (view()->pageLogicalHeight()) {
+        // re-paint header/footer if table is split over multiple pages
+        if (m_head) {
+            IntPoint childPoint = flipForWritingMode(m_head, IntPoint(tx, ty), ParentToChildFlippingAdjustment);
+            if (info.rect.y() > childPoint.y() + m_head->y()) {
+                repaintedHeadPoint = IntPoint(childPoint.x(), info.rect.y() - m_head->y());
+                repaintedHead = true;
+
+                RenderObject* headObj = dynamic_cast<RenderObject*>(m_head);
+                headObj->paint(info, repaintedHeadPoint.x(), repaintedHeadPoint.y());
+
+                RenderLayer* myLayer  = headObj->enclosingLayer();
+                if(myLayer){
+                    for (RenderObject* row = dynamic_cast<RenderObject*>(m_head)->firstChild(); row; row = row->nextSibling()) {
+                        if (row->isTableRow()) {
+                            for (RenderObject* cell = row->firstChild(); cell; cell = cell->nextSibling()) {
+                                if (cell->isTableCell()) {
+                                    for (RenderObject* contentObj = cell->firstChild(); contentObj; contentObj = contentObj->nextSibling()) {
+                                        if (contentObj->isBox()){
+
+                                            RenderLayer* currInnerLayer = contentObj->enclosingLayer();
+
+                                            if(currInnerLayer){
+                                                RenderBox* currContentBox = toRenderBox(contentObj);
+                                                RenderBox* currRowBox = toRenderBox(row);
+
+                                                int origY = currContentBox->y();
+                                                int newY = (repaintedHeadPoint.y()-ty)+(currRowBox->height()-currContentBox->height());
+
+                                                currContentBox->setY(newY);
+                                                currInnerLayer->updateLayerPosition();
+                                                myLayer->repaintIncludingDescendants();
+                                                currContentBox->setY(origY);
+                                            }
+                                        }
+                                    }
+                                }
+                            }
+                        }
+                    }
+                }
+            }
+        }
+        if (m_foot) {
+            IntPoint childPoint = flipForWritingMode(m_foot, IntPoint(tx, ty), ParentToChildFlippingAdjustment);
+            if (info.rect.y() + info.rect.height() < childPoint.y() + m_foot->y()) {
+                // find actual end of table on current page
+                int dy = 0;
+                const int max_dy = info.rect.y() + info.rect.height();
+                const int vspace = vBorderSpacing();
+                for (RenderObject* section = firstChild(); section; section = section->nextSibling()) {
+                    if (section->isTableSection()) {
+                        if (toRenderBox(section)->y() > max_dy) {
+                            continue;
+                        }
+                        int i = 0;
+                        for(RenderObject* row = section->firstChild(); row; row = row->nextSibling()) {
+                            if (!row->isTableRow()) {
+                                continue;
+                            }
+                            // get actual bottom-y position of this row - pretty complicated, how could this be simplified?
+                            // note how we have to take the rowPoint and section's y-offset into account, see e.g.
+                            // RenderTableSection::paint where this is also done...
+                            IntPoint rowPoint = flipForWritingMode(toRenderBox(row), IntPoint(tx, ty), ParentToChildFlippingAdjustment);
+                            int row_dy = rowPoint.y() + toRenderBox(row)->y() + toRenderBox(row)->logicalHeight() + toRenderBox(section)->y();
+                            if (row_dy < max_dy && row_dy > dy) {
+                                dy = row_dy;
+                            } else if (row_dy > max_dy) {
+                                break;
+                            }
+                            i++;
+                        }
+                    }
+                }
+                repaintedFoot = true;
+                repaintedFootPoint = IntPoint(childPoint.x(), dy - m_foot->y());
+                dynamic_cast<RenderObject*>(m_foot)->paint(info, repaintedFootPoint.x(), repaintedFootPoint.y());
+            }
+        }
+    }
+
     if (collapseBorders() && paintPhase == PaintPhaseChildBlockBackground && style()->visibility() == VISIBLE) {
         // Collect all the unique border styles that we want to paint in a sorted list.  Once we
         // have all the styles sorted, we then do individual passes, painting each style of border
@@ -522,6 +642,12 @@ void RenderTable::paintObject(PaintInfo& paintInfo, int tx, int ty)
             for (RenderObject* child = firstChild(); child; child = child->nextSibling())
                 if (child->isTableSection()) {
                     IntPoint childPoint = flipForWritingMode(toRenderTableSection(child), IntPoint(tx, ty), ParentToChildFlippingAdjustment);
+                    // also repaint borders of header/footer if required
+                    if (child == m_head && repaintedHead) {
+                        childPoint = repaintedHeadPoint;
+                    } else if (child == m_foot && repaintedFoot) {
+                        childPoint = repaintedFootPoint;
+                    }
                     child->paint(info, childPoint.x(), childPoint.y());
                 }
         }
@@ -560,7 +686,7 @@ void RenderTable::paintBoxDecorations(PaintInfo& paintInfo, int tx, int ty)
     subtractCaptionRect(rect);
 
     paintBoxShadow(paintInfo.context, rect.x(), rect.y(), rect.width(), rect.height(), style(), Normal);
-    
+
     if (isRoot())
         paintRootBoxFillLayers(paintInfo);
     else if (!isBody() || document()->documentElement()->renderer()->hasBackground())
@@ -654,7 +780,7 @@ RenderTableCol* RenderTable::nextColElement(RenderTableCol* current) const
             return 0;
         next = next->nextSibling();
     }
-    
+
     return 0;
 }
 
@@ -775,7 +901,7 @@ void RenderTable::recalcSections() const
                 maxCols = sectionCols;
         }
     }
-    
+
     m_columns.resize(maxCols);
     m_columnPos.resize(maxCols + 1);
 
@@ -806,11 +932,11 @@ int RenderTable::calcBorderStart() const
             if (gb.style() > BHIDDEN)
                 borderWidth = max(borderWidth, static_cast<unsigned>(gb.width()));
         }
-        
+
         RenderTableSection* firstNonEmptySection = m_head ? m_head : (m_firstBody ? m_firstBody : m_foot);
         if (firstNonEmptySection && !firstNonEmptySection->numRows())
             firstNonEmptySection = sectionBelow(firstNonEmptySection, true);
-        
+
         if (firstNonEmptySection) {
             const BorderValue& sb = firstNonEmptySection->style()->borderStart();
             if (sb.style() == BHIDDEN)
@@ -820,7 +946,7 @@ int RenderTable::calcBorderStart() const
                 borderWidth = max(borderWidth, static_cast<unsigned>(sb.width()));
 
             const RenderTableSection::CellStruct& cs = firstNonEmptySection->cellAt(0, 0);
-            
+
             if (cs.hasCells()) {
                 const BorderValue& cb = cs.primaryCell()->style()->borderStart(); // FIXME: Make this work with perpendicualr and flipped cells.
                 if (cb.style() == BHIDDEN)
@@ -864,11 +990,11 @@ int RenderTable::calcBorderEnd() const
             if (gb.style() > BHIDDEN)
                 borderWidth = max(borderWidth, static_cast<unsigned>(gb.width()));
         }
-        
+
         RenderTableSection* firstNonEmptySection = m_head ? m_head : (m_firstBody ? m_firstBody : m_foot);
         if (firstNonEmptySection && !firstNonEmptySection->numRows())
             firstNonEmptySection = sectionBelow(firstNonEmptySection, true);
-        
+
         if (firstNonEmptySection) {
             const BorderValue& sb = firstNonEmptySection->style()->borderEnd();
             if (sb.style() == BHIDDEN)
@@ -878,7 +1004,7 @@ int RenderTable::calcBorderEnd() const
                 borderWidth = max(borderWidth, static_cast<unsigned>(sb.width()));
 
             const RenderTableSection::CellStruct& cs = firstNonEmptySection->cellAt(0, endColumn);
-            
+
             if (cs.hasCells()) {
                 const BorderValue& cb = cs.primaryCell()->style()->borderEnd(); // FIXME: Make this work with perpendicular and flipped cells.
                 if (cb.style() == BHIDDEN)
@@ -1130,7 +1256,7 @@ RenderTableCell* RenderTable::cellBefore(const RenderTableCell* cell) const
     int effCol = colToEffCol(cell->col());
     if (!effCol)
         return 0;
-    
+
     // If we hit a colspan back up to a real cell.
     RenderTableSection::CellStruct& prevCell = section->cellAt(cell->row(), effCol - 1);
     return prevCell.primaryCell();
@@ -1175,7 +1301,7 @@ int RenderTable::firstLineBoxBaseline() const
 IntRect RenderTable::overflowClipRect(int tx, int ty, OverlayScrollbarSizeRelevancy relevancy)
 {
     IntRect rect = RenderBlock::overflowClipRect(tx, ty, relevancy);
-    
+
     // If we have a caption, expand the clip to include the caption.
     // FIXME: Technically this is wrong, but it's virtually impossible to fix this
     // for real until captions have been re-written.
diff --git a/src/3rdparty/webkit/Source/WebCore/rendering/RenderTableSection.cpp b/src/3rdparty/webkit/Source/WebCore/rendering/RenderTableSection.cpp
index 7d414a07db..43328c2cc9 100644
--- a/src/3rdparty/webkit/Source/WebCore/rendering/RenderTableSection.cpp
+++ b/src/3rdparty/webkit/Source/WebCore/rendering/RenderTableSection.cpp
@@ -414,7 +414,7 @@ void RenderTableSection::layout()
     setNeedsLayout(false);
 }
 
-int RenderTableSection::layoutRows(int toAdd)
+int RenderTableSection::layoutRows(int toAdd, int headHeight, int footHeight)
 {
 #ifndef NDEBUG
     setNeedsLayoutIsForbidden(true);
@@ -496,12 +496,56 @@ int RenderTableSection::layoutRows(int toAdd)
 
     LayoutStateMaintainer statePusher(view(), this, IntSize(x(), y()), style()->isFlippedBlocksWritingMode());
 
+    // Calculate logical row heights
+    Vector<int> logicalRowHeights;
+    logicalRowHeights.resize(totalRows);
+    for (int r = 0; r < totalRows; r++) {
+        logicalRowHeights[r] = m_rowPos[r + 1] - m_rowPos[r] - vspacing;
+    }
+
+    // Make sure that cell contents do not overlap a page break
+    if (view()->layoutState()->pageLogicalHeight()) {
+        LayoutState* layoutState = view()->layoutState();
+        int pageLogicalHeight = layoutState->m_pageLogicalHeight;
+        int pageOffset = 0;
+
+        for (int r = 0; r < totalRows; ++r) {
+            m_rowPos[r] += pageOffset;
+            int remainingLogicalHeight = pageLogicalHeight - layoutState->pageLogicalOffset(m_rowPos[r]) % pageLogicalHeight;
+            int availableHeight = remainingLogicalHeight - footHeight - vspacing;
+            RenderTableRow* rowRenderer = m_grid[r].rowRenderer;
+            
+            int rowRequiredHeight = 0;
+
+            for (int c = 0; c < nEffCols; c++) {
+                CellStruct& cs = cellAt(r, c);
+                RenderTableCell* cell = cs.primaryCell();
+
+                if (!cell || cs.inColSpan || cell->row() != r || !rowRenderer || rowRenderer->style()->pageBreakInside() != PBAVOID)
+                    continue;
+
+                int cellRequiredHeight = cell->contentLogicalHeight() + cell->paddingTop(false) + cell->paddingBottom(false);
+                if( cellRequiredHeight > rowRequiredHeight ){
+                    rowRequiredHeight = cellRequiredHeight;
+                }
+            }
+            int requiredHeight = max(logicalRowHeights[r], rowRequiredHeight);
+            if (requiredHeight >= availableHeight && requiredHeight < pageLogicalHeight) {
+                pageOffset += remainingLogicalHeight + headHeight;
+                if (requiredHeight > availableHeight) {
+                    m_rowPos[r] += remainingLogicalHeight + headHeight;
+                }
+            }
+        }
+        m_rowPos[totalRows] += pageOffset;
+    }
+
     for (int r = 0; r < totalRows; r++) {
         // Set the row's x/y position and width/height.
         if (RenderTableRow* rowRenderer = m_grid[r].rowRenderer) {
             rowRenderer->setLocation(0, m_rowPos[r]);
             rowRenderer->setLogicalWidth(logicalWidth());
-            rowRenderer->setLogicalHeight(m_rowPos[r + 1] - m_rowPos[r] - vspacing);
+            rowRenderer->setLogicalHeight(logicalRowHeights[r]);
             rowRenderer->updateLayerTransform();
         }
 
@@ -513,7 +557,11 @@ int RenderTableSection::layoutRows(int toAdd)
                 continue;
 
             rindx = cell->row();
-            rHeight = m_rowPos[rindx + cell->rowSpan()] - m_rowPos[rindx] - vspacing;
+            if (cell->rowSpan() == 1) {
+                rHeight = logicalRowHeights[rindx];
+            } else {
+                rHeight = m_rowPos[rindx + cell->rowSpan()] - m_rowPos[rindx] - vspacing;
+            }
             
             // Force percent height children to lay themselves out again.
             // This will cause these children to grow to fill the cell.
diff --git a/src/3rdparty/webkit/Source/WebCore/rendering/RenderTableSection.h b/src/3rdparty/webkit/Source/WebCore/rendering/RenderTableSection.h
index db6edc2a7a..9d912a0801 100644
--- a/src/3rdparty/webkit/Source/WebCore/rendering/RenderTableSection.h
+++ b/src/3rdparty/webkit/Source/WebCore/rendering/RenderTableSection.h
@@ -49,7 +49,7 @@ public:
 
     void setCellLogicalWidths();
     int calcRowLogicalHeight();
-    int layoutRows(int logicalHeight);
+    int layoutRows(int logicalHeight, int headHeight, int footHeight);
 
     RenderTable* table() const { return toRenderTable(parent()); }
 
diff --git a/src/3rdparty/webkit/Source/WebCore/rendering/RenderingAllInOne.cpp b/src/3rdparty/webkit/Source/WebCore/rendering/RenderingAllInOne.cpp
index afc42f1465..f216194abe 100644
--- a/src/3rdparty/webkit/Source/WebCore/rendering/RenderingAllInOne.cpp
+++ b/src/3rdparty/webkit/Source/WebCore/rendering/RenderingAllInOne.cpp
@@ -35,7 +35,6 @@
 #include "InlineFlowBox.cpp"
 #include "InlineTextBox.cpp"
 #include "LayoutState.cpp"
-#include "PointerEventsHitRules.cpp"
 #include "RenderApplet.cpp"
 #include "RenderArena.cpp"
 #include "RenderBR.cpp"
@@ -68,8 +67,6 @@
 #include "RenderListItem.cpp"
 #include "RenderListMarker.cpp"
 #include "RenderMarquee.cpp"
-#include "RenderMedia.cpp"
-#include "RenderMediaControls.cpp"
 #include "RenderMenuList.cpp"
 #include "RenderMeter.cpp"
 #include "RenderObject.cpp"
@@ -99,9 +96,7 @@
 #include "RenderTextControlSingleLine.cpp"
 #include "RenderTextFragment.cpp"
 #include "RenderTheme.cpp"
-#include "RenderThemeWin.cpp"
 #include "RenderTreeAsText.cpp"
-#include "RenderVideo.cpp"
 #include "RenderView.cpp"
 #include "RenderWidget.cpp"
 #include "RenderWordBreak.cpp"
diff --git a/src/3rdparty/webkit/Source/WebCore/rendering/RootInlineBox.h b/src/3rdparty/webkit/Source/WebCore/rendering/RootInlineBox.h
index 575a10db2b..cf94af6f64 100644
--- a/src/3rdparty/webkit/Source/WebCore/rendering/RootInlineBox.h
+++ b/src/3rdparty/webkit/Source/WebCore/rendering/RootInlineBox.h
@@ -53,6 +53,9 @@ public:
     int paginationStrut() const { return m_paginationStrut; }
     void setPaginationStrut(int s) { m_paginationStrut = s; }
 
+    bool isFirstAfterPageBreak() const { return m_isFirstAfterPageBreak; }
+    void setIsFirstAfterPageBreak(bool isFirstAfterPageBreak) { m_isFirstAfterPageBreak = isFirstAfterPageBreak; }
+
     int selectionTop() const;
     int selectionBottom() const;
     int selectionHeight() const { return max(0, selectionBottom() - selectionTop()); }
diff --git a/src/3rdparty/webkit/Source/WebCore/rendering/style/RenderStyle.h b/src/3rdparty/webkit/Source/WebCore/rendering/style/RenderStyle.h
index 938b29760a..8d52acc04e 100644
--- a/src/3rdparty/webkit/Source/WebCore/rendering/style/RenderStyle.h
+++ b/src/3rdparty/webkit/Source/WebCore/rendering/style/RenderStyle.h
@@ -637,6 +637,8 @@ public:
 
     short widows() const { return rareInheritedData->widows; }
     short orphans() const { return rareInheritedData->orphans; }
+    bool hasAutoWidows() const { return rareInheritedData->m_hasAutoWidows; }
+    bool hasAutoOrphans() const { return rareInheritedData->m_hasAutoOrphans; }
     EPageBreak pageBreakInside() const { return static_cast<EPageBreak>(noninherited_flags._page_break_inside); }
     EPageBreak pageBreakBefore() const { return static_cast<EPageBreak>(noninherited_flags._page_break_before); }
     EPageBreak pageBreakAfter() const { return static_cast<EPageBreak>(noninherited_flags._page_break_after); }
@@ -1011,8 +1013,10 @@ public:
     int zIndex() const { return m_box->zIndex(); }
     void setZIndex(int v) { SET_VAR(m_box, m_hasAutoZIndex, false); SET_VAR(m_box, m_zIndex, v) }
 
-    void setWidows(short w) { SET_VAR(rareInheritedData, widows, w); }
-    void setOrphans(short o) { SET_VAR(rareInheritedData, orphans, o); }
+    void setHasAutoWidows() { SET_VAR(rareInheritedData, m_hasAutoWidows, true); SET_VAR(rareInheritedData, widows, initialWidows()) }
+    void setWidows(short w) { SET_VAR(rareInheritedData, m_hasAutoWidows, false); SET_VAR(rareInheritedData, widows, w); }
+    void setHasAutoOrphans() { SET_VAR(rareInheritedData, m_hasAutoOrphans, true); SET_VAR(rareInheritedData, orphans, initialOrphans()) }
+    void setOrphans(short o) { SET_VAR(rareInheritedData, m_hasAutoOrphans, false); SET_VAR(rareInheritedData, orphans, o); }
     void setPageBreakInside(EPageBreak b) { noninherited_flags._page_break_inside = b; }
     void setPageBreakBefore(EPageBreak b) { noninherited_flags._page_break_before = b; }
     void setPageBreakAfter(EPageBreak b) { noninherited_flags._page_break_after = b; }
diff --git a/src/3rdparty/webkit/Source/WebCore/rendering/style/StyleAllInOne.cpp b/src/3rdparty/webkit/Source/WebCore/rendering/style/StyleAllInOne.cpp
index 967fa000e7..2dd9dc9994 100644
--- a/src/3rdparty/webkit/Source/WebCore/rendering/style/StyleAllInOne.cpp
+++ b/src/3rdparty/webkit/Source/WebCore/rendering/style/StyleAllInOne.cpp
@@ -32,8 +32,6 @@
 #include "NinePieceImage.cpp"
 #include "QuotesData.cpp"
 #include "RenderStyle.cpp"
-#include "SVGRenderStyle.cpp"
-#include "SVGRenderStyleDefs.cpp"
 #include "ShadowData.cpp"
 #include "StyleBackgroundData.cpp"
 #include "StyleBoxData.cpp"
diff --git a/src/3rdparty/webkit/Source/WebCore/rendering/style/StyleRareInheritedData.cpp b/src/3rdparty/webkit/Source/WebCore/rendering/style/StyleRareInheritedData.cpp
index c38461166b..a7ece4fa35 100644
--- a/src/3rdparty/webkit/Source/WebCore/rendering/style/StyleRareInheritedData.cpp
+++ b/src/3rdparty/webkit/Source/WebCore/rendering/style/StyleRareInheritedData.cpp
@@ -36,6 +36,8 @@ StyleRareInheritedData::StyleRareInheritedData()
     , m_effectiveZoom(RenderStyle::initialZoom())
     , widows(RenderStyle::initialWidows())
     , orphans(RenderStyle::initialOrphans())
+    , m_hasAutoWidows(true)
+    , m_hasAutoOrphans(true)
     , textSecurity(RenderStyle::initialTextSecurity())
     , userModify(READ_ONLY)
     , wordBreak(RenderStyle::initialWordBreak())
@@ -70,6 +72,8 @@ StyleRareInheritedData::StyleRareInheritedData(const StyleRareInheritedData& o)
     , m_effectiveZoom(o.m_effectiveZoom)
     , widows(o.widows)
     , orphans(o.orphans)
+    , m_hasAutoWidows(o.m_hasAutoWidows)
+    , m_hasAutoOrphans(o.m_hasAutoOrphans)
     , textSecurity(o.textSecurity)
     , userModify(o.userModify)
     , wordBreak(o.wordBreak)
@@ -120,6 +124,8 @@ bool StyleRareInheritedData::operator==(const StyleRareInheritedData& o) const
         && m_effectiveZoom == o.m_effectiveZoom
         && widows == o.widows
         && orphans == o.orphans
+        && m_hasAutoWidows == o.m_hasAutoWidows
+        && m_hasAutoOrphans == o.m_hasAutoOrphans
         && textSecurity == o.textSecurity
         && userModify == o.userModify
         && wordBreak == o.wordBreak
diff --git a/src/3rdparty/webkit/Source/WebCore/rendering/style/StyleRareInheritedData.h b/src/3rdparty/webkit/Source/WebCore/rendering/style/StyleRareInheritedData.h
index da410f1ac6..b853cba98d 100644
--- a/src/3rdparty/webkit/Source/WebCore/rendering/style/StyleRareInheritedData.h
+++ b/src/3rdparty/webkit/Source/WebCore/rendering/style/StyleRareInheritedData.h
@@ -68,6 +68,8 @@ public:
     // Paged media properties.
     short widows;
     short orphans;
+    unsigned m_hasAutoWidows : 1;
+    unsigned m_hasAutoOrphans : 1;
     
     unsigned textSecurity : 2; // ETextSecurity
     unsigned userModify : 2; // EUserModify (editing)
diff --git a/src/3rdparty/webkit/Source/WebKit.pri b/src/3rdparty/webkit/Source/WebKit.pri
index 01f88a485d..c3df18cbdb 100644
--- a/src/3rdparty/webkit/Source/WebKit.pri
+++ b/src/3rdparty/webkit/Source/WebKit.pri
@@ -38,7 +38,7 @@ DEPENDPATH += $$OUT_PWD
 
 DEFINES += BUILDING_QT__=1
 building-libs {
-    win32-msvc*|win32-icc: INCLUDEPATH += $$PWD/JavaScriptCore/os-win32
+    win32-msvc200*|win32-msvc2010|win32-msvc2012|win32-msvc2013|win32-icc: INCLUDEPATH += $$PWD/JavaScriptCore/os-win32
 } else {
     CONFIG(QTDIR_build) {
         QT += webkit
diff --git a/src/3rdparty/webkit/Source/WebKit.pro b/src/3rdparty/webkit/Source/WebKit.pro
index 9be0f4aff9..1731066c38 100644
--- a/src/3rdparty/webkit/Source/WebKit.pro
+++ b/src/3rdparty/webkit/Source/WebKit.pro
@@ -1,16 +1,11 @@
 TEMPLATE = subdirs
 CONFIG += ordered
+DEFINES += Q_NODLL Q_DECL_IMPORT QT_STATIC_BUILD STATIC
 
 include(WebKit.pri)
 
-!v8 {
-    exists($$PWD/JavaScriptCore/JavaScriptCore.pro): SUBDIRS += JavaScriptCore/JavaScriptCore.pro
-    exists($$PWD/JavaScriptCore/jsc.pro): SUBDIRS += JavaScriptCore/jsc.pro
-}
-
 webkit2:exists($$PWD/WebKit2/WebKit2.pro): SUBDIRS += WebKit2/WebKit2.pro
 
-SUBDIRS += WebCore
 SUBDIRS += WebKit/qt/QtWebKit.pro
 
 webkit2 {
@@ -22,8 +17,6 @@ contains(QT_CONFIG, declarative) {
     exists($$PWD/WebKit/qt/declarative): SUBDIRS += WebKit/qt/declarative
 }
 
-exists($$PWD/WebKit/qt/tests): SUBDIRS += WebKit/qt/tests
-
 build-qtscript {
     SUBDIRS += \
         JavaScriptCore/qt/api/QtScript.pro \
@@ -38,5 +31,3 @@ symbian {
     install.commands = $(MAKE) -C WebCore install
     QMAKE_EXTRA_TARGETS += install
 }
-
-include(WebKit/qt/docs/docs.pri)
diff --git a/src/3rdparty/webkit/Source/WebKit/qt/Api/qwebelement.h b/src/3rdparty/webkit/Source/WebKit/qt/Api/qwebelement.h
index 4b1a7582f6..2ad7f1f9f4 100644
--- a/src/3rdparty/webkit/Source/WebKit/qt/Api/qwebelement.h
+++ b/src/3rdparty/webkit/Source/WebKit/qt/Api/qwebelement.h
@@ -170,6 +170,7 @@ private:
     friend class QWebHitTestResult;
     friend class QWebHitTestResultPrivate;
     friend class QWebPage;
+    friend class QWebPrinter;
 
 #if defined(WTF_USE_V8) && WTF_USE_V8
     friend class V8::Bindings::QtWebElementRuntime;
diff --git a/src/3rdparty/webkit/Source/WebKit/qt/Api/qwebframe.cpp b/src/3rdparty/webkit/Source/WebKit/qt/Api/qwebframe.cpp
index 5ea7059132..053e393b3f 100644
--- a/src/3rdparty/webkit/Source/WebKit/qt/Api/qwebframe.cpp
+++ b/src/3rdparty/webkit/Source/WebKit/qt/Api/qwebframe.cpp
@@ -216,6 +216,110 @@ static inline ResourceRequestCachePolicy cacheLoadControlToCachePolicy(uint cach
     return WebCore::UseProtocolCachePolicy;
 }
 
+#ifndef QT_NO_PRINTER
+QWebPrinterPrivate::QWebPrinterPrivate(const QWebFrame *f, QPaintDevice *printer, QPainter &p)
+    : printContext(f->d->frame)
+    , painter(p)
+    , frame(f)
+    , graphicsContext(&p)
+{
+    IntRect pageRect(0, 0, printer->width(), printer->height());
+    printContext.begin(pageRect.width(), pageRect.height());
+    float pageHeight = 0;
+    printContext.computePageRects(pageRect, /* headerHeight */ 0, /* footerHeight */ 0, /* userScaleFactor */ 1.0, pageHeight);
+
+    printWidth = pageRect.width();
+}
+
+QWebPrinterPrivate::~QWebPrinterPrivate() 
+{
+    printContext.end();
+}
+
+/*!
+    \class QWebPrinter
+    \since 4.7
+    \brief The QWebPrinter controls printing of a \l{QWebFrame::}
+
+    \inmodule QtWebKit
+
+    \sa QWebFrame
+*/
+QWebPrinter::QWebPrinter(const QWebFrame *frame, QPaintDevice *printer, QPainter &painter)
+    : d(new QWebPrinterPrivate(frame, printer, painter))
+{}
+
+QWebPrinter::~QWebPrinter() 
+{
+    delete d; 
+}
+
+/*!
+    Print a page of the frame. \a i is  the number of the page to print, 
+    and must be between 1 and \fn QWebPrinter::pageCount() .
+*/
+void QWebPrinter::spoolPage(int i) const
+{
+    if (i < 1 || i > d->printContext.pageCount()) 
+        return;
+    d->printContext.spoolPage(d->graphicsContext, i - 1, d->printWidth);
+}
+
+/*!
+    Returns the number of pages of the frame when printed.
+*/
+int QWebPrinter::pageCount() const
+{
+    return d->printContext.pageCount();
+}
+
+QPair<int, QRectF> QWebPrinter::elementLocation(const QWebElement & e)
+{
+    //Compute a mapping from node to render object once and for all
+    if (d->elementToRenderObject.empty())
+    for (WebCore::RenderObject * o=d->frame->d->frame->document()->renderer(); o; o=o->nextInPreOrder())
+        if (o->node())
+            d->elementToRenderObject[o->node()] = o;
+        
+    if (!d->elementToRenderObject.contains(e.m_element))
+        return QPair<int,QRectF>(-1, QRectF());
+    const WebCore::RenderObject * ro = d->elementToRenderObject[e.m_element];
+    const Vector<IntRect> & pageRects = d->printContext.getPageRects();
+
+    if (pageRects.size() == 0)
+        return QPair<int,QRectF>(-1, QRectF());
+
+    WebCore::RenderView *root = toRenderView(d->frame->d->frame->document()->renderer());
+    //We need the scale factor, because pages are shrinked
+    float scale = (float)d->printWidth / (float)root->width();
+
+    QRectF r(const_cast<WebCore::RenderObject *>(ro)->absoluteBoundingBoxRect());
+    
+    int low=0;
+    int high=pageRects.size();
+    int c = r.y() + r.height() / 2;
+    while(low <= high) {
+        int m = (low+high)/2;
+        if(c < pageRects[m].y())
+            high = m-1;
+        else if(c > pageRects[m].maxY())
+            low = m +1;
+        else {
+            QRectF tr = r.translated(0, -pageRects[m].y());
+            return QPair<int, QRectF>(m+1, QRect(tr.x() * scale, tr.y()*scale, tr.width()*scale, tr.height()*scale));
+        }
+    }
+    return QPair<int,QRectF>(-1, QRectF());
+}
+
+/*!
+    Return the painter used for printing.
+*/
+QPainter * QWebPrinter::painter() {
+    return &d->painter;
+}
+#endif //QT_NO_PRINTER
+
 QWebFrameData::QWebFrameData(WebCore::Page* parentPage, WebCore::Frame* parentFrame,
                              WebCore::HTMLFrameOwnerElement* ownerFrameElement,
                              const WTF::String& frameName)
@@ -1434,25 +1538,8 @@ bool QWebFrame::event(QEvent *e)
 void QWebFrame::print(QPrinter *printer) const
 {
     QPainter painter;
-    if (!painter.begin(printer))
-        return;
-
-    const qreal zoomFactorX = (qreal)printer->logicalDpiX() / qt_defaultDpi();
-    const qreal zoomFactorY = (qreal)printer->logicalDpiY() / qt_defaultDpi();
-
-    PrintContext printContext(d->frame);
-    float pageHeight = 0;
-
-    QRect qprinterRect = printer->pageRect();
-
-    IntRect pageRect(0, 0,
-                     int(qprinterRect.width() / zoomFactorX),
-                     int(qprinterRect.height() / zoomFactorY));
-
-    printContext.begin(pageRect.width());
-
-    printContext.computePageRects(pageRect, /* headerHeight */ 0, /* footerHeight */ 0, /* userScaleFactor */ 1.0, pageHeight);
-
+    painter.begin(printer);
+    QWebPrinter p(this, printer, painter);
     int docCopies;
     int pageCopies;
     if (printer->collateCopies()) {
@@ -1469,11 +1556,12 @@ void QWebFrame::print(QPrinter *printer) const
 
     if (fromPage == 0 && toPage == 0) {
         fromPage = 1;
-        toPage = printContext.pageCount();
+        toPage = p.pageCount();
     }
     // paranoia check
     fromPage = qMax(1, fromPage);
-    toPage = qMin(static_cast<int>(printContext.pageCount()), toPage);
+    toPage = qMin(static_cast<int>(p.pageCount()), toPage);
+
     if (toPage < fromPage) {
         // if the user entered a page range outside the actual number
         // of printable pages, just return
@@ -1486,20 +1574,15 @@ void QWebFrame::print(QPrinter *printer) const
         toPage = tmp;
         ascending = false;
     }
-
-    painter.scale(zoomFactorX, zoomFactorY);
-    GraphicsContext ctx(&painter);
-
     for (int i = 0; i < docCopies; ++i) {
         int page = fromPage;
         while (true) {
             for (int j = 0; j < pageCopies; ++j) {
                 if (printer->printerState() == QPrinter::Aborted
                     || printer->printerState() == QPrinter::Error) {
-                    printContext.end();
                     return;
                 }
-                printContext.spoolPage(ctx, page - 1, pageRect.width());
+                p.spoolPage(page);
                 if (j < pageCopies - 1)
                     printer->newPage();
             }
@@ -1518,8 +1601,7 @@ void QWebFrame::print(QPrinter *printer) const
         if ( i < docCopies - 1)
             printer->newPage();
     }
-
-    printContext.end();
+    painter.end();
 }
 #endif // QT_NO_PRINTER
 
diff --git a/src/3rdparty/webkit/Source/WebKit/qt/Api/qwebframe.h b/src/3rdparty/webkit/Source/WebKit/qt/Api/qwebframe.h
index 3c5a28e7d5..99771f8a88 100644
--- a/src/3rdparty/webkit/Source/WebKit/qt/Api/qwebframe.h
+++ b/src/3rdparty/webkit/Source/WebKit/qt/Api/qwebframe.h
@@ -21,6 +21,8 @@
 #ifndef QWEBFRAME_H
 #define QWEBFRAME_H
 
+#define  __EXTENSIVE_WKHTMLTOPDF_QT_HACK__
+
 #include <QtCore/qobject.h>
 #include <QtCore/qurl.h>
 #include <QtCore/qvariant.h>
@@ -42,6 +44,9 @@ class QPrinter;
 QT_END_NAMESPACE
 
 class QWebNetworkRequest;
+#ifndef QT_NO_PRINTER
+class QWebPrinterPrivate;
+#endif
 class QWebFramePrivate;
 class QWebPage;
 class QWebHitTestResult;
@@ -103,6 +108,20 @@ private:
     friend class QWebPage;
 };
 
+#ifndef QT_NO_PRINTER
+class QWEBKIT_EXPORT QWebPrinter {
+public:
+    QWebPrinter(const QWebFrame * frame, QPaintDevice * printer, QPainter &painter);
+    ~QWebPrinter();
+    void spoolPage(int i) const;
+    QPainter * painter();
+    int pageCount() const;
+    QPair<int, QRectF> elementLocation(const QWebElement & e);
+private:
+    QWebPrinterPrivate * d;
+};
+#endif
+
 class QWEBKIT_EXPORT QWebFrame : public QObject {
     Q_OBJECT
     Q_PROPERTY(qreal textSizeMultiplier READ textSizeMultiplier WRITE setTextSizeMultiplier DESIGNABLE false)
@@ -228,6 +247,8 @@ private:
     friend class QWebPage;
     friend class QWebPagePrivate;
     friend class QWebFramePrivate;
+    friend class QWebPrinterPrivate;
+    friend class QWebPrinter;
     friend class DumpRenderTreeSupportQt;
     friend class WebCore::WidgetPrivate;
     friend class WebCore::FrameLoaderClientQt;
diff --git a/src/3rdparty/webkit/Source/WebKit/qt/Api/qwebframe_p.h b/src/3rdparty/webkit/Source/WebKit/qt/Api/qwebframe_p.h
index 4108972df5..3698eed48c 100644
--- a/src/3rdparty/webkit/Source/WebKit/qt/Api/qwebframe_p.h
+++ b/src/3rdparty/webkit/Source/WebKit/qt/Api/qwebframe_p.h
@@ -35,6 +35,9 @@
 #include "wtf/RefPtr.h"
 #include "Frame.h"
 #include "ViewportArguments.h"
+#include <qpainter.h>
+#include "PrintContext.h"
+#include "GraphicsContext.h"
 
 #if USE(ACCELERATED_COMPOSITING) && USE(TEXTURE_MAPPER)
 #include "texmap/TextureMapper.h"
@@ -69,6 +72,19 @@ public:
     int marginHeight;
 };
 
+class QWebPrinterPrivate {
+public:
+    WebCore::PrintContext printContext;
+    QPainter & painter;
+    const QWebFrame * frame;
+    WebCore::GraphicsContext graphicsContext;
+    int printWidth;
+    QHash<const WebCore::Node*, const WebCore::RenderObject *> elementToRenderObject;
+    
+    QWebPrinterPrivate(const QWebFrame * frame, QPaintDevice *printer, QPainter &p);
+    ~QWebPrinterPrivate();
+};
+
 class QWebFramePrivate {
 public:
     QWebFramePrivate()
diff --git a/src/3rdparty/webkit/Source/WebKit/qt/Api/qwebpage.cpp b/src/3rdparty/webkit/Source/WebKit/qt/Api/qwebpage.cpp
index 078fe15bc1..d23c816e10 100644
--- a/src/3rdparty/webkit/Source/WebKit/qt/Api/qwebpage.cpp
+++ b/src/3rdparty/webkit/Source/WebKit/qt/Api/qwebpage.cpp
@@ -3215,6 +3215,11 @@ bool QWebPage::isContentEditable() const
     return d->page->isEditable();
 }
 
+void QWebPage::setDevicePixelRatio(qreal devicePixelRatio)
+{
+    d->pixelRatio = devicePixelRatio;
+}
+
 /*!
     \property QWebPage::forwardUnsupportedContent
     \brief whether QWebPage should forward unsupported content
diff --git a/src/3rdparty/webkit/Source/WebKit/qt/Api/qwebpage.h b/src/3rdparty/webkit/Source/WebKit/qt/Api/qwebpage.h
index f1f481beef..3e1014141c 100644
--- a/src/3rdparty/webkit/Source/WebKit/qt/Api/qwebpage.h
+++ b/src/3rdparty/webkit/Source/WebKit/qt/Api/qwebpage.h
@@ -308,6 +308,8 @@ public:
     void setContentEditable(bool editable);
     bool isContentEditable() const;
 
+    void setDevicePixelRatio(qreal devicePixelRatio);
+
 #ifndef QT_NO_CONTEXTMENU
     bool swallowContextMenuEvent(QContextMenuEvent *event);
 #endif
diff --git a/src/3rdparty/webkit/Source/WebKit/qt/Api/qwebsettings.cpp b/src/3rdparty/webkit/Source/WebKit/qt/Api/qwebsettings.cpp
index c1ef92e651..dc4de392b7 100644
--- a/src/3rdparty/webkit/Source/WebKit/qt/Api/qwebsettings.cpp
+++ b/src/3rdparty/webkit/Source/WebKit/qt/Api/qwebsettings.cpp
@@ -75,8 +75,11 @@ public:
     QUrl userStyleSheetLocation;
     QString defaultTextEncoding;
     QString localStoragePath;
+    QString printingMediaType;
     QString offlineWebApplicationCachePath;
     qint64 offlineStorageDefaultQuota;
+    qreal printingMinimumShrinkFactor;
+    qreal printingMaximumShrinkFactor;
 
     void apply();
     WebCore::Settings* settings;
@@ -229,9 +232,18 @@ void QWebSettingsPrivate::apply()
         QString encoding = !defaultTextEncoding.isEmpty() ? defaultTextEncoding: global->defaultTextEncoding;
         settings->setDefaultTextEncodingName(encoding);
 
+        QString type = !printingMediaType.isEmpty() ? printingMediaType : global->printingMediaType;
+        settings->setPrintingMediaType(type.isEmpty() ? "print" : type);
+
         QString storagePath = !localStoragePath.isEmpty() ? localStoragePath : global->localStoragePath;
         settings->setLocalStorageDatabasePath(storagePath);
 
+        float minimumShrinkFactor = printingMinimumShrinkFactor > 0.0f ? printingMinimumShrinkFactor : global->printingMinimumShrinkFactor;
+        settings->setPrintingMinimumShrinkFactor(minimumShrinkFactor);
+
+        float maximumShrinkFactor = printingMaximumShrinkFactor > 0.0f ? printingMaximumShrinkFactor : global->printingMaximumShrinkFactor;
+        settings->setPrintingMaximumShrinkFactor(maximumShrinkFactor);
+
         value = attributes.value(QWebSettings::PrintElementBackgrounds,
                                       global->attributes.value(QWebSettings::PrintElementBackgrounds));
         settings->setShouldPrintBackgrounds(value);
@@ -519,6 +531,8 @@ QWebSettings::QWebSettings()
     d->attributes.insert(QWebSettings::SiteSpecificQuirksEnabled, true);
     d->offlineStorageDefaultQuota = 5 * 1024 * 1024;
     d->defaultTextEncoding = QLatin1String("iso-8859-1");
+    d->printingMinimumShrinkFactor = 1.25f;
+    d->printingMaximumShrinkFactor = 2.0f;
 }
 
 /*!
@@ -527,6 +541,8 @@ QWebSettings::QWebSettings()
 QWebSettings::QWebSettings(WebCore::Settings* settings)
     : d(new QWebSettingsPrivate(settings))
 {
+    d->printingMinimumShrinkFactor = 0.0f;
+    d->printingMaximumShrinkFactor = 0.0f;
     d->settings = settings;
     d->apply();
     allSettings()->append(d);
@@ -635,6 +651,86 @@ QString QWebSettings::defaultTextEncoding() const
 }
 
 /*!
+    \since 4.7
+    Specifies which media type to use when printing. If
+    left empty the default "print" will be used, other choices include "screen". 
+    See \l{http://www.w3.org/TR/CSS2/media.html}{CSS Standard}, for a complete list.
+
+    \sa printingMediaType()
+*/
+void QWebSettings::setPrintingMediaType(const QString& type)
+{
+    d->printingMediaType = type;
+    d->apply();
+}
+
+/*!
+    \since 4.7
+    Returns the media type used when printing or QString() if the
+    default value is used.
+
+    \sa setPrintingMediaType()
+*/
+QString QWebSettings::printingMediaType() const
+{
+    return d->printingMediaType;
+}
+
+/*!
+    \since 4.6
+    Specifies minimum shrink fator allowed for printing. If set to 0 a
+    default value is used.
+
+    When printing, content will be shrunk to reduce page usage, it
+    will reduced by a factor between printingMinimumShrinkFactor and
+    printingMaximumShrinkFactor. 
+
+    \sa printingMinimumShrinkFactor()
+    \sa setPrintingMaximumShrinkFactor()
+    \sa printingMaximumShrinkFactor()
+*/
+void QWebSettings::setPrintingMinimumShrinkFactor(qreal printingMinimumShrinkFactor)
+{
+    d->printingMinimumShrinkFactor = printingMinimumShrinkFactor;
+    d->apply();
+}
+
+/*!
+    \since 4.6
+    returns the minimum shrink factor used for printing.
+
+    \sa setPrintingMinimumShrinkFactor()
+*/
+qreal QWebSettings::printingMinimumShrinkFactor() const
+{
+    return d->printingMinimumShrinkFactor;
+}
+
+/*!
+    \since 4.6 
+    Specifies maximum shrink fator allowed for printing. If set to 0 a
+    default value is used.
+
+    \sa setPrintingMinimumShrinkFactor()
+*/
+void QWebSettings::setPrintingMaximumShrinkFactor(qreal printingMaximumShrinkFactor)
+{
+    d->printingMaximumShrinkFactor = printingMaximumShrinkFactor;
+    d->apply();
+}
+
+/*!
+    \since 4.6 
+    returns the maximum shrink factor used for printing.
+
+    \sa setPrintingMinimumShrinkFactor()
+*/
+qreal QWebSettings::printingMaximumShrinkFactor() const
+{
+    return d->printingMaximumShrinkFactor;
+}
+
+/*!
     Sets the path of the icon database to \a path. The icon database is used
     to store "favicons" associated with web sites.
 
diff --git a/src/3rdparty/webkit/Source/WebKit/qt/Api/qwebsettings.h b/src/3rdparty/webkit/Source/WebKit/qt/Api/qwebsettings.h
index 008035ba76..bb134a344e 100644
--- a/src/3rdparty/webkit/Source/WebKit/qt/Api/qwebsettings.h
+++ b/src/3rdparty/webkit/Source/WebKit/qt/Api/qwebsettings.h
@@ -116,6 +116,15 @@ public:
     void setDefaultTextEncoding(const QString &encoding);
     QString defaultTextEncoding() const;
 
+    void setPrintingMediaType(const QString &type);
+    QString printingMediaType() const;
+
+    void setPrintingMinimumShrinkFactor(qreal printingMinimumShrinkFactor);
+    qreal printingMinimumShrinkFactor() const;
+
+    void setPrintingMaximumShrinkFactor(qreal printingMaximimShrinkFactor);
+    qreal printingMaximumShrinkFactor() const;
+
     static void setIconDatabasePath(const QString &location);
     static QString iconDatabasePath();
     static void clearIconDatabase();
diff --git a/src/3rdparty/webkit/Source/WebKit/qt/QtWebKit.pro b/src/3rdparty/webkit/Source/WebKit/qt/QtWebKit.pro
index 32798f7f00..5c6fd4fbaa 100644
--- a/src/3rdparty/webkit/Source/WebKit/qt/QtWebKit.pro
+++ b/src/3rdparty/webkit/Source/WebKit/qt/QtWebKit.pro
@@ -2,7 +2,6 @@
 CONFIG += building-libs
 CONFIG += depend_includepath
 
-TARGET = QtWebKit
 TEMPLATE = lib
 
 DEFINES += BUILDING_WEBKIT
@@ -15,23 +14,53 @@ else: CONFIG_DIR = release
 
 SOURCE_DIR = $$replace(PWD, /WebKit/qt, "")
 
-include($$PWD/Api/headers.pri)
 include($$SOURCE_DIR/WebKit.pri)
-include($$SOURCE_DIR/JavaScriptCore/JavaScriptCore.pri)
+
+include($$SOURCE_DIR/JavaScriptCore/JavaScriptCore.pro)
+
+for(item, SOURCES):JAVASCRIPT_CORE_SOURCES += ../../JavaScriptCore/$$item
+
+unset(SOURCES)
+
+include($$SOURCE_DIR/WebCore/WebCore.pro)
+
+for(item, SOURCES): {
+    path = $$split(item, '/')
+
+    contains(path, sqlite3.c) {
+        WEB_CORE_SOURCES += $$item
+    }
+
+    !contains(path, sqlite3.c) {
+        WEB_CORE_SOURCES += ../../WebCore/$$item
+    }
+}
+for(item, HEADERS):WEB_CORE_HEADERS += ../../WebCore/$$item
+for(item, ASM_SOURCES):WEB_CORE_ASM_SOURCES += ../../WebCore/$$item
+
+SOURCES = $$JAVASCRIPT_CORE_SOURCES $$WEB_CORE_SOURCES
+HEADERS = $$WEB_CORE_HEADERS
+ASM_SOURCES = $$WEB_CORE_ASM_SOURCES
+
+mac {
+  for(item, OBJECTIVE_SOURCES):WEB_CORE_OBJECTIVE_SOURCES += ../../WebCore/$$item
+  OBJECTIVE_SOURCES = $$WEB_CORE_OBJECTIVE_SOURCES
+  INCLUDEPATH += ../../WebCore/platform/mac
+}
+
+include($$PWD/Api/headers.pri)
+
 webkit2 {
     include($$SOURCE_DIR/WebKit2/WebKit2.pri)
     include($$SOURCE_DIR/WebKit2/WebKit2API.pri)
 }
-include($$SOURCE_DIR/WebCore/WebCore.pri)
 
-!v8:prependJavaScriptCoreLib(../../JavaScriptCore)
-prependWebCoreLib(../../WebCore)
-webkit2:prependWebKit2Lib(../../WebKit2)
+TARGET = QtWebKit
 
 # This is needed for syncqt when it parses the dependencies on module's main pro file so
 # the generated includes are containing the dependencies.
 # It used to be in WebCore.pro but now that this is the main pro file it has to be here.
-QT += network
+QT += network gui
 
 isEmpty(OUTPUT_DIR): OUTPUT_DIR = ../..
 
@@ -42,6 +71,8 @@ win32*:!win32-msvc* {
     contains(DEFINES, ENABLE_WEBGL=1)|contains(CONFIG, texmap): LIBS += $$QMAKE_LIBS_OPENGL
 }
 
+win32-msvc*:LIBS += -lAdvapi32
+
 include_webinspector: RESOURCES += $$SOURCE_DIR/WebCore/inspector/front-end/WebKit.qrc $$WC_GENERATED_SOURCES_DIR/InspectorBackendStub.qrc
 
 # Extract sources to build from the generator definitions
diff --git a/src/corelib/tools/qtextboundaryfinder.cpp b/src/corelib/tools/qtextboundaryfinder.cpp
index d6a8987dd1..f69b19c7e9 100644
--- a/src/corelib/tools/qtextboundaryfinder.cpp
+++ b/src/corelib/tools/qtextboundaryfinder.cpp
@@ -156,6 +156,8 @@ static void init(QTextBoundaryFinder::BoundaryType type, const QChar *chars, int
   \value NotAtBoundary  The boundary finder is not at a boundary position.
   \value StartWord  The boundary finder is at the start of a word.
   \value EndWord  The boundary finder is at the end of a word.
+  \value SoftHyphen The boundary finder is at the soft hyphen
+                    (can occur for a Line boundary type only).
 */
 
 /*!
@@ -369,7 +371,7 @@ int QTextBoundaryFinder::toNextBoundary()
         break;
     case Line:
         Q_ASSERT(pos);
-        while (pos < length && d->attributes[pos-1].lineBreakType < HB_Break)
+        while (pos < length && d->attributes[pos-1].lineBreakType == HB_NoBreak)
             ++pos;
         break;
     }
@@ -411,7 +413,7 @@ int QTextBoundaryFinder::toPreviousBoundary()
             --pos;
         break;
     case Line:
-        while (pos > 0 && d->attributes[pos-1].lineBreakType < HB_Break)
+        while (pos > 0 && d->attributes[pos-1].lineBreakType == HB_NoBreak)
             --pos;
         break;
     }
@@ -436,7 +438,7 @@ bool QTextBoundaryFinder::isAtBoundary() const
     case Word:
         return d->attributes[pos].wordBoundary;
     case Line:
-        return (pos > 0) ? d->attributes[pos-1].lineBreakType >= HB_Break : true;
+        return (pos > 0) ? d->attributes[pos-1].lineBreakType != HB_NoBreak : true;
     case Sentence:
         return d->attributes[pos].sentenceBoundary;
     }
@@ -452,6 +454,8 @@ QTextBoundaryFinder::BoundaryReasons QTextBoundaryFinder::boundaryReasons() cons
         return NotAtBoundary;
     if (! isAtBoundary())
         return NotAtBoundary;
+    if (t == Line && pos < length && d->attributes[pos-1].lineBreakType == HB_SoftHyphen)
+        return SoftHyphen;
     if (pos == 0) {
         if (d->attributes[pos].whiteSpace)
             return NotAtBoundary;
diff --git a/src/corelib/tools/qtextboundaryfinder.h b/src/corelib/tools/qtextboundaryfinder.h
index 186ec08144..6db8478747 100644
--- a/src/corelib/tools/qtextboundaryfinder.h
+++ b/src/corelib/tools/qtextboundaryfinder.h
@@ -71,8 +71,8 @@ public:
     enum BoundaryReason {
         NotAtBoundary = 0,
         StartWord = 1,
-        EndWord = 2
-        //Hyphen
+        EndWord = 2,
+        SoftHyphen = 4
     };
     Q_DECLARE_FLAGS( BoundaryReasons, BoundaryReason )
 
@@ -106,6 +106,8 @@ private:
     QTextBoundaryFinderPrivate *d;
 };
 
+Q_DECLARE_OPERATORS_FOR_FLAGS(QTextBoundaryFinder::BoundaryReasons)
+
 QT_END_NAMESPACE
 
 QT_END_HEADER
diff --git a/src/gui/gui.pro b/src/gui/gui.pro
index 63e3ccd498..3dee2c8d63 100644
--- a/src/gui/gui.pro
+++ b/src/gui/gui.pro
@@ -87,6 +87,10 @@ win32:!contains(QT_CONFIG, directwrite) {
     DEFINES += QT_NO_DIRECTWRITE
 }
 
+win32-g++* {
+    INCLUDEPATH += $$PWD
+}
+
 mac:contains(QMAKE_MAC_XARCH, no) {
     DEFINES += QT_NO_MAC_XARCH
 } else {
diff --git a/src/gui/image/qpixmap.cpp b/src/gui/image/qpixmap.cpp
index 20cc2b3597..8027d693cc 100644
--- a/src/gui/image/qpixmap.cpp
+++ b/src/gui/image/qpixmap.cpp
@@ -134,12 +134,6 @@ extern QApplication::Type qt_appType;
 
 void QPixmap::init(int w, int h, int type)
 {
-    if (qt_appType == QApplication::Tty) {
-        qWarning("QPixmap: Cannot create a QPixmap when no GUI is being used");
-        data = 0;
-        return;
-    }
-
     if ((w > 0 && h > 0) || type == QPixmapData::BitmapType)
         data = QPixmapData::create(w, h, (QPixmapData::PixelType) type);
     else
diff --git a/src/gui/image/qpixmap_raster.cpp b/src/gui/image/qpixmap_raster.cpp
index 7163656f55..eccafd1671 100644
--- a/src/gui/image/qpixmap_raster.cpp
+++ b/src/gui/image/qpixmap_raster.cpp
@@ -47,6 +47,7 @@
 #include "qnativeimage_p.h"
 #include "qimage_p.h"
 #include "qpaintengine.h"
+#include "kernel/qapplication_p.h"
 
 #include "qbitmap.h"
 #include "qimage.h"
@@ -115,8 +116,10 @@ void QRasterPixmapData::resize(int width, int height)
 #else
     if (pixelType() == BitmapType)
         format = QImage::Format_MonoLSB;
-    else
+    else if (qt_is_gui_used)
         format = QNativeImage::systemFormat();
+    else
+        format = QImage::Format_RGB32;
 #endif
 
     image = QImage(width, height, format);
@@ -432,7 +435,7 @@ void QRasterPixmapData::createPixmapForImage(QImage &sourceImage, Qt::ImageConve
                     ? QImage::Format_ARGB32_Premultiplied
                     : QImage::Format_RGB32;
         } else {
-            QImage::Format opaqueFormat = QNativeImage::systemFormat();
+            QImage::Format opaqueFormat = qt_is_gui_used ? QNativeImage::systemFormat() : QImage::Format_RGB32;
             QImage::Format alphaFormat = QImage::Format_ARGB32_Premultiplied;
 
 #if !defined(QT_HAVE_NEON) && !defined(QT_ALWAYS_HAVE_SSE2)
diff --git a/src/gui/kernel/qapplication_x11.cpp b/src/gui/kernel/qapplication_x11.cpp
index 400b99d440..2b554e5277 100644
--- a/src/gui/kernel/qapplication_x11.cpp
+++ b/src/gui/kernel/qapplication_x11.cpp
@@ -2282,6 +2282,8 @@ void qt_init(QApplicationPrivate *priv, int,
         QSegfaultHandler::initialize(priv->argv, priv->argc);
 #endif
         QCursorData::initialize();
+    } else if (!QApplicationPrivate::graphics_system_name.isNull()) {
+        QApplicationPrivate::graphics_system = QGraphicsSystemFactory::create(QApplicationPrivate::graphics_system_name);
     }
     QFont::initialize();
 
diff --git a/src/gui/kernel/qguiplatformplugin.cpp b/src/gui/kernel/qguiplatformplugin.cpp
index 1b1a863e6d..1b154fa8c6 100644
--- a/src/gui/kernel/qguiplatformplugin.cpp
+++ b/src/gui/kernel/qguiplatformplugin.cpp
@@ -85,7 +85,7 @@ QGuiPlatformPlugin *qt_guiPlatformPlugin()
 
         QString key = QString::fromLocal8Bit(qgetenv("QT_PLATFORM_PLUGIN"));
 #ifdef Q_WS_X11
-        if (key.isEmpty()) {
+        if (QApplication::type() != QApplication::Tty && key.isEmpty()) {
             switch(X11->desktopEnvironment) {
             case DE_KDE:
                 key = QString::fromLatin1("kde");
diff --git a/src/gui/painting/qpaintengine.h b/src/gui/painting/qpaintengine.h
index e8b6b900fe..c02b638ed9 100644
--- a/src/gui/painting/qpaintengine.h
+++ b/src/gui/painting/qpaintengine.h
@@ -45,6 +45,7 @@
 #include <QtCore/qnamespace.h>
 #include <QtCore/qobjectdefs.h>
 #include <QtCore/qscopedpointer.h>
+#include <QtCore/qurl.h>
 #include <QtGui/qpainter.h>
 
 QT_BEGIN_HEADER
@@ -162,6 +163,19 @@ public:
     virtual void drawRects(const QRect *rects, int rectCount);
     virtual void drawRects(const QRectF *rects, int rectCount);
 
+    virtual void addHyperlink(const QRectF &r, const QUrl &url) {Q_UNUSED(r); Q_UNUSED(url);}
+    virtual void addAnchor(const QRectF &r, const QString &name) {Q_UNUSED(r); Q_UNUSED(name);}
+    virtual void addLink(const QRectF &r, const QString &anchor) {Q_UNUSED(r); Q_UNUSED(anchor);}
+    virtual void addTextField(const QRectF &r, const QString &text, const QString &name, bool multiLine, bool password, bool readOnly, int maxLength) {
+        Q_UNUSED(r); Q_UNUSED(text); Q_UNUSED(name); Q_UNUSED(multiLine); Q_UNUSED(password); Q_UNUSED(readOnly); Q_UNUSED(maxLength);
+    }
+    virtual void addCheckBox(const QRectF &r, bool checked, const QString &name, bool readOnly) {
+        Q_UNUSED(r); Q_UNUSED(checked); Q_UNUSED(name); Q_UNUSED(readOnly);
+    }
+    virtual void addRadioButton(const QRectF &r, const QString & group="", bool checked=false, const QString &name="", bool readOnly=false) {
+        Q_UNUSED(r); Q_UNUSED(checked); Q_UNUSED(name); Q_UNUSED(readOnly); Q_UNUSED(group);
+    }
+
     virtual void drawLines(const QLine *lines, int lineCount);
     virtual void drawLines(const QLineF *lines, int lineCount);
 
@@ -177,6 +191,10 @@ public:
     virtual void drawPolygon(const QPoint *points, int pointCount, PolygonDrawMode mode);
 
     virtual void drawPixmap(const QRectF &r, const QPixmap &pm, const QRectF &sr) = 0;
+    virtual void drawPixmap(const QRectF &r, const QPixmap &pm, const QRectF &sr, const QByteArray * data) {
+		Q_UNUSED(data);
+		drawPixmap(r,pm,sr);
+	}
     virtual void drawTextItem(const QPointF &p, const QTextItem &textItem);
     virtual void drawTiledPixmap(const QRectF &r, const QPixmap &pixmap, const QPointF &s);
     virtual void drawImage(const QRectF &r, const QImage &pm, const QRectF &sr,
diff --git a/src/gui/painting/qpaintengine_mac.cpp b/src/gui/painting/qpaintengine_mac.cpp
index 4aa0668c63..62d866ef00 100644
--- a/src/gui/painting/qpaintengine_mac.cpp
+++ b/src/gui/painting/qpaintengine_mac.cpp
@@ -341,13 +341,7 @@ CGColorSpaceRef QCoreGraphicsPaintEngine::macDisplayColorSpace(const QWidget *wi
 
     // Get the color space from the display profile.
     CGColorSpaceRef colorSpace = 0;
-    CMProfileRef displayProfile = 0;
-    CMError err = CMGetProfileByAVID((CMDisplayIDType)displayID, &displayProfile);
-    if (err == noErr) {
-        colorSpace = CGColorSpaceCreateWithPlatformColorSpace(displayProfile);
-        CMCloseProfile(displayProfile);
-    }
-
+    colorSpace = CGDisplayCopyColorSpace(displayID);
     // Fallback: use generic DeviceRGB
     if (colorSpace == 0)
         colorSpace = CGColorSpaceCreateDeviceRGB();
diff --git a/src/gui/painting/qpaintengine_raster.cpp b/src/gui/painting/qpaintengine_raster.cpp
index 78f899cc94..e651fcd598 100644
--- a/src/gui/painting/qpaintengine_raster.cpp
+++ b/src/gui/painting/qpaintengine_raster.cpp
@@ -2243,11 +2243,11 @@ namespace {
 /*!
     \reimp
 */
-void QRasterPaintEngine::drawImage(const QRectF &r, const QImage &img, const QRectF &sr,
+void QRasterPaintEngine::drawImage(const QRectF &r, const QImage &_img, const QRectF &_sr,
                                    Qt::ImageConversionFlags)
 {
 #ifdef QT_DEBUG_DRAW
-    qDebug() << " - QRasterPaintEngine::drawImage(), r=" << r << " sr=" << sr << " image=" << img.size() << "depth=" << img.depth();
+    qDebug() << " - QRasterPaintEngine::drawImage(), r=" << r << " sr=" << _sr << " image=" << _img.size() << "depth=" << img.depth();
 #endif
 
     if (r.isEmpty())
@@ -2255,6 +2255,17 @@ void QRasterPaintEngine::drawImage(const QRectF &r, const QImage &img, const QRe
 
     Q_D(QRasterPaintEngine);
     QRasterPaintEngineState *s = state();
+    
+    QImage img;
+    QRectF sr=_sr;
+    if (s->matrix.isAffine()) {
+        img = _img.copy(sr.toRect()).scaled(
+            s->matrix.mapRect(r).size().toSize(), Qt::IgnoreAspectRatio, Qt::SmoothTransformation);
+        sr = img.rect();
+    } else {
+        img=_img;
+    }
+ 
     int sr_l = qFloor(sr.left());
     int sr_r = qCeil(sr.right()) - 1;
     int sr_t = qFloor(sr.top());
diff --git a/src/gui/painting/qpainter.cpp b/src/gui/painting/qpainter.cpp
index f7066ff333..924e02c1c0 100644
--- a/src/gui/painting/qpainter.cpp
+++ b/src/gui/painting/qpainter.cpp
@@ -5393,7 +5393,7 @@ void QPainter::drawPixmap(const QPointF &p, const QPixmap &pm)
     }
 }
 
-void QPainter::drawPixmap(const QRectF &r, const QPixmap &pm, const QRectF &sr)
+void QPainter::drawPixmap(const QRectF &r, const QPixmap &pm, const QRectF &sr, const QByteArray * data)
 {
 #if defined QT_DEBUG_DRAW
     if (qt_show_painter_debug_output)
@@ -5518,7 +5518,7 @@ void QPainter::drawPixmap(const QRectF &r, const QPixmap &pm, const QRectF &sr)
             x += d->state->matrix.dx();
             y += d->state->matrix.dy();
         }
-        d->engine->drawPixmap(QRectF(x, y, w, h), pm, QRectF(sx, sy, sw, sh));
+        d->engine->drawPixmap(QRectF(x, y, w, h), pm, QRectF(sx, sy, sw, sh), data);
     }
 }
 
@@ -7254,6 +7254,200 @@ void QPainter::fillRect(const QRectF &r, const QColor &color)
     \since 4.5
 */
 
+
+/*!
+    \fn void QPainter::addAnchor(int x, int y, int w, int h, const QString &name);
+
+    \overload
+
+    Add an anchor to the current page at the rect specified by \a x, \a y, \a w and \a h  
+    named \a name.
+
+    Note that for output formats not supporting links, currently all other then PDF,
+    this call has no effect.
+
+    \sa addLink()
+
+    \since 4.7
+*/
+
+/*!
+    \fn void QPainter::addAnchor(const QRect &r, const QString &name);
+
+    \overload
+
+    Add an anchor to the current page at the rect specified by \a r named \a name.
+
+    Note that for output formats not supporting links, currently all other then PDF,
+    this call has no effect.
+
+    \sa addLink()
+
+    \since 4.7
+*/
+
+/*!
+    \fn void addAnchor(const QRectF &r, const QString &name);
+
+    \overload
+
+    Add an anchor to the current page at the rect specified by \a r named \a name.
+
+    Note that for output formats not supporting links, currently all other then PDF,
+    this call has no effect.
+
+    \sa addLink()
+
+    \since 4.7
+*/
+void QPainter::addAnchor(const QRectF &r, const QString &name)
+{
+    Q_D(QPainter);
+    if (!d->engine) {
+        qWarning("QPainter::addAnchor: Painter not active");
+        return;
+    }
+    d->engine->addAnchor(worldTransform().mapRect(r), name);
+}
+
+/*!
+    \fn void QPainter::addLink(int x, int y, int w, int h, const QString &anchor);
+
+    \overload
+
+    Add a link to the current page at the rect specified by \a x, \a y, \a w and \a h  
+    linking to the anchor named \a anchor.
+
+    Note that for output formats not supporting links, currently all other then PDF,
+    this call has no effect.
+
+    \sa addAnchor()
+
+    \since 4.7
+*/
+
+/*!
+    \fn void QPainter::addLink(const QRect &r, const QString &anchor);
+
+    \overload
+
+    Add a link to the current page at the rect specified by \a r  
+    linking to the anchor named \a anchor.
+
+    Note that for output formats not supporting links, currently all other then PDF,
+    this call has no effect.
+
+    \sa addAnchor()
+
+    \since 4.7
+*/
+
+/*!
+    \fn void QPainter::addLink(const QRectF &r, const QString &anchor);
+
+    \overload
+
+    Add a link to the current page at the rect specified by \a r  
+    linking to the anchor named \a anchor.
+
+    Note that for output formats not supporting links, currently all other then PDF,
+    this call has no effect.
+
+    \sa addAnchor()
+
+    \since 4.7
+*/
+void QPainter::addLink(const QRectF &r, const QString &anchor)
+{
+    Q_D(QPainter);
+    if (!d->engine) {
+        qWarning("QPainter::addLink: Painter not active");
+        return;
+    }
+    
+    d->engine->addLink(worldTransform().mapRect(r), anchor);
+}
+
+
+/*!
+    \fn void QPainter::addHyperlink(int x, int y, int w, int h, const QUrl &url);
+
+    \overload
+
+    Add a link to the current page at the rect specified by \a x, \a y, \a w and \a h  
+    linking to \a url.
+
+    Note that for output formats not supporting links, currently all other then PDF,
+    this call has no effect.
+
+    \since 4.7
+*/
+
+/*!
+    \fn void QPainter::addHyperlink(const QRect &r, const QUrl &url);
+
+    \overload
+
+    Add a link to the current page at the rect specified by \a r
+    linking to \a url.
+
+    Note that for output formats not supporting links, currently all other then PDF,
+    this call has no effect.
+
+    \since 4.7
+*/
+
+/*!
+    \fn void QPainter::addHyperlink(const QRectF &r, const QUrl &url);
+
+    \overload
+
+    Add a link to the current page at the rect specified by \a r
+    linking to \a url.
+
+    Note that for output formats not supporting links, currently all other then PDF,
+    this call has no effect.
+
+    \since 4.7
+*/
+void QPainter::addHyperlink(const QRectF &r, const QUrl &url)
+{
+    Q_D(QPainter);
+    if (!d->engine) {
+        qWarning("QPainter::addHyperlink: Painter not active");
+        return;
+    }
+    d->engine->addHyperlink(worldTransform().mapRect(r), url);
+}
+
+void QPainter::addTextField(const QRectF &r, const QString &text, const QString &name, bool multiLine, bool password, bool readOnly, int maxLength) {
+    Q_D(QPainter);
+    if (!d->engine) {
+        qWarning("QPainter::addTextField: Painter not active");
+        return;
+    }
+    d->engine->addTextField(worldTransform().mapRect(r), text, name, multiLine, password, readOnly, maxLength);
+}
+
+void QPainter::addCheckBox(const QRectF &r, bool checked, const QString &name, bool readOnly) {
+    Q_D(QPainter);
+    if (!d->engine) {
+        qWarning("QPainter::addCheckBox: Painter not active");
+        return;
+    }
+    d->engine->addCheckBox(worldTransform().mapRect(r), checked, name, readOnly);
+}
+
+
+void QPainter::addRadioButton(const QRectF &r, const QString & group, bool checked, const QString &name, bool readOnly) {
+    Q_D(QPainter);
+    if (!d->engine) {
+        qWarning("QPainter::addRadioButton: Painter not active");
+        return;
+    }
+    d->engine->addRadioButton(worldTransform().mapRect(r), group, checked, name, readOnly);
+}
+
 /*!
     Sets the given render \a hint on the painter if \a on is true;
     otherwise clears the render hint.
diff --git a/src/gui/painting/qpainter.h b/src/gui/painting/qpainter.h
index 76f07c2c12..cfba5f60f4 100644
--- a/src/gui/painting/qpainter.h
+++ b/src/gui/painting/qpainter.h
@@ -364,7 +364,7 @@ public:
     inline void drawPicture(const QPoint &p, const QPicture &picture);
 #endif
 
-    void drawPixmap(const QRectF &targetRect, const QPixmap &pixmap, const QRectF &sourceRect);
+    void drawPixmap(const QRectF &targetRect, const QPixmap &pixmap, const QRectF &sourceRect, const QByteArray * data=0);
     inline void drawPixmap(const QRect &targetRect, const QPixmap &pixmap, const QRect &sourceRect);
     inline void drawPixmap(int x, int y, int w, int h, const QPixmap &pm,
                            int sx, int sy, int sw, int sh);
@@ -447,6 +447,22 @@ public:
     inline void fillRect(const QRect &r, Qt::BrushStyle style);
     inline void fillRect(const QRectF &r, Qt::BrushStyle style);
 
+    inline void addAnchor(int x, int y, int w, int h, const QString &name);
+    inline void addAnchor(const QRect &r, const QString &name);
+    void addAnchor(const QRectF &r, const QString &name);
+
+    inline void addLink(int x, int y, int w, int h, const QString &anchor);
+    inline void addLink(const QRect &r, const QString &anchor);
+    void addLink(const QRectF &r, const QString &anchor);
+    
+    void addTextField(const QRectF &r, const QString &text="", const QString &name="", bool multiLine=false, bool password=false, bool readOnly=false, int maxLength=-1);
+    void addCheckBox(const QRectF &r, bool checked=false, const QString &name="", bool readOnly=false);
+    void addRadioButton(const QRectF &r, const QString & group="",  bool checked=false, const QString &name="", bool readOnly=false);;
+
+    inline void addHyperlink(int x, int y, int w, int h, const QUrl &url);
+    inline void addHyperlink(const QRect &r, const QUrl &url);
+    void addHyperlink(const QRectF &r, const QUrl &url);
+    
     void eraseRect(const QRectF &);
     inline void eraseRect(int x, int y, int w, int h);
     inline void eraseRect(const QRect &);
@@ -821,6 +837,35 @@ inline void QPainter::fillRect(const QRectF &r, Qt::BrushStyle style)
     fillRect(r, QBrush(style));
 }
 
+inline void QPainter::addAnchor(int x, int y, int w, int h, const QString &name) 
+{
+    addAnchor(QRectF(x, y, w, h), name);
+}
+
+inline void QPainter::addAnchor(const QRect &r, const QString &name)
+{
+    addAnchor(QRectF(r), name);
+}
+
+inline void QPainter::addLink(int x, int y, int w, int h, const QString &anchor)
+{
+    addLink(QRectF(x, y, w, h), anchor);
+}
+
+inline void QPainter::addLink(const QRect &r, const QString &anchor)
+{
+    addLink(QRectF(r), anchor);
+}
+
+inline void QPainter::addHyperlink(int x, int y, int w, int h, const QUrl &url)
+{
+    addHyperlink(QRectF(x, y, w, h), url);
+}
+
+inline void QPainter::addHyperlink(const QRect &r, const QUrl &url)
+{
+    addHyperlink(QRectF(r), url);
+}
 
 inline void QPainter::setBrushOrigin(int x, int y)
 {
diff --git a/src/gui/painting/qprintengine.h b/src/gui/painting/qprintengine.h
index ad00816de8..995545a313 100644
--- a/src/gui/painting/qprintengine.h
+++ b/src/gui/painting/qprintengine.h
@@ -90,6 +90,10 @@ public:
         PPK_SupportsMultipleCopies,
         PPK_PaperSize = PPK_PageSize,
 
+        PPK_UseCompression = 0xfe10,
+        PPK_ImageQuality,
+        PPK_ImageDPI,
+
         PPK_CustomBase = 0xff00
     };
 
@@ -97,6 +101,8 @@ public:
     virtual QVariant property(PrintEnginePropertyKey key) const = 0;
 
     virtual bool newPage() = 0;
+    virtual void beginSectionOutline(const QString &text, const QString &anchor) {Q_UNUSED(text); Q_UNUSED(anchor);}
+    virtual void endSectionOutline() {}
     virtual bool abort() = 0;
 
     virtual int metric(QPaintDevice::PaintDeviceMetric) const = 0;
diff --git a/src/gui/painting/qprintengine_pdf.cpp b/src/gui/painting/qprintengine_pdf.cpp
index e21de2f4c2..f6d6e1cc34 100644
--- a/src/gui/painting/qprintengine_pdf.cpp
+++ b/src/gui/painting/qprintengine_pdf.cpp
@@ -1,7 +1,7 @@
 /****************************************************************************
 **
-** Copyright (C) 2015 The Qt Company Ltd.
-** Contact: http://www.qt.io/licensing/
+** Copyright (C) 2014 Digia Plc and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/legal
 **
 ** This file is part of the QtGui module of the Qt Toolkit.
 **
@@ -10,21 +10,20 @@
 ** Licensees holding valid commercial Qt licenses may use this file in
 ** accordance with the commercial license agreement provided with the
 ** Software or, alternatively, in accordance with the terms contained in
-** a written agreement between you and The Qt Company. For licensing terms
-** and conditions see http://www.qt.io/terms-conditions. For further
-** information use the contact form at http://www.qt.io/contact-us.
+** a written agreement between you and Digia.  For licensing terms and
+** conditions see http://qt.digia.com/licensing.  For further information
+** use the contact form at http://qt.digia.com/contact-us.
 **
 ** GNU Lesser General Public License Usage
 ** Alternatively, this file may be used under the terms of the GNU Lesser
-** General Public License version 2.1 or version 3 as published by the Free
-** Software Foundation and appearing in the file LICENSE.LGPLv21 and
-** LICENSE.LGPLv3 included in the packaging of this file. Please review the
-** following information to ensure the GNU Lesser General Public License
-** requirements will be met: https://www.gnu.org/licenses/lgpl.html and
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+** General Public License version 2.1 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL included in the
+** packaging of this file.  Please review the following information to
+** ensure the GNU Lesser General Public License version 2.1 requirements
+** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
 **
-** As a special exception, The Qt Company gives you certain additional
-** rights. These rights are described in The Qt Company LGPL Exception
+** In addition, as a special exception, Digia gives you certain additional
+** rights.  These rights are described in the Digia Qt LGPL Exception
 ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
 **
 ** GNU General Public License Usage
@@ -35,6 +34,7 @@
 ** ensure the GNU General Public License version 3.0 requirements will be
 ** met: http://www.gnu.org/copyleft/gpl.html.
 **
+**
 ** $QT_END_LICENSE$
 **
 ****************************************************************************/
@@ -51,6 +51,7 @@
 #include <qimagewriter.h>
 #include <qbuffer.h>
 #include <qdatetime.h>
+#include <QCryptographicHash>
 
 #ifndef QT_NO_PRINTER
 #include <limits.h>
@@ -77,12 +78,6 @@ extern qint64 qt_image_id(const QImage &image);
 // Can't use it though, as gs generates completely wrong images if this is true.
 static const bool interpolateImages = false;
 
-#ifdef QT_NO_COMPRESS
-static const bool do_compress = false;
-#else
-static const bool do_compress = true;
-#endif
-
 QPdfPage::QPdfPage()
     : QPdf::ByteStream(true) // Enable file backing
 {
@@ -109,6 +104,30 @@ inline QPaintEngine::PaintEngineFeatures qt_pdf_decide_features()
     return f;
 }
 
+void QPdfEngine::setProperty(PrintEnginePropertyKey key, const QVariant &value) {
+    Q_D(QPdfEngine);
+    if (key==PPK_UseCompression)
+        d->doCompress = value.toBool();
+    else if (key==PPK_ImageQuality)
+        d->imageQuality = value.toInt();
+    else if (key==PPK_ImageDPI)
+        d->imageDPI = value.toInt();
+    else
+        QPdfBaseEngine::setProperty(key, value);
+}
+
+QVariant QPdfEngine::property(PrintEnginePropertyKey key) const {
+    Q_D(const QPdfEngine);
+    if (key==PPK_UseCompression)
+        return d->doCompress;
+    else if (key==PPK_ImageQuality)
+        return d->imageQuality;
+    else if (key==PPK_ImageDPI)
+        return d->imageDPI;
+    else
+        return QPdfBaseEngine::property(key);
+}
+
 QPdfEngine::QPdfEngine(QPrinter::PrinterMode m)
     : QPdfBaseEngine(*new QPdfEnginePrivate(m), qt_pdf_decide_features())
 {
@@ -156,6 +175,60 @@ bool QPdfEngine::begin(QPaintDevice *pdev)
 bool QPdfEngine::end()
 {
     Q_D(QPdfEngine);
+
+    uint dests;
+    if (d->anchors.size()) {
+        dests = d->addXrefEntry(-1);
+        d->xprintf("<<\n");
+        for (QHash<QString, uint>::iterator i=d->anchors.begin();
+             i != d->anchors.end(); ++i) {
+            d->printAnchor(i.key());
+            d->xprintf(" %d 0 R\n", i.value());
+        }
+        d->xprintf(">>\nendobj\n");
+    }
+
+    if (d->outlineRoot) {
+        d->outlineRoot->obj = d->requestObject();
+        d->writeOutlineChildren(d->outlineRoot);
+        d->addXrefEntry(d->outlineRoot->obj);
+        d->xprintf("<</Type /Outlines /First %d 0 R\n/Last %d 0 R>>\nendobj\n",
+                   d->outlineRoot->firstChild->obj, d->outlineRoot->lastChild->obj);
+    }
+
+    if (d->formFields.size()) {
+        uint font = d->addXrefEntry(-1);
+        d->xprintf("<</Type/Font/Name/Helv/BaseFont/Helvetica/Subtype/Type1>>\n"
+                   "endobj\n");
+        d->addXrefEntry(d->formFieldList);
+        d->xprintf("<</Fields[");
+        foreach(const uint & i, d->formFields)
+           d->xprintf("%d 0 R ",i);
+        d->xprintf("]\n"
+                   "/DR<</Font<</Helv %d 0 R>>>>\n"
+                   "/DA(/Helv 0 Tf 0 g)\n"
+                   "/NeedAppearances true\n"
+                   ">>\n"
+                   "endobj\n", font);
+    }
+
+    d->catalog = d->addXrefEntry(-1);
+    d->xprintf("<<\n"
+               "/Type /Catalog\n"
+               "/Pages %d 0 R\n", d->pageRoot);
+    if (d->outlineRoot)
+        d->xprintf("/Outlines %d 0 R\n"
+                   "/PageMode /UseOutlines\n", d->outlineRoot->obj);
+
+    if (d->formFields.size())
+        d->xprintf("/AcroForm %d 0 R\n", d->formFieldList);
+
+    if (d->anchors.size())
+        d->xprintf("/Dests %d 0 R\n", dests);
+
+    d->xprintf(">>\n"
+               "endobj\n");
+
     d->writeTail();
 
     d->stream->unsetDevice();
@@ -165,8 +238,84 @@ bool QPdfEngine::end()
     return true;
 }
 
+void QPdfEngine::addCheckBox(const QRectF &r, bool checked, const QString &name, bool readOnly) {
+    Q_D(QPdfEngine);
+    uint obj = d->addXrefEntry(-1);
+    char buf[256];
+    QRectF rr = d->pageMatrix().mapRect(r);
+    if (d->formFieldList == -1) d->formFieldList = d->requestObject();
+    d->xprintf("<<\n"
+               "/Type /Annot\n"
+               "/Parent %d 0 R\n"
+               "/F 4\n"
+               "/Rect[", d->formFieldList);
+    d->xprintf("%s ", qt_real_to_string(rr.left(),buf));
+    d->xprintf("%s ", qt_real_to_string(rr.top(),buf));
+    d->xprintf("%s ", qt_real_to_string(rr.right(),buf));
+    d->xprintf("%s", qt_real_to_string(rr.bottom(),buf));
+    d->xprintf("]\n"
+               "/FT/Btn\n"
+               "/Subtype/Widget\n"
+               "/P %d 0 R\n", d->pages.back());
+    if (checked)
+        d->xprintf("/AS /Yes\n");
+    if (!name.isEmpty()) {
+        d->xprintf("/T");
+        d->printString(name);
+        d->xprintf("\n");
+    }
+    d->xprintf("/Ff %d\n"
+               ">>\n"
+               "endobj\n",
+               (readOnly?1:0)<<0);
+    d->currentPage->annotations.push_back(obj);
+    d->formFields.push_back(obj);
+}
+
+void QPdfEngine::addTextField(const QRectF &r, const QString &text, const QString &name, bool multiLine, bool password, bool readOnly, int maxLength)
+{
+    Q_D(QPdfEngine);
+    uint obj = d->addXrefEntry(-1);
+    char buf[256];
+    QRectF rr = d->pageMatrix().mapRect(r);
+    if (d->formFieldList == -1) d->formFieldList = d->requestObject();
+    d->xprintf("<<\n"
+               "/Type /Annot\n"
+               "/Parent %d 0 R\n"
+               "/F 4\n"
+               "/Rect[", d->formFieldList);
+    d->xprintf("%s ", qt_real_to_string(rr.left(),buf));
+    d->xprintf("%s ", qt_real_to_string(rr.top(),buf));
+    d->xprintf("%s ", qt_real_to_string(rr.right(),buf));
+    d->xprintf("%s", qt_real_to_string(rr.bottom(),buf));
+    d->xprintf("]\n"
+               "/BS<</S/I>>\n"
+               "/FT/Tx\n"
+               "/Subtype/Widget\n"
+               "/P %d 0 R\n", d->pages.back());
+    if (!text.isEmpty()) {
+        d->xprintf("/V");
+        d->printString(text);
+        d->xprintf("\n");
+    }
+    if (!name.isEmpty()) {
+        d->xprintf("/T");
+        d->printString(name);
+        d->xprintf("\n");
+    }
+    if (maxLength >= 0)
+        d->xprintf("/MaxLen %d\n",maxLength);
+    d->xprintf("/DA(/Helv 12 Tf 0 g)\n"
+               "/Ff %d\n"
+               ">>\n"
+               "endobj\n",
+               (readOnly?1:0)<<0 | (password?1:0)<<13 | (multiLine?1:0)<<12
+        );
+    d->currentPage->annotations.push_back(obj);
+    d->formFields.push_back(obj);
+}
 
-void QPdfEngine::drawPixmap (const QRectF &rectangle, const QPixmap &pixmap, const QRectF &sr)
+void QPdfEngine::drawPixmap (const QRectF &rectangle, const QPixmap &pixmap, const QRectF &sr, const QByteArray * data)
 {
     if (sr.isEmpty() || rectangle.isEmpty() || pixmap.isNull())
         return;
@@ -176,22 +325,35 @@ void QPdfEngine::drawPixmap (const QRectF &rectangle, const QPixmap &pixmap, con
 
     QRect sourceRect = sr.toRect();
     QPixmap pm = sourceRect != pixmap.rect() ? pixmap.copy(sourceRect) : pixmap;
-    QImage image = pm.toImage();
+    QImage unscaled = pm.toImage();
+    QImage image = unscaled;
+
+    QRectF a = d->stroker.matrix.mapRect(rectangle);
+    QRectF c = d->paperRect();
+    int maxWidth = int(a.width() / c.width() * d->width() / 72.0 * d->imageDPI);
+    int maxHeight = int(a.height() / c.height() * d->height() / 72.0 * d->imageDPI);
+    if (image.width() > maxWidth || image.height() > maxHeight)
+        image = unscaled.scaled( image.size().boundedTo( QSize(maxWidth, maxHeight) ), Qt::IgnoreAspectRatio, Qt::SmoothTransformation);
+
+    bool useScaled=true;
     bool bitmap = true;
-    const int object = d->addImage(image, &bitmap, pm.cacheKey());
+    const int object = d->addImage(image, &bitmap, pm.cacheKey(), &unscaled, (sr == pixmap.rect()?data:0), &useScaled );
+    int width = useScaled?image.width():unscaled.width();
+    int height = useScaled?image.height():unscaled.height();
+
     if (object < 0)
         return;
 
     *d->currentPage << "q\n/GSa gs\n";
     *d->currentPage
-        << QPdf::generateMatrix(QTransform(rectangle.width() / sr.width(), 0, 0, rectangle.height() / sr.height(),
+        << QPdf::generateMatrix(QTransform(rectangle.width() / width, 0, 0, rectangle.height() / height,
                                            rectangle.x(), rectangle.y()) * (d->simplePen ? QTransform() : d->stroker.matrix));
     if (bitmap) {
         // set current pen as d->brush
         d->brush = d->pen.brush();
     }
     setBrush();
-    d->currentPage->streamImage(image.width(), image.height(), object);
+    d->currentPage->streamImage(width, height, object);
     *d->currentPage << "Q\n";
 
     d->brush = b;
@@ -301,18 +463,68 @@ QPdfEnginePrivate::QPdfEnginePrivate(QPrinter::PrinterMode m)
     : QPdfBaseEnginePrivate(m)
 {
     streampos = 0;
-
+    doCompress = true;
+    imageDPI = 1400;
+    imageQuality = 94;
     stream = new QDataStream;
     pageOrder = QPrinter::FirstPageFirst;
     orientation = QPrinter::Portrait;
+    outlineRoot = NULL;
+    outlineCurrent = NULL;
     fullPage = false;
 }
 
 QPdfEnginePrivate::~QPdfEnginePrivate()
 {
+    if (outlineRoot)
+      delete outlineRoot;
     delete stream;
 }
 
+void QPdfEnginePrivate::printAnchor(const QString &name) {
+    QByteArray a = name.toUtf8();
+    if (a.size() >= 127)
+        a = QCryptographicHash::hash(a,QCryptographicHash::Sha1);
+    xprintf("/");
+    for (int i=0; i < a.size(); ++i) {
+        unsigned char c = a[i];
+        if (('a' <= c && c <= 'z') ||
+            ('A' <= c && c <= 'Z') ||
+            ('0' <= c && c <= '9') ||
+            c == '.' || c == '_')
+            xprintf("%c", c);
+        else if(c == 0)
+            xprintf("!");
+        else
+            xprintf("#%02x", c);
+    }
+}
+
+void QPdfEnginePrivate::writeOutlineChildren(OutlineItem * node) {
+    for (OutlineItem * i = node->firstChild; i != NULL; i = i->next)
+       i->obj = requestObject();
+    for (OutlineItem * i = node->firstChild; i != NULL; i = i->next) {
+       QPdfEnginePrivate::writeOutlineChildren(i);
+       addXrefEntry(i->obj);
+       xprintf("<</Title ");
+       printString(i->text);
+       xprintf("\n"
+               "  /Parent %d 0 R\n"
+               "  /Dest ", i->parent->obj);
+       printAnchor(i->anchor);
+       xprintf("\n  /Count 0\n");
+       if (i->next)
+           xprintf("  /Next %d 0 R\n", i->next->obj);
+       if (i->prev)
+           xprintf("  /Prev %d 0 R\n", i->prev->obj);
+       if (i->firstChild)
+           xprintf("  /First %d 0 R\n", i->firstChild->obj);
+       if (i->lastChild)
+           xprintf("  /Last %d 0 R\n", i->lastChild->obj);
+       xprintf(">>\n"
+               "endobj\n");
+    }
+}
 
 #ifdef USE_NATIVE_GRADIENTS
 int QPdfEnginePrivate::gradientBrush(const QBrush &b, const QMatrix &matrix, int *gStateObject)
@@ -398,7 +610,7 @@ int QPdfEnginePrivate::gradientBrush(const QBrush &b, const QMatrix &matrix, int
                 ">>\n"
                 "stream\n"
               << content
-              << "endstream\n"
+              << "\nendstream\n"
                 "endobj\n";
 
             int softMaskFormObject = addXrefEntry(-1);
@@ -520,10 +732,121 @@ int QPdfEnginePrivate::addBrushPattern(const QTransform &m, bool *specifyColor,
     return patternObj;
 }
 
+
+void QPdfEnginePrivate::convertImage(const QImage & image, QByteArray & imageData) {
+    int w = image.width();
+    int h = image.height();
+    imageData.resize(colorMode == QPrinter::GrayScale ? w * h : 3 * w * h);
+    uchar *data = (uchar *)imageData.data();
+    for (int y = 0; y < h; ++y) {
+        const QRgb *rgb = (const QRgb *)image.scanLine(y);
+        if (colorMode == QPrinter::GrayScale) {
+            for (int x = 0; x < w; ++x) {
+                *(data++) = qGray(*rgb);
+                ++rgb;
+            }
+        } else if (image.format() == QImage::Format_ARGB32_Premultiplied) {
+            for (int x = 0; x < w; ++x) {
+                double multiplier = (qAlpha(*rgb) / 255.0) == 0 ? 0 : 1.0 / (qAlpha(*rgb) / 255.0);
+                *(data++) = qRed(*rgb) * multiplier;
+                *(data++) = qGreen(*rgb) * multiplier;
+                *(data++) = qBlue(*rgb) * multiplier;
+                ++rgb;
+            }
+        } else {
+            for (int x = 0; x < w; ++x) {
+                *(data++) = qRed(*rgb);
+                *(data++) = qGreen(*rgb);
+                *(data++) = qBlue(*rgb);
+                ++rgb;
+            }
+        }
+    }
+}
+
+#include <iostream>
+
+class jpg_header_reader {
+private:
+  const QByteArray * data;
+  int index;
+
+  class jpeg_exception {};
+
+  unsigned char next() {
+    if (index == data->size()) throw jpeg_exception();
+    return data->data()[index++];
+  }
+
+  void skip() {
+    int l = (next() << 8) + next();
+    if (l < 2) throw jpeg_exception();
+    for (int i=2; i < l; ++i) next();
+  }
+
+  void read_header() {
+    int l = (next() << 8) + next();
+    if (l < 2) throw jpeg_exception();
+    precision = next();
+    height = (next() << 8) + next();
+    width = (next() << 8) + next();
+    components = next();
+    if (l != 8 + components*3) throw jpeg_exception();
+  }
+
+public:
+  bool read(const QByteArray * d) {
+    index=0;
+    data=d;
+    try {
+      if (next() != 0xFF) throw jpeg_exception();
+      unsigned char marker = next();
+      if (marker != 0xD8) throw jpeg_exception();
+      while (true) {
+        marker = next();
+        while (marker != 0xFF) marker=next();
+        while (marker == 0xFF) marker=next();
+        switch(marker) {
+          case 0xC0:   // SOF0 Start Of Frame N - BaseLine
+          case 0xC1:   // SOF1 N indicates which compression process - Extended Sequential
+          case 0xC2:   // SOF2 Only SOF0-SOF2 are now in common use - Progressive
+          case 0xC3:   // SOF3 Lossless
+          case 0xC5:   // SOF5 Differential sequential
+          case 0xC6:   // SOF6 Differential progressive
+          case 0xC7:   // SOF7 Differential lossless
+          case 0xC9:   // SOF9 Extended sequential, arithmetic coding
+          case 0xCA:   // SOF10 Progressive, arithmetic coding
+          case 0xCB:   // SOF11 Lossless, arithmetic coding
+          case 0xCD:   // SOF13 Differential sequential, arithmetic coding
+          case 0xCE:   // SOF14 Differential progressive, arithmetic coding
+          case 0xCF:   // SOF15 Differential lossless, arithmetic coding
+          case 0xE1:   // EXIF/XMP Exif marker.  Also used for XMP data!
+            read_header();
+            return true;
+          case 0xDA:    // SOS Start Of Scan (begins compressed data)
+          case 0xD9:    // EOI End Of Image (end of datastream)
+            return false;
+          default:
+            skip();
+            break;
+          }
+        }
+    } catch(jpeg_exception) {
+      return false;
+    }
+    return true;
+  }
+
+  int precision, height, width, components;
+
+};
+
+
+
 /*!
  * Adds an image to the pdf and return the pdf-object id. Returns -1 if adding the image failed.
  */
-int QPdfEnginePrivate::addImage(const QImage &img, bool *bitmap, qint64 serial_no)
+int QPdfEnginePrivate::addImage(const QImage &img, bool *bitmap, qint64 serial_no, const QImage * noneScaled, const QByteArray * data, bool * useScaled)
 {
     if (img.isNull())
         return -1;
@@ -533,20 +856,24 @@ int QPdfEnginePrivate::addImage(const QImage &img, bool *bitmap, qint64 serial_n
         return object;
 
     QImage image = img;
-    QImage::Format format = image.format();
     if (image.depth() == 1 && *bitmap && img.colorTable().size() == 2
         && img.colorTable().at(0) == QColor(Qt::black).rgba()
         && img.colorTable().at(1) == QColor(Qt::white).rgba())
     {
-        if (format == QImage::Format_MonoLSB)
+        if (image.format() != QImage::Format_Mono)
             image = image.convertToFormat(QImage::Format_Mono);
-        format = QImage::Format_Mono;
     } else {
         *bitmap = false;
-        if (format != QImage::Format_RGB32 && format != QImage::Format_ARGB32) {
+        if (image.format() != QImage::Format_RGB32
+            && image.format() != QImage::Format_ARGB32
+            && image.format() != QImage::Format_ARGB32_Premultiplied)
             image = image.convertToFormat(QImage::Format_ARGB32);
-            format = QImage::Format_ARGB32;
-        }
+    }
+    QImage::Format format = image.format();
+    QImage nonScaledImage;
+    if (noneScaled && noneScaled->format() != format) {
+        nonScaledImage = noneScaled->convertToFormat(format);
+        noneScaled = &nonScaledImage;
     }
 
     int w = image.width();
@@ -564,65 +891,97 @@ int QPdfEnginePrivate::addImage(const QImage &img, bool *bitmap, qint64 serial_n
         }
         object = writeImage(data, w, h, d, 0, 0);
     } else {
-        QByteArray softMaskData;
-        bool dct = false;
         QByteArray imageData;
-        bool hasAlpha = false;
-        bool hasMask = false;
+        uLongf target=1024*1024*1024;
+        bool uns=false;
+        bool dct = false;
+
+        d = (colorMode == QPrinter::GrayScale) ? 8 : 32;
 
         if (QImageWriter::supportedImageFormats().contains("jpeg") && colorMode != QPrinter::GrayScale) {
-            QBuffer buffer(&imageData);
+            QByteArray imageData2;
+
+            QBuffer buffer(&imageData2);
             QImageWriter writer(&buffer, "jpeg");
-            writer.setQuality(94);
+            writer.setQuality(imageQuality);
             writer.write(image);
-            dct = true;
-
-            if (format != QImage::Format_RGB32) {
-                softMaskData.resize(w * h);
-                uchar *sdata = (uchar *)softMaskData.data();
-                for (int y = 0; y < h; ++y) {
-                    const QRgb *rgb = (const QRgb *)image.constScanLine(y);
-                    for (int x = 0; x < w; ++x) {
-                        uchar alpha = qAlpha(*rgb);
-                        *sdata++ = alpha;
-                        hasMask |= (alpha < 255);
-                        hasAlpha |= (alpha != 0 && alpha != 255);
-                        ++rgb;
-                    }
-                }
+
+            if ((uLongf)imageData2.size() < target) {
+                imageData=imageData2;
+                target = imageData2.size();
+                dct = true;
+                uns=false;
             }
-        } else {
-            imageData.resize(colorMode == QPrinter::GrayScale ? w * h : 3 * w * h);
-            uchar *data = (uchar *)imageData.data();
+        }
+
+        if (noneScaled && noneScaled->rect() != image.rect()) {
+            QByteArray imageData2;
+            convertImage(*noneScaled, imageData2);
+            uLongf len = imageData2.size();
+            uLongf destLen = len + len/100 + 13; // zlib requirement
+            Bytef* dest = new Bytef[destLen];
+            if (Z_OK == ::compress(dest, &destLen, (const Bytef*) imageData2.data(), (uLongf)len) &&
+                (uLongf)destLen < target) {
+                imageData=imageData2;
+                target=destLen;
+                dct=false;
+                uns=true;
+            }
+            delete[] dest;
+        }
+
+        {
+            QByteArray imageData2;
+            convertImage(image, imageData2);
+            uLongf len = imageData2.size();
+            uLongf destLen = len + len/100 + 13; // zlib requirement
+            Bytef* dest = new Bytef[destLen];
+            if (Z_OK == ::compress(dest, &destLen, (const Bytef*) imageData2.data(), (uLongf)len) &&
+                (uLongf)destLen < target) {
+                imageData=imageData2;
+                target=destLen;
+                dct=false;
+                uns=false;
+            }
+            delete[] dest;
+        }
+
+
+        if (colorMode != QPrinter::GrayScale && noneScaled != 0 && data != 0) {
+          jpg_header_reader header;
+          if (header.read(data)) {
+            d = header.components == 3?32:8;
+            imageData = *data;
+            target=data->size();
+            dct=true;
+            uns=true;
+          }
+        }
+
+        if (uns) {
+            w = noneScaled->width();
+            h = noneScaled->height();
+        }
+        if (useScaled) *useScaled = (uns?false:true);
+        QByteArray softMaskData;
+        bool hasAlpha = false;
+        bool hasMask = false;
+
+        if (format != QImage::Format_RGB32) {
             softMaskData.resize(w * h);
             uchar *sdata = (uchar *)softMaskData.data();
             for (int y = 0; y < h; ++y) {
-                const QRgb *rgb = (const QRgb *)image.constScanLine(y);
-                if (colorMode == QPrinter::GrayScale) {
-                    for (int x = 0; x < w; ++x) {
-                        *(data++) = qGray(*rgb);
-                        uchar alpha = qAlpha(*rgb);
-                        *sdata++ = alpha;
-                        hasMask |= (alpha < 255);
-                        hasAlpha |= (alpha != 0 && alpha != 255);
-                        ++rgb;
-                    }
-                } else {
-                    for (int x = 0; x < w; ++x) {
-                        *(data++) = qRed(*rgb);
-                        *(data++) = qGreen(*rgb);
-                        *(data++) = qBlue(*rgb);
-                        uchar alpha = qAlpha(*rgb);
-                        *sdata++ = alpha;
-                        hasMask |= (alpha < 255);
-                        hasAlpha |= (alpha != 0 && alpha != 255);
-                        ++rgb;
-                    }
+                const QRgb *rgb = (const QRgb *)(uns?noneScaled->constScanLine(y):image.constScanLine(y));
+                for (int x = 0; x < w; ++x) {
+                    uchar alpha = qAlpha(*rgb);
+                    *sdata++ = alpha;
+                    hasMask |= (alpha < 255);
+                    hasAlpha |= (alpha != 0 && alpha != 255);
+                    ++rgb;
                 }
             }
-            if (format == QImage::Format_RGB32)
-                hasAlpha = hasMask = false;
         }
+
         int maskObject = 0;
         int softMaskObject = 0;
         if (hasAlpha) {
@@ -644,7 +1003,7 @@ int QPdfEnginePrivate::addImage(const QImage &img, bool *bitmap, qint64 serial_n
             }
             maskObject = writeImage(mask, w, h, 1, 0, 0);
         }
-        object = writeImage(imageData, w, h, colorMode == QPrinter::GrayScale ? 8 : 32,
+        object = writeImage(imageData, w, h, d,
                             maskObject, softMaskObject, dct);
     }
     imageCache.insert(serial_no, object);
@@ -758,7 +1117,7 @@ void QPdfEnginePrivate::xprintf(const char* fmt, ...)
 int QPdfEnginePrivate::writeCompressed(QIODevice *dev)
 {
 #ifndef QT_NO_COMPRESS
-    if (do_compress) {
+    if (doCompress) {
         int size = QPdfPage::chunkSize();
         int sum = 0;
         ::z_stream zStruct;
@@ -832,7 +1191,7 @@ int QPdfEnginePrivate::writeCompressed(QIODevice *dev)
 int QPdfEnginePrivate::writeCompressed(const char *src, int len)
 {
 #ifndef QT_NO_COMPRESS
-    if(do_compress) {
+    if(doCompress) {
         uLongf destLen = len + len/100 + 13; // zlib requirement
         Bytef* dest = new Bytef[destLen];
         if (Z_OK == ::compress(dest, &destLen, (const Bytef*) src, (uLongf)len)) {
@@ -885,13 +1244,13 @@ int QPdfEnginePrivate::writeImage(const QByteArray &data, int width, int height,
         write(data);
         len = data.length();
     } else {
-        if (do_compress)
+        if (doCompress)
             xprintf("/Filter /FlateDecode\n>>\nstream\n");
         else
             xprintf(">>\nstream\n");
         len = writeCompressed(data);
     }
-    xprintf("endstream\n"
+    xprintf("\nendstream\n"
             "endobj\n");
     addXrefEntry(lenobj);
     xprintf("%d\n"
@@ -908,14 +1267,9 @@ void QPdfEnginePrivate::writeHeader()
 
     writeInfo();
 
-    catalog = addXrefEntry(-1);
     pageRoot = requestObject();
-    xprintf("<<\n"
-            "/Type /Catalog\n"
-            "/Pages %d 0 R\n"
-            ">>\n"
-            "endobj\n", pageRoot);
 
+    formFieldList = -1;
     // graphics state
     graphicsState = addXrefEntry(-1);
     xprintf("<<\n"
@@ -944,16 +1298,25 @@ void QPdfEnginePrivate::writeInfo()
     printString(creator);
     xprintf("\n/Producer ");
     printString(QString::fromLatin1("Qt " QT_VERSION_STR));
-    QDateTime now = QDateTime::currentDateTime().toUTC();
+    QDateTime now = QDateTime::currentDateTime();
     QTime t = now.time();
     QDate d = now.date();
-    xprintf("\n/CreationDate (D:%d%02d%02d%02d%02d%02d)\n",
+    xprintf("\n/CreationDate (D:%d%02d%02d%02d%02d%02d",
             d.year(),
             d.month(),
             d.day(),
             t.hour(),
             t.minute(),
             t.second());
+    QDateTime fake=now;
+    fake.setTimeSpec(Qt::UTC);
+    int offset = now.secsTo(fake);
+    if (offset == 0)
+        xprintf("Z)\n");
+    else if (offset < 0)
+        xprintf("-%02d'%02d')\n", (-offset)/60/60 , ((-offset)/60) % 60);
+    else if (offset > 0)
+        xprintf("+%02d'%02d')\n", offset/60/60 , (offset/60) % 60);
     xprintf(">>\n"
             "endobj\n");
 }
@@ -1027,7 +1390,7 @@ void QPdfEnginePrivate::embedFont(QFontSubset *font)
             "/CapHeight " << properties.capHeight.toReal()*scale << "\n"
             "/StemV " << properties.lineWidth.toReal()*scale << "\n"
             "/FontFile2 " << fontstream << "0 R\n"
-            ">> endobj\n";
+            ">>\nendobj\n";
         write(descriptor);
     }
     {
@@ -1039,13 +1402,13 @@ void QPdfEnginePrivate::embedFont(QFontSubset *font)
         s << "<<\n"
             "/Length1 " << fontData.size() << "\n"
             "/Length " << length_object << "0 R\n";
-        if (do_compress)
+        if (doCompress)
             s << "/Filter /FlateDecode\n";
         s << ">>\n"
             "stream\n";
         write(header);
         int len = writeCompressed(fontData);
-        write("endstream\n"
+        write("\nendstream\n"
               "endobj\n");
         addXrefEntry(length_object);
         xprintf("%d\n"
@@ -1072,7 +1435,7 @@ void QPdfEnginePrivate::embedFont(QFontSubset *font)
         xprintf("<< /Length %d >>\n"
                 "stream\n", touc.length());
         write(touc);
-        write("endstream\n"
+        write("\nendstream\n"
               "endobj\n");
     }
     {
@@ -1101,6 +1464,101 @@ void QPdfEnginePrivate::writeFonts()
     fonts.clear();
 }
 
+
+void QPdfEngine::addHyperlink(const QRectF &r, const QUrl &url)
+{
+    Q_D(QPdfEngine);
+    char buf[256];
+    QRectF rr = d->pageMatrix().mapRect(r);
+    uint annot = d->addXrefEntry(-1);
+    QByteArray urlascii = url.toString().toLatin1();
+    int len = urlascii.size();
+    char *url_esc = new char[len * 2 + 1];
+    const char * urldata = urlascii.constData();
+    int k = 0;
+    for (int j = 0; j < len; j++, k++){
+        if (urldata[j] == '(' ||
+            urldata[j] == ')' ||
+            urldata[j] == '\\'){
+            url_esc[k] = '\\';
+            k++;
+        }
+        url_esc[k] = urldata[j];
+    }
+    url_esc[k] = 0;
+    d->xprintf("<<\n/Type /Annot\n/Subtype /Link\n/Rect [");
+    d->xprintf("%s ", qt_real_to_string(rr.left(),buf));
+    d->xprintf("%s ", qt_real_to_string(rr.top(),buf));
+    d->xprintf("%s ", qt_real_to_string(rr.right(),buf));
+    d->xprintf("%s", qt_real_to_string(rr.bottom(),buf));
+    d->xprintf("]\n/Border [0 0 0]\n/A <<\n");
+    d->xprintf("/Type /Action\n/S /URI\n/URI (%s)\n", url_esc);
+    d->xprintf(">>\n>>\n");
+    d->xprintf("endobj\n");
+    d->currentPage->annotations.append(annot);
+    delete[] url_esc;
+}
+
+void QPdfEngine::addLink(const QRectF &r, const QString &anchor)
+{
+    Q_D(QPdfEngine);
+    char buf[256];
+    QRectF rr = d->pageMatrix().mapRect(r);
+    uint annot = d->addXrefEntry(-1);
+    d->xprintf("<<\n/Type /Annot\n/Subtype /Link\n/Rect [");
+    d->xprintf("%s ", qt_real_to_string(rr.left(),buf));
+    d->xprintf("%s ", qt_real_to_string(rr.top(),buf));
+    d->xprintf("%s ", qt_real_to_string(rr.right(),buf));
+    d->xprintf("%s", qt_real_to_string(rr.bottom(),buf));
+    d->xprintf("]\n/Border [0 0 0]\n/Dest ");
+    d->printAnchor(anchor);
+    d->xprintf("\n>>\n");
+    d->xprintf("endobj\n");
+    d->currentPage->annotations.append(annot);
+}
+
+void QPdfEngine::addAnchor(const QRectF &r, const QString &name)
+{
+    Q_D(QPdfEngine);
+    char buf[256];
+    QRectF rr = d->pageMatrix().mapRect(r);
+    uint anchor = d->addXrefEntry(-1);
+    d->xprintf("[%d /XYZ %s \n",
+               d->pages.size() - 1,
+               qt_real_to_string(rr.left(), buf));
+    d->xprintf("%s 0]\n",
+               qt_real_to_string(rr.bottom(), buf));
+    d->xprintf("endobj\n");
+    d->anchors[name] = anchor;
+}
+
+void QPdfEngine::beginSectionOutline(const QString &text, const QString &anchor)
+{
+    Q_D(QPdfEngine);
+    if (d->outlineCurrent == NULL) {
+        if (d->outlineRoot)
+            delete d->outlineRoot;
+        d->outlineCurrent = d->outlineRoot = new QPdfEnginePrivate::OutlineItem(QString(), QString());
+    }
+
+    QPdfEnginePrivate::OutlineItem *i = new QPdfEnginePrivate::OutlineItem(text, anchor);
+    i->parent = d->outlineCurrent;
+    i->prev = d->outlineCurrent->lastChild;
+    if (d->outlineCurrent->firstChild)
+        d->outlineCurrent->lastChild->next = i;
+    else
+        d->outlineCurrent->firstChild = i;
+    d->outlineCurrent->lastChild = i;
+    d->outlineCurrent = i;
+}
+
+void QPdfEngine::endSectionOutline()
+{
+    Q_D(QPdfEngine);
+    if (d->outlineCurrent)
+        d->outlineCurrent = d->outlineCurrent->parent;
+}
+
 void QPdfEnginePrivate::writePage()
 {
     if (pages.empty())
@@ -1171,14 +1629,14 @@ void QPdfEnginePrivate::writePage()
     addXrefEntry(pageStream);
     xprintf("<<\n"
             "/Length %d 0 R\n", pageStreamLength); // object number for stream length object
-    if (do_compress)
+    if (doCompress)
         xprintf("/Filter /FlateDecode\n");
 
     xprintf(">>\n");
     xprintf("stream\n");
     QIODevice *content = currentPage->stream();
     int len = writeCompressed(content);
-    xprintf("endstream\n"
+    xprintf("\nendstream\n"
             "endobj\n");
 
     addXrefEntry(pageStreamLength);
diff --git a/src/gui/painting/qprintengine_pdf_p.h b/src/gui/painting/qprintengine_pdf_p.h
index 4cbfac3c39..773706deeb 100644
--- a/src/gui/painting/qprintengine_pdf_p.h
+++ b/src/gui/painting/qprintengine_pdf_p.h
@@ -92,7 +92,12 @@ public:
     // reimplementations QPaintEngine
     bool begin(QPaintDevice *pdev);
     bool end();
-    void drawPixmap (const QRectF & rectangle, const QPixmap & pixmap, const QRectF & sr);
+
+    void drawPixmap(const QRectF &r, const QPixmap &pm, const QRectF &sr, const QByteArray * data=0);
+    void drawPixmap(const QRectF & rectangle, const QPixmap & pixmap, const QRectF & sr) {
+        drawPixmap(rectangle, pixmap, sr, 0);
+    }
+
     void drawImage(const QRectF &r, const QImage &pm, const QRectF &sr,
                    Qt::ImageConversionFlags flags = Qt::AutoColor);
     void drawTiledPixmap (const QRectF & rectangle, const QPixmap & pixmap, const QPointF & point);
@@ -108,12 +113,23 @@ public:
 
     void setBrush();
 
+    virtual void addHyperlink(const QRectF &r, const QUrl &url);
+    virtual void addAnchor(const QRectF &r, const QString &name);
+    virtual void addLink(const QRectF &r, const QString &anchor);
+    virtual void addTextField(const QRectF &r, const QString &text, const QString &name, bool multiLine, bool password, bool readOnly, int maxLength);
+    virtual void addCheckBox(const QRectF &r, bool checked, const QString &name, bool readOnly);
+
     // ### unused, should have something for this in QPrintEngine
     void setAuthor(const QString &author);
     QString author() const;
 
     void setDevice(QIODevice* dev);
 
+    void beginSectionOutline(const QString &text, const QString &anchor);
+    void endSectionOutline();
+
+    void setProperty(PrintEnginePropertyKey key, const QVariant &value);
+    QVariant property(PrintEnginePropertyKey key) const;
 private:
     Q_DISABLE_COPY(QPdfEngine)
 
@@ -124,6 +140,35 @@ class QPdfEnginePrivate : public QPdfBaseEnginePrivate
 {
     Q_DECLARE_PUBLIC(QPdfEngine)
 public:
+  
+    class OutlineItem {
+    public:
+        OutlineItem *parent;
+        OutlineItem *next;
+        OutlineItem *prev;
+        OutlineItem *firstChild;
+        OutlineItem *lastChild;
+        uint obj;
+        QString text;
+        QString anchor;
+        
+        OutlineItem(const QString &t, const QString &a): 
+            parent(NULL), next(NULL), prev(NULL), firstChild(NULL), lastChild(NULL),
+            obj(0), text(t), anchor(a) {}
+        ~OutlineItem() {
+            OutlineItem *i = firstChild;
+            while(i != NULL) { 
+                OutlineItem *n = i->next;
+                delete i;
+                i=n;
+            }
+        }
+    };
+    
+    OutlineItem *outlineRoot;
+    OutlineItem *outlineCurrent;
+    void writeOutlineChildren(OutlineItem *node);
+    
     QPdfEnginePrivate(QPrinter::PrinterMode m);
     ~QPdfEnginePrivate();
 
@@ -141,7 +186,9 @@ public:
     void writeHeader();
     void writeTail();
 
-    int addImage(const QImage &image, bool *bitmap, qint64 serial_no);
+    void convertImage(const QImage & image, QByteArray & imageData);
+
+    int addImage(const QImage &image, bool *bitmap, qint64 serial_no, const QImage * noneScaled=0, const QByteArray * data=0, bool * useScaled=0);
     int addConstantAlphaObject(int brushAlpha, int penAlpha = 255);
     int addBrushPattern(const QTransform &matrix, bool *specifyColor, int *gStateObject);
 
@@ -161,16 +208,25 @@ private:
     void writeFonts();
     void embedFont(QFontSubset *font);
 
+    int formFieldList;
+    QVector<uint> formFields;
     QVector<int> xrefPositions;
     QDataStream* stream;
     int streampos;
 
+    bool doCompress;
+    int imageDPI;
+    int imageQuality;
+
     int writeImage(const QByteArray &data, int width, int height, int depth,
                    int maskObject, int softMaskObject, bool dct = false);
     void writePage();
 
     int addXrefEntry(int object, bool printostr = true);
+
     void printString(const QString &string);
+    void printAnchor(const QString &name);
+    
     void xprintf(const char* fmt, ...);
     inline void write(const QByteArray &data) {
         stream->writeRawData(data.constData(), data.size());
@@ -183,6 +239,8 @@ private:
 
     // various PDF objects
     int pageRoot, catalog, info, graphicsState, patternColorSpace;
+    QVector<uint> dests;
+    QHash<QString, uint> anchors;
     QVector<uint> pages;
     QHash<qint64, uint> imageCache;
     QHash<QPair<uint, uint>, uint > alphaCache;
diff --git a/src/gui/painting/qprinter.cpp b/src/gui/painting/qprinter.cpp
index 139bf3bc27..94ebf4c1f3 100644
--- a/src/gui/painting/qprinter.cpp
+++ b/src/gui/painting/qprinter.cpp
@@ -933,6 +933,39 @@ void QPrinter::setOutputFileName(const QString &fileName)
     d->addToManualSetList(QPrintEngine::PPK_OutputFileName);
 }
 
+/*!
+    Add a section to the document outline. All following sections will be added
+    to as subsections to this section, until endSectionOutline() has been called.
+
+    \a name is the name of the added section. \a anchor is the name of an anchor
+    indicating the beginning of the section.  This anchor must be added by calling
+    QPainter::addAnchor().
+
+    Note that for output formats not supporting outlines, currently all other then PDF,
+    this call has no effect.
+
+    \sa endSectionOutline() QPainter::addAnchor() 
+
+    \since 4.7
+*/
+void QPrinter::beginSectionOutline(const QString &name, const QString &anchor)
+{
+    Q_D(QPrinter);
+    d->printEngine->beginSectionOutline(name, anchor);
+}
+
+/*!
+    End the current section.
+
+    \sa beginSectionOutline()
+
+    \since 4.7
+*/
+void QPrinter::endSectionOutline() 
+{
+    Q_D(QPrinter);
+    d->printEngine->endSectionOutline();
+}
 
 /*!
   Returns the name of the program that sends the print output to the
diff --git a/src/gui/painting/qprinter.h b/src/gui/painting/qprinter.h
index c2d871989f..53075e1018 100644
--- a/src/gui/painting/qprinter.h
+++ b/src/gui/painting/qprinter.h
@@ -147,6 +147,9 @@ public:
     enum PrinterOption { PrintToFile, PrintSelection, PrintPageRange };
 #endif // QT3_SUPPORT
 
+    void beginSectionOutline(const QString &text, const QString &anchor);
+    void endSectionOutline();
+
     void setOutputFormat(OutputFormat format);
     OutputFormat outputFormat() const;
 
diff --git a/src/gui/styles/qstyle.cpp b/src/gui/styles/qstyle.cpp
index 614fe69210..a26595ad1f 100644
--- a/src/gui/styles/qstyle.cpp
+++ b/src/gui/styles/qstyle.cpp
@@ -47,6 +47,7 @@
 #include "qpixmapcache.h"
 #include "qstyleoption.h"
 #include "private/qstyle_p.h"
+#include "private/qapplication_p.h"
 #ifndef QT_NO_DEBUG
 #include "qdebug.h"
 #endif
@@ -2231,7 +2232,7 @@ QPalette QStyle::standardPalette() const
 {
 #ifdef Q_WS_X11
     QColor background;
-    if (QX11Info::appDepth() > 8)
+    if (!qt_is_gui_used || QX11Info::appDepth() > 8)
         background = QColor(0xd4, 0xd0, 0xc8); // win 2000 grey
     else
         background = QColor(192, 192, 192);
diff --git a/src/gui/text/qfontengine.cpp b/src/gui/text/qfontengine.cpp
index 67b8798da1..3f7d831a13 100644
--- a/src/gui/text/qfontengine.cpp
+++ b/src/gui/text/qfontengine.cpp
@@ -69,6 +69,16 @@ static inline bool qtransform_equals_no_translate(const QTransform &a, const QTr
     }
 }
 
+template<typename T>
+static inline bool qSafeFromBigEndian(const uchar *source, const uchar *end, T *output)
+{
+    if (source + sizeof(T) > end)
+        return false;
+
+    *output = qFromBigEndian<T>(source);
+    return true;
+}
+
 // Harfbuzz helper functions
 
 static HB_Bool hb_stringToGlyphs(HB_Font font, const HB_UChar16 *string, hb_uint32 length, HB_Glyph *glyphs, hb_uint32 *numGlyphs, HB_Bool rightToLeft)
@@ -808,26 +818,38 @@ void QFontEngine::loadKerningPairs(QFixed scalingFactor)
         return;
 
     const uchar *table = reinterpret_cast<const uchar *>(tab.constData());
+    const uchar *end = table + tab.size();
+
+    quint16 version;
+    if (!qSafeFromBigEndian(table, end, &version))
+        return;
 
-    unsigned short version = qFromBigEndian<quint16>(table);
     if (version != 0) {
 //        qDebug("wrong version");
        return;
     }
 
-    unsigned short numTables = qFromBigEndian<quint16>(table + 2);
+    quint16 numTables;
+    if (!qSafeFromBigEndian(table + 2, end, &numTables))
+        return;
+
     {
         int offset = 4;
         for(int i = 0; i < numTables; ++i) {
-            if (offset + 6 > tab.size()) {
-//                qDebug("offset out of bounds");
-                goto end;
-            }
             const uchar *header = table + offset;
 
-            ushort version = qFromBigEndian<quint16>(header);
-            ushort length = qFromBigEndian<quint16>(header+2);
-            ushort coverage = qFromBigEndian<quint16>(header+4);
+            quint16 version;
+            if (!qSafeFromBigEndian(header, end, &version))
+                goto end;
+
+            quint16 length;
+            if (!qSafeFromBigEndian(header + 2, end, &length))
+                goto end;
+
+            quint16 coverage;
+            if (!qSafeFromBigEndian(header + 4, end, &coverage))
+                goto end;
+
 //            qDebug("subtable: version=%d, coverage=%x",version, coverage);
             if(version == 0 && coverage == 0x0001) {
                 if (offset + length > tab.size()) {
@@ -836,7 +858,10 @@ void QFontEngine::loadKerningPairs(QFixed scalingFactor)
                 }
                 const uchar *data = table + offset + 6;
 
-                ushort nPairs = qFromBigEndian<quint16>(data);
+                quint16 nPairs;
+                if (!qSafeFromBigEndian(data, end, &nPairs))
+                    goto end;
+
                 if(nPairs * 6 + 8 > length - 6) {
 //                    qDebug("corrupt table!");
                     // corrupt table
@@ -846,8 +871,21 @@ void QFontEngine::loadKerningPairs(QFixed scalingFactor)
                 int off = 8;
                 for(int i = 0; i < nPairs; ++i) {
                     QFontEngine::KernPair p;
-                    p.left_right = (((uint)qFromBigEndian<quint16>(data+off)) << 16) + qFromBigEndian<quint16>(data+off+2);
-                    p.adjust = QFixed(((int)(short)qFromBigEndian<quint16>(data+off+4))) / scalingFactor;
+
+                    quint16 tmp;
+                    if (!qSafeFromBigEndian(data + off, end, &tmp))
+                        goto end;
+
+                    p.left_right = uint(tmp) << 16;
+                    if (!qSafeFromBigEndian(data + off + 2, end, &tmp))
+                        goto end;
+
+                    p.left_right |= tmp;
+
+                    if (!qSafeFromBigEndian(data + off + 4, end, &tmp))
+                        goto end;
+
+                    p.adjust = QFixed(int(short(tmp))) / scalingFactor;
                     kerning_pairs.append(p);
                     off += 6;
                 }
@@ -872,26 +910,31 @@ int QFontEngine::glyphCount() const
     QByteArray maxpTable = getSfntTable(MAKE_TAG('m', 'a', 'x', 'p'));
     if (maxpTable.size() < 6)
         return 0;
-    return qFromBigEndian<quint16>(reinterpret_cast<const uchar *>(maxpTable.constData() + 4));
+
+    const uchar *source = reinterpret_cast<const uchar *>(maxpTable.constData() + 4);
+    const uchar *end = source + maxpTable.size();
+
+    quint16 count = 0;
+    qSafeFromBigEndian(source, end, &count);
+    return count;
 }
 
 const uchar *QFontEngine::getCMap(const uchar *table, uint tableSize, bool *isSymbolFont, int *cmapSize)
 {
     const uchar *header = table;
-    if (tableSize < 4)
-        return 0;
-
     const uchar *endPtr = table + tableSize;
 
     // version check
-    if (qFromBigEndian<quint16>(header) != 0)
+    quint16 version;
+    if (!qSafeFromBigEndian(header, endPtr, &version) || version != 0)
         return 0;
 
-    unsigned short numTables = qFromBigEndian<quint16>(header + 2);
-    const uchar *maps = table + 4;
-    if (maps + 8 * numTables > endPtr)
+    quint16 numTables;
+    if (!qSafeFromBigEndian(header + 2, endPtr, &numTables))
         return 0;
 
+    const uchar *maps = table + 4;
+
     enum {
         Invalid,
         AppleRoman,
@@ -906,8 +949,14 @@ const uchar *QFontEngine::getCMap(const uchar *table, uint tableSize, bool *isSy
     int tableToUse = -1;
     int score = Invalid;
     for (int n = 0; n < numTables; ++n) {
-        const quint16 platformId = qFromBigEndian<quint16>(maps + 8 * n);
-        const quint16 platformSpecificId = qFromBigEndian<quint16>(maps + 8 * n + 2);
+        quint16 platformId;
+        if (!qSafeFromBigEndian(maps + 8 * n, endPtr, &platformId))
+            return 0;
+
+        quint16 platformSpecificId;
+        if (!qSafeFromBigEndian(maps + 8 * n + 2, endPtr, &platformSpecificId))
+            return 0;
+
         switch (platformId) {
         case 0: // Unicode
             if (score < Unicode &&
@@ -961,20 +1010,30 @@ const uchar *QFontEngine::getCMap(const uchar *table, uint tableSize, bool *isSy
 resolveTable:
     *isSymbolFont = (symbolTable > -1);
 
-    unsigned int unicode_table = qFromBigEndian<quint32>(maps + 8*tableToUse + 4);
+    quint32 unicode_table;
+    if (!qSafeFromBigEndian(maps + 8 * tableToUse + 4, endPtr, &unicode_table))
+        return 0;
 
-    if (!unicode_table || unicode_table + 8 > tableSize)
+    if (!unicode_table)
         return 0;
 
     // get the header of the unicode table
     header = table + unicode_table;
 
-    unsigned short format = qFromBigEndian<quint16>(header);
-    unsigned int length;
-    if(format < 8)
-        length = qFromBigEndian<quint16>(header + 2);
-    else
-        length = qFromBigEndian<quint32>(header + 4);
+    quint16 format;
+    if (!qSafeFromBigEndian(header, endPtr, &format))
+        return 0;
+
+    quint32 length;
+    if (format < 8) {
+        quint16 tmp;
+        if (!qSafeFromBigEndian(header + 2, endPtr, &tmp))
+            return 0;
+        length = tmp;
+    } else {
+        if (!qSafeFromBigEndian(header + 4, endPtr, &length))
+            return 0;
+    }
 
     if (table + unicode_table + length > endPtr)
         return 0;
@@ -989,7 +1048,7 @@ resolveTable:
         // Check that none of the latin1 range are in the unicode table
         bool unicodeTableHasLatin1 = false;
         for (int uc=0x00; uc<0x100; ++uc) {
-            if (getTrueTypeGlyphIndex(selectedTable, uc) != 0) {
+            if (getTrueTypeGlyphIndex(selectedTable, length, uc) != 0) {
                 unicodeTableHasLatin1 = true;
                 break;
             }
@@ -999,7 +1058,7 @@ resolveTable:
         bool unicodeTableHasSymbols = false;
         if (!unicodeTableHasLatin1) {
             for (int uc=0xf000; uc<0xf100; ++uc) {
-                if (getTrueTypeGlyphIndex(selectedTable, uc) != 0) {
+                if (getTrueTypeGlyphIndex(selectedTable, length, uc) != 0) {
                     unicodeTableHasSymbols = true;
                     break;
                 }
@@ -1017,12 +1076,17 @@ resolveTable:
     return table + unicode_table;
 }
 
-quint32 QFontEngine::getTrueTypeGlyphIndex(const uchar *cmap, uint unicode)
+quint32 QFontEngine::getTrueTypeGlyphIndex(const uchar *cmap, int cmapSize, uint unicode)
 {
-    unsigned short format = qFromBigEndian<quint16>(cmap);
+    const uchar *end = cmap + cmapSize;
+    quint16 format;
+    if (!qSafeFromBigEndian(cmap, end, &format))
+        return 0;
+
     if (format == 0) {
-        if (unicode < 256)
-            return (int) *(cmap+6+unicode);
+        const uchar *ptr = cmap + 6 + unicode;
+        if (unicode < 256 && ptr < end)
+            return quint32(*ptr);
     } else if (format == 4) {
         /* some fonts come with invalid cmap tables, where the last segment
            specified end = start = rangeoffset = 0xffff, delta = 0x0001
@@ -1031,25 +1095,49 @@ quint32 QFontEngine::getTrueTypeGlyphIndex(const uchar *cmap, uint unicode)
         */
         if(unicode >= 0xffff)
             return 0;
-        quint16 segCountX2 = qFromBigEndian<quint16>(cmap + 6);
+
+        quint16 segCountX2;
+        if (!qSafeFromBigEndian(cmap + 6, end, &segCountX2))
+            return 0;
+
         const unsigned char *ends = cmap + 14;
+
         int i = 0;
-        for (; i < segCountX2/2 && qFromBigEndian<quint16>(ends + 2*i) < unicode; i++) {}
+        for (; i < segCountX2/2; ++i) {
+            quint16 codePoint;
+            if (!qSafeFromBigEndian(ends + 2 * i, end, &codePoint))
+                return 0;
+            if (codePoint >= unicode)
+                break;
+        }
 
         const unsigned char *idx = ends + segCountX2 + 2 + 2*i;
-        quint16 startIndex = qFromBigEndian<quint16>(idx);
 
+        quint16 startIndex;
+        if (!qSafeFromBigEndian(idx, end, &startIndex))
+            return 0;
         if (startIndex > unicode)
             return 0;
 
         idx += segCountX2;
-        qint16 idDelta = (qint16)qFromBigEndian<quint16>(idx);
+
+        quint16 tmp;
+        if (!qSafeFromBigEndian(idx, end, &tmp))
+            return 0;
+        qint16 idDelta = qint16(tmp);
+
         idx += segCountX2;
-        quint16 idRangeoffset_t = (quint16)qFromBigEndian<quint16>(idx);
+
+        quint16 idRangeoffset_t;
+        if (!qSafeFromBigEndian(idx, end, &idRangeoffset_t))
+            return 0;
 
         quint16 glyphIndex;
         if (idRangeoffset_t) {
-            quint16 id = qFromBigEndian<quint16>(idRangeoffset_t + 2*(unicode - startIndex) + idx);
+            quint16 id;
+            if (!qSafeFromBigEndian(idRangeoffset_t + 2 * (unicode - startIndex) + idx, end, &id))
+                return 0;
+
             if (id)
                 glyphIndex = (idDelta + id) % 0x10000;
             else
@@ -1059,13 +1147,19 @@ quint32 QFontEngine::getTrueTypeGlyphIndex(const uchar *cmap, uint unicode)
         }
         return glyphIndex;
     } else if (format == 6) {
-        quint16 tableSize = qFromBigEndian<quint16>(cmap + 2);
+        quint16 tableSize;
+        if (!qSafeFromBigEndian(cmap + 2, end, &tableSize))
+            return 0;
 
-        quint16 firstCode6 = qFromBigEndian<quint16>(cmap + 6);
+        quint16 firstCode6;
+        if (!qSafeFromBigEndian(cmap + 6, end, &firstCode6))
+            return 0;
         if (unicode < firstCode6)
             return 0;
 
-        quint16 entryCount6 = qFromBigEndian<quint16>(cmap + 8);
+        quint16 entryCount6;
+        if (!qSafeFromBigEndian(cmap + 8, end, &entryCount6))
+            return 0;
         if (entryCount6 * 2 + 10 > tableSize)
             return 0;
 
@@ -1074,9 +1168,14 @@ quint32 QFontEngine::getTrueTypeGlyphIndex(const uchar *cmap, uint unicode)
             return 0;
 
         quint16 entryIndex6 = unicode - firstCode6;
-        return qFromBigEndian<quint16>(cmap + 10 + (entryIndex6 * 2));
+
+        quint16 index = 0;
+        qSafeFromBigEndian(cmap + 10 + (entryIndex6 * 2), end, &index);
+        return index;
     } else if (format == 12) {
-        quint32 nGroups = qFromBigEndian<quint32>(cmap + 12);
+        quint32 nGroups;
+        if (!qSafeFromBigEndian(cmap + 12, end, &nGroups))
+            return 0;
 
         cmap += 16; // move to start of groups
 
@@ -1084,13 +1183,24 @@ quint32 QFontEngine::getTrueTypeGlyphIndex(const uchar *cmap, uint unicode)
         while (left <= right) {
             int middle = left + ( ( right - left ) >> 1 );
 
-            quint32 startCharCode = qFromBigEndian<quint32>(cmap + 12*middle);
+            quint32 startCharCode;
+            if (!qSafeFromBigEndian(cmap + 12 * middle, end, &startCharCode))
+                return 0;
+
             if(unicode < startCharCode)
                 right = middle - 1;
             else {
-                quint32 endCharCode = qFromBigEndian<quint32>(cmap + 12*middle + 4);
-                if(unicode <= endCharCode)
-                    return qFromBigEndian<quint32>(cmap + 12*middle + 8) + unicode - startCharCode;
+                quint32 endCharCode;
+                if (!qSafeFromBigEndian(cmap + 12 * middle + 4, end, &endCharCode))
+                    return 0;
+
+                if (unicode <= endCharCode) {
+                    quint32 index;
+                    if (!qSafeFromBigEndian(cmap + 12 * middle + 8, end, &index))
+                        return 0;
+
+                    return index + unicode - startCharCode;
+                }
                 left = middle + 1;
             }
         }
diff --git a/src/gui/text/qfontengine_mac.mm b/src/gui/text/qfontengine_mac.mm
index ba01f4c6fa..460aa5fd65 100644
--- a/src/gui/text/qfontengine_mac.mm
+++ b/src/gui/text/qfontengine_mac.mm
@@ -625,7 +625,7 @@ bool QFontEngineMacMulti::canRender(const QChar *string, int len)
 }
 
 QFontEngineMac::QFontEngineMac(ATSUStyle baseStyle, ATSUFontID fontID, const QFontDef &def, QFontEngineMacMulti *multiEngine)
-    : fontID(fontID), multiEngine(multiEngine), cmap(0), symbolCMap(false)
+    : fontID(fontID), multiEngine(multiEngine), cmap(0), symbolCMap(false), cmapSize(0)
 {
     fontDef = def;
     ATSUCreateAndCopyStyle(baseStyle, &style);
@@ -747,22 +747,21 @@ bool QFontEngineMac::stringToCMap(const QChar *str, int len, QGlyphLayout *glyph
 {
     if (!cmap) {
         cmapTable = getSfntTable(MAKE_TAG('c', 'm', 'a', 'p'));
-        int size = 0;
-        cmap = getCMap(reinterpret_cast<const uchar *>(cmapTable.constData()), cmapTable.size(), &symbolCMap, &size);
+        cmap = getCMap(reinterpret_cast<const uchar *>(cmapTable.constData()), cmapTable.size(), &symbolCMap, &cmapSize);
         if (!cmap)
             return false;
     }
     if (symbolCMap) {
         for (int i = 0; i < len; ++i) {
             unsigned int uc = getChar(str, i, len);
-            glyphs->glyphs[i] = getTrueTypeGlyphIndex(cmap, uc);
+            glyphs->glyphs[i] = getTrueTypeGlyphIndex(cmap, cmapSize, uc);
             if(!glyphs->glyphs[i] && uc < 0x100)
-                glyphs->glyphs[i] = getTrueTypeGlyphIndex(cmap, uc + 0xf000);
+                glyphs->glyphs[i] = getTrueTypeGlyphIndex(cmap, cmapSize, uc + 0xf000);
         }
     } else {
         for (int i = 0; i < len; ++i) {
             unsigned int uc = getChar(str, i, len);
-            glyphs->glyphs[i] = getTrueTypeGlyphIndex(cmap, uc);
+            glyphs->glyphs[i] = getTrueTypeGlyphIndex(cmap, cmapSize, uc);
         }
     }
 
diff --git a/src/gui/text/qfontengine_mac_p.h b/src/gui/text/qfontengine_mac_p.h
index 7d70c24fc0..844d42190f 100644
--- a/src/gui/text/qfontengine_mac_p.h
+++ b/src/gui/text/qfontengine_mac_p.h
@@ -108,6 +108,7 @@ private:
     qreal m_maxCharWidth;
     QFixed m_xHeight;
     QFixed m_averageCharWidth;
+    mutable int cmapSize;
 };
 
 class QFontEngineMacMulti : public QFontEngineMulti
diff --git a/src/gui/text/qfontengine_p.h b/src/gui/text/qfontengine_p.h
index f29ac47eef..9c3435f9ed 100644
--- a/src/gui/text/qfontengine_p.h
+++ b/src/gui/text/qfontengine_p.h
@@ -247,7 +247,7 @@ public:
     QFontEngineGlyphCache *glyphCache(void *key, QFontEngineGlyphCache::Type type, const QTransform &transform) const;
 
     static const uchar *getCMap(const uchar *table, uint tableSize, bool *isSymbolFont, int *cmapSize);
-    static quint32 getTrueTypeGlyphIndex(const uchar *cmap, uint unicode);
+    static quint32 getTrueTypeGlyphIndex(const uchar *cmap, int cmapSize, uint unicode);
 
     static QByteArray convertToPostscriptFontFamilyName(const QByteArray &fontFamily);
 
diff --git a/src/gui/text/qfontengine_qpa.cpp b/src/gui/text/qfontengine_qpa.cpp
index 04f7b76332..011d2330df 100644
--- a/src/gui/text/qfontengine_qpa.cpp
+++ b/src/gui/text/qfontengine_qpa.cpp
@@ -358,9 +358,9 @@ bool QFontEngineQPA::stringToCMap(const QChar *str, int len, QGlyphLayout *glyph
             unsigned int uc = getChar(str, i, len);
             if (mirrored)
                 uc = QChar::mirroredChar(uc);
-            glyphs->glyphs[glyph_pos] = getTrueTypeGlyphIndex(cmap, uc);
+            glyphs->glyphs[glyph_pos] = getTrueTypeGlyphIndex(cmap, cmapSize, uc);
             if(!glyphs->glyphs[glyph_pos] && uc < 0x100)
-                glyphs->glyphs[glyph_pos] = getTrueTypeGlyphIndex(cmap, uc + 0xf000);
+                glyphs->glyphs[glyph_pos] = getTrueTypeGlyphIndex(cmap, cmapSize, uc + 0xf000);
             ++glyph_pos;
         }
     } else {
@@ -368,7 +368,7 @@ bool QFontEngineQPA::stringToCMap(const QChar *str, int len, QGlyphLayout *glyph
             unsigned int uc = getChar(str, i, len);
             if (mirrored)
                 uc = QChar::mirroredChar(uc);
-            glyphs->glyphs[glyph_pos] = getTrueTypeGlyphIndex(cmap, uc);
+            glyphs->glyphs[glyph_pos] = getTrueTypeGlyphIndex(cmap, cmapSize, uc);
 #if 0 && defined(DEBUG_FONTENGINE)
             QChar c(uc);
             if (!findGlyph(glyphs[glyph_pos].glyph) && !seenGlyphs.contains(c))
@@ -511,16 +511,16 @@ bool QFontEngineQPA::canRender(const QChar *string, int len)
     if (symbol) {
         for (int i = 0; i < len; ++i) {
             unsigned int uc = getChar(string, i, len);
-            glyph_t g = getTrueTypeGlyphIndex(cmap, uc);
+            glyph_t g = getTrueTypeGlyphIndex(cmap, cmapSize, uc);
             if(!g && uc < 0x100)
-                g = getTrueTypeGlyphIndex(cmap, uc + 0xf000);
+                g = getTrueTypeGlyphIndex(cmap, cmapSize, uc + 0xf000);
             if (!g)
                 return false;
         }
     } else {
         for (int i = 0; i < len; ++i) {
             unsigned int uc = getChar(string, i, len);
-            if (!getTrueTypeGlyphIndex(cmap, uc))
+            if (!getTrueTypeGlyphIndex(cmap, cmapSize, uc))
                 return false;
         }
     }
diff --git a/src/gui/text/qfontengine_qpf.cpp b/src/gui/text/qfontengine_qpf.cpp
index 8d5e71b8fc..9087cff8c8 100644
--- a/src/gui/text/qfontengine_qpf.cpp
+++ b/src/gui/text/qfontengine_qpf.cpp
@@ -577,9 +577,9 @@ bool QFontEngineQPF::stringToCMap(const QChar *str, int len, QGlyphLayout *glyph
     if (symbol) {
         for (int i = 0; i < len; ++i) {
             unsigned int uc = getChar(str, i, len);
-            glyphs->glyphs[glyph_pos] = getTrueTypeGlyphIndex(cmap, uc);
+            glyphs->glyphs[glyph_pos] = getTrueTypeGlyphIndex(cmap, cmapSize, uc);
             if(!glyphs->glyphs[glyph_pos] && uc < 0x100)
-                glyphs->glyphs[glyph_pos] = getTrueTypeGlyphIndex(cmap, uc + 0xf000);
+                glyphs->glyphs[glyph_pos] = getTrueTypeGlyphIndex(cmap, cmapSize, uc + 0xf000);
             ++glyph_pos;
         }
     } else {
@@ -587,7 +587,7 @@ bool QFontEngineQPF::stringToCMap(const QChar *str, int len, QGlyphLayout *glyph
             unsigned int uc = getChar(str, i, len);
             if (mirrored)
                 uc = QChar::mirroredChar(uc);
-            glyphs->glyphs[glyph_pos] = getTrueTypeGlyphIndex(cmap, uc);
+            glyphs->glyphs[glyph_pos] = getTrueTypeGlyphIndex(cmap, cmapSize, uc);
 #if 0 && defined(DEBUG_FONTENGINE)
             QChar c(uc);
             if (!findGlyph(glyphs[glyph_pos].glyph) && !seenGlyphs.contains(c))
@@ -786,16 +786,16 @@ bool QFontEngineQPF::canRender(const QChar *string, int len)
     if (symbol) {
         for (int i = 0; i < len; ++i) {
             unsigned int uc = getChar(string, i, len);
-            glyph_t g = getTrueTypeGlyphIndex(cmap, uc);
+            glyph_t g = getTrueTypeGlyphIndex(cmap, cmapSize, uc);
             if(!g && uc < 0x100)
-                g = getTrueTypeGlyphIndex(cmap, uc + 0xf000);
+                g = getTrueTypeGlyphIndex(cmap, cmapSize, uc + 0xf000);
             if (!g)
                 return false;
         }
     } else {
         for (int i = 0; i < len; ++i) {
             unsigned int uc = getChar(string, i, len);
-            if (!getTrueTypeGlyphIndex(cmap, uc))
+            if (!getTrueTypeGlyphIndex(cmap, cmapSize, uc))
                 return false;
         }
     }
diff --git a/src/gui/text/qfontengine_s60.cpp b/src/gui/text/qfontengine_s60.cpp
index 1da501a92b..b2bb5610b2 100644
--- a/src/gui/text/qfontengine_s60.cpp
+++ b/src/gui/text/qfontengine_s60.cpp
@@ -77,6 +77,7 @@ QSymbianTypeFaceExtras::QSymbianTypeFaceExtras(CFont* cFont, COpenFont *openFont
     : m_cFont(cFont)
     , m_symbolCMap(false)
     , m_openFont(openFont)
+    , m_cmapSize(0)
 {
     if (!symbianFontTableApiAvailable()) {
         TAny *trueTypeExtension = NULL;
@@ -161,10 +162,9 @@ const uchar *QSymbianTypeFaceExtras::cmap() const
 {
     if (m_cmapTable.isNull()) {
         const QByteArray cmapTable = getSfntTable(MAKE_TAG('c', 'm', 'a', 'p'));
-        int size = 0;
         const uchar *cmap = QFontEngine::getCMap(reinterpret_cast<const uchar *>
-                (cmapTable.constData()), cmapTable.size(), &m_symbolCMap, &size);
-        m_cmapTable = QByteArray(reinterpret_cast<const char *>(cmap), size);
+                (cmapTable.constData()), cmapTable.size(), &m_symbolCMap, &m_cmapSize);
+        m_cmapTable = QByteArray(reinterpret_cast<const char *>(cmap), m_cmapSize);
     }
     return reinterpret_cast<const uchar *>(m_cmapTable.constData());
 }
@@ -324,6 +324,7 @@ bool QFontEngineS60::stringToCMap(const QChar *characters, int len, QGlyphLayout
     for (int i = 0; i < len; ++i) {
         const unsigned int uc = getChar(characters, i, len);
         *g++ = QFontEngine::getTrueTypeGlyphIndex(cmap,
+                                                  m_cmapSize,
                         (isRtl && !m_extras->isSymbolCMap()) ? QChar::mirroredChar(uc) : uc);
     }
 
@@ -463,7 +464,7 @@ bool QFontEngineS60::canRender(const QChar *string, int len)
     const unsigned char *cmap = m_extras->cmap();
     for (int i = 0; i < len; ++i) {
         const unsigned int uc = getChar(string, i, len);
-        if (QFontEngine::getTrueTypeGlyphIndex(cmap, uc) == 0)
+        if (QFontEngine::getTrueTypeGlyphIndex(cmap, m_cmapSize, uc) == 0)
             return false;
     }
     return true;
diff --git a/src/gui/text/qfontengine_s60_p.h b/src/gui/text/qfontengine_s60_p.h
index 17e2207f7b..9e385708ff 100644
--- a/src/gui/text/qfontengine_s60_p.h
+++ b/src/gui/text/qfontengine_s60_p.h
@@ -93,6 +93,7 @@ private:
     // the Font Table API
     COpenFont *m_openFont;
     mutable MOpenFontTrueTypeExtension *m_trueTypeExtension;
+    mutable int m_cmapSize;
 };
 
 class QFontEngineS60 : public QFontEngine
diff --git a/src/gui/text/qfontengine_win.cpp b/src/gui/text/qfontengine_win.cpp
index bd9a437999..6ad5eb4915 100644
--- a/src/gui/text/qfontengine_win.cpp
+++ b/src/gui/text/qfontengine_win.cpp
@@ -215,9 +215,8 @@ void QFontEngineWin::getCMap()
     bool symb = false;
     if (ttf) {
         cmapTable = getSfntTable(qbswap<quint32>(MAKE_TAG('c', 'm', 'a', 'p')));
-        int size = 0;
         cmap = QFontEngine::getCMap(reinterpret_cast<const uchar *>(cmapTable.constData()),
-                       cmapTable.size(), &symb, &size);
+                       cmapTable.size(), &symb, &cmapSize);
     }
     if (!cmap) {
         ttf = false;
@@ -263,14 +262,14 @@ int QFontEngineWin::getGlyphIndexes(const QChar *str, int numChars, QGlyphLayout
         if (symbol) {
             for (; i < numChars; ++i, ++glyph_pos) {
                 unsigned int uc = getChar(str, i, numChars);
-                glyphs->glyphs[glyph_pos] = getTrueTypeGlyphIndex(cmap, uc);
+                glyphs->glyphs[glyph_pos] = getTrueTypeGlyphIndex(cmap, cmapSize, uc);
                 if (!glyphs->glyphs[glyph_pos] && uc < 0x100)
-                    glyphs->glyphs[glyph_pos] = getTrueTypeGlyphIndex(cmap, uc + 0xf000);
+                    glyphs->glyphs[glyph_pos] = getTrueTypeGlyphIndex(cmap, cmapSize, uc + 0xf000);
             }
         } else if (ttf) {
             for (; i < numChars; ++i, ++glyph_pos) {
                 unsigned int uc = getChar(str, i, numChars);
-                glyphs->glyphs[glyph_pos] = getTrueTypeGlyphIndex(cmap, QChar::mirroredChar(uc));
+                glyphs->glyphs[glyph_pos] = getTrueTypeGlyphIndex(cmap, cmapSize, QChar::mirroredChar(uc));
             }
         } else {
 #endif
@@ -296,14 +295,14 @@ int QFontEngineWin::getGlyphIndexes(const QChar *str, int numChars, QGlyphLayout
         if (symbol) {
             for (; i < numChars; ++i, ++glyph_pos) {
                 unsigned int uc = getChar(str, i, numChars);
-                glyphs->glyphs[glyph_pos] = getTrueTypeGlyphIndex(cmap, uc);
+                glyphs->glyphs[glyph_pos] = getTrueTypeGlyphIndex(cmap, cmapSize, uc);
                 if(!glyphs->glyphs[glyph_pos] && uc < 0x100)
-                    glyphs->glyphs[glyph_pos] = getTrueTypeGlyphIndex(cmap, uc + 0xf000);
+                    glyphs->glyphs[glyph_pos] = getTrueTypeGlyphIndex(cmap, cmapSize, uc + 0xf000);
             }
         } else if (ttf) {
             for (; i < numChars; ++i, ++glyph_pos) {
                 unsigned int uc = getChar(str, i, numChars);
-                glyphs->glyphs[glyph_pos] = getTrueTypeGlyphIndex(cmap, uc);
+                glyphs->glyphs[glyph_pos] = getTrueTypeGlyphIndex(cmap, cmapSize, uc);
             }
         } else {
 #endif
@@ -335,6 +334,7 @@ QFontEngineWin::QFontEngineWin(const QString &name, HFONT _hfont, bool stockFont
     _name = name;
 
     cmap = 0;
+    cmapSize = 0;
     hfont = _hfont;
     logfont = lf;
     HDC hdc = shared_dc();
@@ -811,9 +811,9 @@ bool QFontEngineWin::canRender(const QChar *string,  int len)
     if (symbol) {
         for (int i = 0; i < len; ++i) {
             unsigned int uc = getChar(string, i, len);
-            if (getTrueTypeGlyphIndex(cmap, uc) == 0) {
+            if (getTrueTypeGlyphIndex(cmap, cmapSize, uc) == 0) {
                 if (uc < 0x100) {
-                    if (getTrueTypeGlyphIndex(cmap, uc + 0xf000) == 0)
+                    if (getTrueTypeGlyphIndex(cmap, cmapSize, uc + 0xf000) == 0)
                         return false;
                 } else {
                     return false;
@@ -823,7 +823,7 @@ bool QFontEngineWin::canRender(const QChar *string,  int len)
     } else if (ttf) {
         for (int i = 0; i < len; ++i) {
             unsigned int uc = getChar(string, i, len);
-            if (getTrueTypeGlyphIndex(cmap, uc) == 0)
+            if (getTrueTypeGlyphIndex(cmap, cmapSize, uc) == 0)
                 return false;
         }
     } else {
diff --git a/src/gui/text/qfontengine_win_p.h b/src/gui/text/qfontengine_win_p.h
index 0c8df72226..27f0355018 100644
--- a/src/gui/text/qfontengine_win_p.h
+++ b/src/gui/text/qfontengine_win_p.h
@@ -144,6 +144,7 @@ public:
     mutable uint widthCacheSize;
     mutable QFixed *designAdvances;
     mutable int designAdvancesSize;
+    int cmapSize;
 
 private:
     bool hasCFFTable() const;
diff --git a/src/svg/qsvggenerator.cpp b/src/svg/qsvggenerator.cpp
index 1679040849..b26b0bfe82 100644
--- a/src/svg/qsvggenerator.cpp
+++ b/src/svg/qsvggenerator.cpp
@@ -103,6 +103,7 @@ public:
 
         afterFirstUpdate = false;
         numGradients = 0;
+        clip = false;
     }
 
     QSize size;
@@ -129,6 +130,9 @@ public:
 
     QString currentGradientName;
     int numGradients;
+    QString stateString;
+    QString oldStateString;
+    bool clip;
 
     struct _attributes {
         QString document_title;
@@ -141,6 +145,18 @@ public:
         QString dashPattern, dashOffset;
         QString fill, fillOpacity;
     } attributes;
+
+    void emitState() {
+        if (stateString == oldStateString) return;
+
+        // close old state and start a new one...
+        if (afterFirstUpdate)
+            *stream << "</g>\n\n";
+        
+        *stream << stateString;
+        afterFirstUpdate = true;
+        oldStateString = stateString;
+    }
 };
 
 static inline QPaintEngine::PaintEngineFeatures svgEngineFeatures()
@@ -322,7 +338,7 @@ public:
     }
 
 
-    void qpenToSvg(const QPen &spen)
+    void qpenToSvg(const QPen &spen, QTextStream & s)
     {
         QString width;
 
@@ -330,7 +346,7 @@ public:
 
         switch (spen.style()) {
         case Qt::NoPen:
-            stream() << QLatin1String("stroke=\"none\" ");
+            s << QLatin1String("stroke=\"none\" ");
 
             d_func()->attributes.stroke = QLatin1String("none");
             d_func()->attributes.strokeOpacity = QString();
@@ -344,8 +360,8 @@ public:
             d_func()->attributes.stroke = color;
             d_func()->attributes.strokeOpacity = colorOpacity;
 
-            stream() << QLatin1String("stroke=\"")<<color<< QLatin1String("\" ");
-            stream() << QLatin1String("stroke-opacity=\"")<<colorOpacity<< QLatin1String("\" ");
+            s << QLatin1String("stroke=\"")<<color<< QLatin1String("\" ");
+            s << QLatin1String("stroke-opacity=\"")<<colorOpacity<< QLatin1String("\" ");
         }
             break;
         case Qt::DashLine:
@@ -368,10 +384,10 @@ public:
             d_func()->attributes.dashPattern = dashPattern;
             d_func()->attributes.dashOffset = dashOffset;
 
-            stream() << QLatin1String("stroke=\"")<<color<< QLatin1String("\" ");
-            stream() << QLatin1String("stroke-opacity=\"")<<colorOpacity<< QLatin1String("\" ");
-            stream() << QLatin1String("stroke-dasharray=\"")<<dashPattern<< QLatin1String("\" ");
-            stream() << QLatin1String("stroke-dashoffset=\"")<<dashOffset<< QLatin1String("\" ");
+            s << QLatin1String("stroke=\"")<<color<< QLatin1String("\" ");
+            s << QLatin1String("stroke-opacity=\"")<<colorOpacity<< QLatin1String("\" ");
+            s << QLatin1String("stroke-dasharray=\"")<<dashPattern<< QLatin1String("\" ");
+            s << QLatin1String("stroke-dashoffset=\"")<<dashOffset<< QLatin1String("\" ");
             break;
         }
         default:
@@ -380,50 +396,50 @@ public:
         }
 
         if (spen.widthF() == 0)
-            stream() <<"stroke-width=\"1\" ";
+            s <<"stroke-width=\"1\" ";
         else
-            stream() <<"stroke-width=\"" << spen.widthF() << "\" ";
+            s <<"stroke-width=\"" << spen.widthF() << "\" ";
 
         switch (spen.capStyle()) {
         case Qt::FlatCap:
-            stream() << "stroke-linecap=\"butt\" ";
+            s << "stroke-linecap=\"butt\" ";
             break;
         case Qt::SquareCap:
-            stream() << "stroke-linecap=\"square\" ";
+            s << "stroke-linecap=\"square\" ";
             break;
         case Qt::RoundCap:
-            stream() << "stroke-linecap=\"round\" ";
+            s << "stroke-linecap=\"round\" ";
             break;
         default:
             qWarning("Unhandled cap style");
         }
         switch (spen.joinStyle()) {
         case Qt::MiterJoin:
-            stream() << "stroke-linejoin=\"miter\" "
+            s << "stroke-linejoin=\"miter\" "
                         "stroke-miterlimit=\""<<spen.miterLimit()<<"\" ";
             break;
         case Qt::BevelJoin:
-            stream() << "stroke-linejoin=\"bevel\" ";
+            s << "stroke-linejoin=\"bevel\" ";
             break;
         case Qt::RoundJoin:
-            stream() << "stroke-linejoin=\"round\" ";
+            s << "stroke-linejoin=\"round\" ";
             break;
         case Qt::SvgMiterJoin:
-            stream() << "stroke-linejoin=\"miter\" "
+            s << "stroke-linejoin=\"miter\" "
                         "stroke-miterlimit=\""<<spen.miterLimit()<<"\" ";
             break;
         default:
             qWarning("Unhandled join style");
         }
     }
-    void qbrushToSvg(const QBrush &sbrush)
+    void qbrushToSvg(const QBrush &sbrush, QTextStream & s)
     {
         d_func()->brush = sbrush;
         switch (sbrush.style()) {
         case Qt::SolidPattern: {
             QString color, colorOpacity;
             translate_color(sbrush.color(), &color, &colorOpacity);
-            stream() << "fill=\"" << color << "\" "
+            s << "fill=\"" << color << "\" "
                         "fill-opacity=\""
                      << colorOpacity << "\" ";
             d_func()->attributes.fill = color;
@@ -434,22 +450,22 @@ public:
             saveLinearGradientBrush(sbrush.gradient());
             d_func()->attributes.fill = QString::fromLatin1("url(#%1)").arg(d_func()->currentGradientName);
             d_func()->attributes.fillOpacity = QString();
-            stream() << QLatin1String("fill=\"url(#") << d_func()->currentGradientName << QLatin1String(")\" ");
+            s << QLatin1String("fill=\"url(#") << d_func()->currentGradientName << QLatin1String(")\" ");
             break;
         case Qt::RadialGradientPattern:
             saveRadialGradientBrush(sbrush.gradient());
             d_func()->attributes.fill = QString::fromLatin1("url(#%1)").arg(d_func()->currentGradientName);
             d_func()->attributes.fillOpacity = QString();
-            stream() << QLatin1String("fill=\"url(#") << d_func()->currentGradientName << QLatin1String(")\" ");
+            s << QLatin1String("fill=\"url(#") << d_func()->currentGradientName << QLatin1String(")\" ");
             break;
         case Qt::ConicalGradientPattern:
             saveConicalGradientBrush(sbrush.gradient());
             d_func()->attributes.fill = QString::fromLatin1("url(#%1)").arg(d_func()->currentGradientName);
             d_func()->attributes.fillOpacity = QString();
-            stream() << QLatin1String("fill=\"url(#") << d_func()->currentGradientName << QLatin1String(")\" ");
+            s << QLatin1String("fill=\"url(#") << d_func()->currentGradientName << QLatin1String(")\" ");
             break;
         case Qt::NoBrush:
-            stream() << QLatin1String("fill=\"none\" ");
+            s << QLatin1String("fill=\"none\" ");
             d_func()->attributes.fill = QLatin1String("none");
             d_func()->attributes.fillOpacity = QString();
             return;
@@ -458,7 +474,7 @@ public:
            break;
         }
     }
-    void qfontToSvg(const QFont &sfont)
+    void qfontToSvg(const QFont &sfont, QTextStream & s)
     {
         Q_D(QSvgPaintEngine);
 
@@ -488,12 +504,23 @@ public:
         d->attributes.font_family = d->font.family();
         d->attributes.font_style = d->font.italic() ? QLatin1String("italic") : QLatin1String("normal");
 
-        *d->stream << "font-family=\"" << d->attributes.font_family << "\" "
-                      "font-size=\"" << d->attributes.font_size << "\" "
-                      "font-weight=\"" << d->attributes.font_weight << "\" "
-                      "font-style=\"" << d->attributes.font_style << "\" "
-                   << endl;
+        s << "font-family=\"" << d->attributes.font_family << "\" "
+             "font-size=\"" << d->attributes.font_size << "\" "
+             "font-weight=\"" << d->attributes.font_weight << "\" "
+             "font-style=\"" << d->attributes.font_style << "\" "
+             << endl;
+    }
+
+    void setViewBoxClip(bool clip) {
+        Q_D(QSvgPaintEngine);
+        d->clip = clip;
     }
+    
+    bool viewBoxClip() const {
+        Q_D(const QSvgPaintEngine);
+        return d->clip;
+    }
+
 };
 
 class QSvgGeneratorPrivate
@@ -808,6 +835,27 @@ int QSvgGenerator::metric(QPaintDevice::PaintDeviceMetric metric) const
     return 0;
 }
 
+/*!
+    \property QSvgGenerator::resolution
+    \brief do not draw objects outside the viewBox
+    \since 4.7
+
+    When specified objects drawn compleatly outsite the viewBox
+    are not include in the output SVG.
+
+    \sa viewBox
+*/
+
+bool QSvgGenerator::viewBoxClip() const {
+    Q_D(const QSvgGenerator);
+    return d->engine->viewBoxClip();
+}
+
+void QSvgGenerator::setViewBoxClip(bool clip) {
+    Q_D(QSvgGenerator);
+    d->engine->setViewBoxClip(clip);
+}
+
 /*****************************************************************************
  * class QSvgPaintEngine
  */
@@ -908,10 +956,13 @@ void QSvgPaintEngine::drawImage(const QRectF &r, const QImage &image,
                                 const QRectF &sr,
                                 Qt::ImageConversionFlag flags)
 {
-    //Q_D(QSvgPaintEngine);
+    Q_D(QSvgPaintEngine);
 
     Q_UNUSED(sr);
     Q_UNUSED(flags);
+    if (d->clip && !d->matrix.mapRect(r).intersects(d->viewBox)) return;
+    d->emitState();
+
     stream() << "<image ";
     stream() << "x=\""<<r.x()<<"\" "
                 "y=\""<<r.y()<<"\" "
@@ -932,53 +983,35 @@ void QSvgPaintEngine::drawImage(const QRectF &r, const QImage &image,
 void QSvgPaintEngine::updateState(const QPaintEngineState &state)
 {
     Q_D(QSvgPaintEngine);
-    QPaintEngine::DirtyFlags flags = state.state();
-
-    // always stream full gstate, which is not required, but...
-    flags |= QPaintEngine::AllDirty;
-
-    // close old state and start a new one...
-    if (d->afterFirstUpdate)
-        *d->stream << "</g>\n\n";
-
-    *d->stream << "<g ";
 
-    if (flags & QPaintEngine::DirtyBrush) {
-        qbrushToSvg(state.brush());
-    }
-
-    if (flags & QPaintEngine::DirtyPen) {
-        qpenToSvg(state.pen());
-    }
-
-    if (flags & QPaintEngine::DirtyTransform) {
-        d->matrix = state.matrix();
-        *d->stream << "transform=\"matrix(" << d->matrix.m11() << ','
-                   << d->matrix.m12() << ','
-                   << d->matrix.m21() << ',' << d->matrix.m22() << ','
-                   << d->matrix.dx() << ',' << d->matrix.dy()
-                   << ")\""
-                   << endl;
-    }
-
-    if (flags & QPaintEngine::DirtyFont) {
-        qfontToSvg(state.font());
-    }
-
-    if (flags & QPaintEngine::DirtyOpacity) {
-        if (!qFuzzyIsNull(state.opacity() - 1))
-            stream() << "opacity=\""<<state.opacity()<<"\" ";
-    }
-
-    *d->stream << '>' << endl;
-
-    d->afterFirstUpdate = true;
+    d->stateString="";
+    QTextStream stateStream(&d->stateString);
+    stateStream << "<g ";
+    qbrushToSvg(state.brush(), stateStream);
+    qpenToSvg(state.pen(), stateStream);
+    
+    d->matrix = state.matrix();
+    stateStream << "transform=\"matrix(" << d->matrix.m11() << ','
+                << d->matrix.m12() << ','
+                << d->matrix.m21() << ',' << d->matrix.m22() << ','
+                << d->matrix.dx() << ',' << d->matrix.dy()
+                << ")\""
+                << endl;
+    qfontToSvg(state.font(), stateStream);
+    
+    if (!qFuzzyIsNull(state.opacity() - 1))
+        stateStream << "opacity=\""<<state.opacity()<<"\" ";
+    
+    stateStream << '>' << endl;
 }
 
 void QSvgPaintEngine::drawPath(const QPainterPath &p)
 {
     Q_D(QSvgPaintEngine);
 
+    if (d->clip && !d->matrix.mapRect(p.boundingRect()).intersects(d->viewBox)) return;
+    d->emitState();
+    
     *d->stream << "<path vector-effect=\""
                << (state->pen().isCosmetic() ? "non-scaling-stroke" : "none")
                << "\" fill-rule=\""
@@ -1024,12 +1057,15 @@ void QSvgPaintEngine::drawPolygon(const QPointF *points, int pointCount,
 {
     Q_ASSERT(pointCount >= 2);
 
-    //Q_D(QSvgPaintEngine);
+    Q_D(QSvgPaintEngine);
 
     QPainterPath path(points[0]);
     for (int i=1; i<pointCount; ++i)
         path.lineTo(points[i]);
 
+    if (d->clip && !d->matrix.mapRect(path.boundingRect()).intersects(d->viewBox)) return;
+    d->emitState();
+
     if (mode == PolylineMode) {
         stream() << "<polyline fill=\"none\" vector-effect=\""
                  << (state->pen().isCosmetic() ? "non-scaling-stroke" : "none")
@@ -1051,6 +1087,12 @@ void QSvgPaintEngine::drawTextItem(const QPointF &pt, const QTextItem &textItem)
     if (d->pen.style() == Qt::NoPen)
         return;
 
+    if (d->clip) {
+        QRectF b=painter()->boundingRect( QRectF(pt, QSize()) , Qt::AlignLeft, textItem.text());
+        if (!d->matrix.mapRect(b).intersects(d->viewBox)) return;
+    }
+    d->emitState();
+
     const QTextItemInt &ti = static_cast<const QTextItemInt &>(textItem);
     QString s = QString::fromRawData(ti.chars, ti.num_chars);
 
@@ -1060,7 +1102,7 @@ void QSvgPaintEngine::drawTextItem(const QPointF &pt, const QTextItem &textItem)
                   "stroke=\"none\" "
                   "xml:space=\"preserve\" "
                   "x=\"" << pt.x() << "\" y=\"" << pt.y() << "\" ";
-    qfontToSvg(textItem.font());
+    qfontToSvg(textItem.font(), *d->stream);
     *d->stream << " >"
                << Qt::escape(s)
                << "</text>"
diff --git a/src/svg/qsvggenerator.h b/src/svg/qsvggenerator.h
index faecc60928..3d067f9b26 100644
--- a/src/svg/qsvggenerator.h
+++ b/src/svg/qsvggenerator.h
@@ -96,6 +96,9 @@ public:
 
     void setResolution(int dpi);
     int resolution() const;
+
+    void setViewBoxClip(bool clip);
+    bool viewBoxClip() const;
 protected:
     QPaintEngine *paintEngine() const;
     int metric(QPaintDevice::PaintDeviceMetric metric) const;
diff --git a/src/xmlpatterns/api/qcoloroutput_p.h b/src/xmlpatterns/api/qcoloroutput_p.h
index 7911e89625..18ff05396f 100644
--- a/src/xmlpatterns/api/qcoloroutput_p.h
+++ b/src/xmlpatterns/api/qcoloroutput_p.h
@@ -70,8 +70,8 @@ namespace QPatternist
             ForegroundShift = 10,
             BackgroundShift = 20,
             SpecialShift    = 20,
-            ForegroundMask  = ((1 << ForegroundShift) - 1) << ForegroundShift,
-            BackgroundMask  = ((1 << BackgroundShift) - 1) << BackgroundShift
+            ForegroundMask  = 0x1f << ForegroundShift,
+            BackgroundMask  = 0x7  << BackgroundShift
         };
 
     public:
diff --git a/tools/configure/configureapp.cpp b/tools/configure/configureapp.cpp
index 9d5daf25c4..5ac7a345d9 100644
--- a/tools/configure/configureapp.cpp
+++ b/tools/configure/configureapp.cpp
@@ -2395,9 +2395,9 @@ bool Configure::checkAvailability(const QString &part)
         available = qmakeSpec == "win32-msvc2005" || qmakeSpec == "win32-msvc2008" ||
                 qmakeSpec == "win32-msvc2010" || qmakeSpec == "win32-msvc2012" || qmakeSpec.startsWith("win32-g++");
         if (dictionary[ "SHARED" ] == "no") {
-            cout << endl << "WARNING: Using static linking will disable the WebKit module." << endl
-                 << endl;
-            available = false;
+           // cout << endl << "WARNING: Using static linking will disable the WebKit module." << endl
+           //      << endl;
+          //  available = false;
         }
     } else if (part == "AUDIO_BACKEND") {
         available = true;
